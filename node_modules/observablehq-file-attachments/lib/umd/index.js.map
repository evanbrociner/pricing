{"version":3,"file":"index.js","sources":["../../src/symbols.ts","../../node_modules/d3-dsv/src/dsv.js","../../node_modules/d3-dsv/src/csv.js","../../node_modules/d3-dsv/src/tsv.js","../../node_modules/d3-dsv/src/autoType.js","../../node_modules/base64-js/index.js","../../src/AFile.ts","../../src/util.ts","../../src/AFileAwait.ts","../../src/AFileSystem.ts","../../src/regenerator.ts"],"sourcesContent":["/**\n * Symbols for attaching special data to files and directories.\n *\n * @module symbols\n */\nexport const METADATA = Symbol.for('METADATA');\nexport const CACHED_METADATA = Symbol.for('CACHED_METADATA');\n\n/**\n * The special symbol [[FILE]] is used to dynamically compute file entries in a directory.\n * These should be a function that accepts `(`_fs_, _path_, _name_, _version_`)`.\n *\n * It will be invoked when a requested file is not found.\n *\n * * _fs_: The [[AFileSystem]] object\n * * _path_: The full requested path\n * * _name_: The name of the requested file, in this directory\n * * _version_: The requested version. This will be `-1` in the case where no version is supplied.\n *\n * The result should be an array with at least one version, including the requested one.\n * The helper fileVersion can be use to make this simpler, taking the version name and the file.\n * The _rest_ argument will be an empty array.\n *\n * Return `null` to decline to create a file of the given name or version.\n *\n * @see DIRECTORY\n */\nexport const FILE = Symbol.for('FILE');\n\n/**\n * The special symbol `DIRECTORY` is used to dynamically compute directory entries.\n * This should be a function that accepts `(`_fs_, _path_, _name_`)`.\n *\n * * It will be invoked when a requested directory is not found.\n *\n * * _fs_: The [[AFileSystem]] object\n * * _path_: The full requested path\n * * _name_: The name of the requested directory, in its parent.\n *\n * The function should return an object describing the directory heirarchy that should reside under this name.\n * The returned structure can include its own [[DIRECTORY]] and [[FILE]] entries to further auto-create\n * levels of directory and their files.\n *\n * `null` should be returned to decline creating a directory of the given name.\n *\n * @see FILE\n */\nexport const DIRECTORY = Symbol.for('DIRECTORY');\nexport const TAGS = Symbol.for('TAGS');\n","var EOL = {},\n    EOF = {},\n    QUOTE = 34,\n    NEWLINE = 10,\n    RETURN = 13;\n\nfunction objectConverter(columns) {\n  return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n    return JSON.stringify(name) + \": d[\" + i + \"] || \\\"\\\"\";\n  }).join(\",\") + \"}\");\n}\n\nfunction customConverter(columns, f) {\n  var object = objectConverter(columns);\n  return function(row, i) {\n    return f(object(row), i, columns);\n  };\n}\n\n// Compute unique columns in order of discovery.\nfunction inferColumns(rows) {\n  var columnSet = Object.create(null),\n      columns = [];\n\n  rows.forEach(function(row) {\n    for (var column in row) {\n      if (!(column in columnSet)) {\n        columns.push(columnSet[column] = column);\n      }\n    }\n  });\n\n  return columns;\n}\n\nfunction pad(value, width) {\n  var s = value + \"\", length = s.length;\n  return length < width ? new Array(width - length + 1).join(0) + s : s;\n}\n\nfunction formatYear(year) {\n  return year < 0 ? \"-\" + pad(-year, 6)\n    : year > 9999 ? \"+\" + pad(year, 6)\n    : pad(year, 4);\n}\n\nfunction formatDate(date) {\n  var hours = date.getUTCHours(),\n      minutes = date.getUTCMinutes(),\n      seconds = date.getUTCSeconds(),\n      milliseconds = date.getUTCMilliseconds();\n  return isNaN(date) ? \"Invalid Date\"\n      : formatYear(date.getUTCFullYear(), 4) + \"-\" + pad(date.getUTCMonth() + 1, 2) + \"-\" + pad(date.getUTCDate(), 2)\n      + (milliseconds ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds, 2) + \".\" + pad(milliseconds, 3) + \"Z\"\n      : seconds ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds, 2) + \"Z\"\n      : minutes || hours ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \"Z\"\n      : \"\");\n}\n\nexport default function(delimiter) {\n  var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n\\r]\"),\n      DELIMITER = delimiter.charCodeAt(0);\n\n  function parse(text, f) {\n    var convert, columns, rows = parseRows(text, function(row, i) {\n      if (convert) return convert(row, i - 1);\n      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n    });\n    rows.columns = columns || [];\n    return rows;\n  }\n\n  function parseRows(text, f) {\n    var rows = [], // output rows\n        N = text.length,\n        I = 0, // current character index\n        n = 0, // current line number\n        t, // current token\n        eof = N <= 0, // current token followed by EOF?\n        eol = false; // current token followed by EOL?\n\n    // Strip the trailing newline.\n    if (text.charCodeAt(N - 1) === NEWLINE) --N;\n    if (text.charCodeAt(N - 1) === RETURN) --N;\n\n    function token() {\n      if (eof) return EOF;\n      if (eol) return eol = false, EOL;\n\n      // Unescape quotes.\n      var i, j = I, c;\n      if (text.charCodeAt(j) === QUOTE) {\n        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);\n        if ((i = I) >= N) eof = true;\n        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        return text.slice(j + 1, i - 1).replace(/\"\"/g, \"\\\"\");\n      }\n\n      // Find next delimiter or newline.\n      while (I < N) {\n        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        else if (c !== DELIMITER) continue;\n        return text.slice(j, i);\n      }\n\n      // Return last token before EOF.\n      return eof = true, text.slice(j, N);\n    }\n\n    while ((t = token()) !== EOF) {\n      var row = [];\n      while (t !== EOL && t !== EOF) row.push(t), t = token();\n      if (f && (row = f(row, n++)) == null) continue;\n      rows.push(row);\n    }\n\n    return rows;\n  }\n\n  function preformatBody(rows, columns) {\n    return rows.map(function(row) {\n      return columns.map(function(column) {\n        return formatValue(row[column]);\n      }).join(delimiter);\n    });\n  }\n\n  function format(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join(\"\\n\");\n  }\n\n  function formatBody(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return preformatBody(rows, columns).join(\"\\n\");\n  }\n\n  function formatRows(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  }\n\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n\n  function formatValue(value) {\n    return value == null ? \"\"\n        : value instanceof Date ? formatDate(value)\n        : reFormat.test(value += \"\") ? \"\\\"\" + value.replace(/\"/g, \"\\\"\\\"\") + \"\\\"\"\n        : value;\n  }\n\n  return {\n    parse: parse,\n    parseRows: parseRows,\n    format: format,\n    formatBody: formatBody,\n    formatRows: formatRows,\n    formatRow: formatRow,\n    formatValue: formatValue\n  };\n}\n","import dsv from \"./dsv.js\";\n\nvar csv = dsv(\",\");\n\nexport var csvParse = csv.parse;\nexport var csvParseRows = csv.parseRows;\nexport var csvFormat = csv.format;\nexport var csvFormatBody = csv.formatBody;\nexport var csvFormatRows = csv.formatRows;\nexport var csvFormatRow = csv.formatRow;\nexport var csvFormatValue = csv.formatValue;\n","import dsv from \"./dsv.js\";\n\nvar tsv = dsv(\"\\t\");\n\nexport var tsvParse = tsv.parse;\nexport var tsvParseRows = tsv.parseRows;\nexport var tsvFormat = tsv.format;\nexport var tsvFormatBody = tsv.formatBody;\nexport var tsvFormatRows = tsv.formatRows;\nexport var tsvFormatRow = tsv.formatRow;\nexport var tsvFormatValue = tsv.formatValue;\n","export default function autoType(object) {\n  for (var key in object) {\n    var value = object[key].trim(), number, m;\n    if (!value) value = null;\n    else if (value === \"true\") value = true;\n    else if (value === \"false\") value = false;\n    else if (value === \"NaN\") value = NaN;\n    else if (!isNaN(number = +value)) value = number;\n    else if (m = value.match(/^([-+]\\d{2})?\\d{4}(-\\d{2}(-\\d{2})?)?(T\\d{2}:\\d{2}(:\\d{2}(\\.\\d{3})?)?(Z|[-+]\\d{2}:\\d{2})?)?$/)) {\n      if (fixtz && !!m[4] && !m[7]) value = value.replace(/-/g, \"/\").replace(/T/, \" \");\n      value = new Date(value);\n    }\n    else continue;\n    object[key] = value;\n  }\n  return object;\n}\n\n// https://github.com/d3/d3-dsv/issues/45\nconst fixtz = new Date(\"2019-01-01T00:00\").getHours() || new Date(\"2019-07-01T00:00\").getHours();","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/**\n * A wrapper for data from other than [FileAttachment](https://observablehq.com/@observablehq/file-attachments)\n * instances, presenting (nearly) the same interface.\n *\n * @module AFile\n */\n\nimport { CACHED_METADATA, METADATA } from './symbols';\nimport { Files, IAFile, Metadata, DataOptions } from './types';\nimport { dsv, toArrayBuffer } from './util';\nimport {fromByteArray} from 'base64-js';\n\n/**\n * The target data format for decision-making about conversions.\n */\nexport type DataFormat = 'json' | 'text' | 'url' | 'arrayBuffer' | 'blob' | 'csv' | 'tsv' | 'stream';\n\n/**\n * `new AFile(`_name_, _data_, _metadata_`)`\n *\n * This implements the same interface as [FileAttachment](https://observablehq.com/@observablehq/file-attachments), but works with supplied data in a variety of forms:\n * * Stringâ€”depending on the type requested, this may involve parsing or converting to an ArrayBuffer, Blob, or ReadableStream. _options_ arguments to the various extractors can include `{utf8:` _false_`}` to use UTF16 rather than UTF8 encoding.\n * * ArrayBuffer\n * * ReadableStream\n * * Blob\n * * JSON-compatible objects\n * * Arrays such as would be returned from {@link csv | .csv()} or {@link tsv | .tsv() }. Non-arrays will be converted to strings and parsed.\n * * A function. returning the value or a promise to the value. This is the most useful form, as it defers computation until needed. Except in the case of a `ReadableStream`, the result is cached. The function is called with the following arguments:\n *     * _file_: the [[AFile]].\n *     * _method_: One of `json`, `text`. `arrayBuffer`, `stream`, `url`, `csv`, `tsv`. These indicate how the data will be used, allowing the function to choose how to represent it. the usual conversions will be applied as needed, however, so it may be safely ignored.\n *     * _options_: The options supplied to the method accessing the data.\n * * Arbitrary data not described above, which can be retrieved unchanged via the `.json()` method\n * * A `Promise` that resolves to any of the above.\n *\n * _metadata_ is either an object with metadata to be combined, or a string, which is interpreted as the `contentType`, as a shorthand when that is the only metadata being supplied.\n *\n * All operations are asynchronous.\n */\nexport class AFile implements IAFile {\n    [METADATA]: Metadata;\n    [CACHED_METADATA]: Metadata;\n    name: string;\n    data: any;\n    ['content-type']: string;\n    #dataResult: any;\n    #noCache: boolean = false;\n\n    /**\n     * Construct a new [[AFile]]\n     * @param name Name of the file\n     * @param data Data for the file. It will be converted as needed.\n     * @param metadata Optional metadata for the file.\n     */\n    constructor(name: string, data: any, metadata: Partial<Metadata> = {}) {\n        // Allow specifying the contentType by just giving the mime type.\n        if (typeof metadata === 'string') {\n            metadata = { name, contentType: metadata };\n        }\n        this[METADATA] = {  ...metadata, name };\n        this.name = name;\n        this.data = data;\n        // Infer a contentType;\n        let { contentType } = metadata;\n        this['content-type'] = contentType =\n            contentType ||\n            (typeof data === 'string'\n            ? 'text/plain'\n            : data.constructor === Array\n            ? 'application/json'\n            : data.constructor === Object\n            ? 'application/json'\n            : 'application/binary');\n        this[METADATA].contentType = contentType;\n    }\n\n    /**\n     * Internal method.\n     * @param type Method that is requesting the data, to handle any prepatory conversions needed\n     * @param opts Any options passed to the original method\n     * @returns A `Promise` resolving to the data in the requested form.\n     */\n    async getData(type: DataFormat, opts: DataOptions): Promise<any> {\n        let data = await ((!this.#noCache && this.#dataResult) || this.data);\n        if (data instanceof AFile) {\n            return data.getData(type, opts);\n        }\n        if (typeof data === 'function') {\n            this.#dataResult = Promise.resolve(data(this, type, opts)).then(\n                d => ((this.#noCache = d instanceof ReadableStream), d)\n            );\n            data = await this.#dataResult;\n            if (this.#noCache) {\n                // Don't hang onto results we're not going to use again.\n                this.#dataResult = undefined;\n            }\n        }\n        if (data instanceof ReadableStream && type !== 'stream') {\n            let result = [];\n            const reader = await data.getReader();\n            let value: any;\n            let done: boolean = false;\n            let count = 0;\n            while (!done) {\n                const r = await reader.read();\n                if (r.value) {\n                    result.push(r.value);\n                    count += r.value.byteLength;\n                }\n                done = done || r.done;\n            }\n            const buffer = new ArrayBuffer(count);\n            const ar = new Uint8Array(buffer);\n            let offset = 0;\n            for (const chunk of result) {\n                ar.set(chunk, offset);\n                offset += chunk.byteLength;\n            }\n            return buffer;\n        }\n        if (!this.#noCache) {\n            this.data = data;\n        }\n        return data;\n    }\n\n    /**\n     * Return the data as JSON (as a Promise)\n     * @param opts Options. The valid option is `utf8`, which defaults to true\n     * @returns A `Promise` that resolves to a JSON value.\n     */\n    async json(opts: DataOptions = { utf8: true }) {\n        const data = await this.getData('json', opts);\n        if (\n            data instanceof Blob ||\n            data instanceof ReadableStream ||\n            data instanceof ArrayBuffer\n        ) {\n            return JSON.parse(await this.text(opts));\n        }\n        return data;\n    }\n\n    /**\n     * Return the data as a string.\n     * @param opts Options. The valid option is `utf8`, which defaults to true\n     * @returns A `Promise` that resolves to a text string.\n     */\n    async text(opts: DataOptions = { utf8: true }) {\n        const { utf8 = true } = opts;\n        const data = await this.getData('text', opts);\n        if (typeof data === 'string') return data;\n        if (data instanceof ArrayBuffer) {\n            if (utf8) {\n                return new TextDecoder().decode(new Uint8Array(data));\n            } else {\n                return String.fromCodePoint(...new Uint16Array(data));\n            }\n        }\n        if (data instanceof Blob) {\n            if (utf8) {\n                return new TextDecoder().decode(\n                    new Uint8Array(await data.arrayBuffer())\n            );\n            } else {\n                return String.fromCodePoint(\n                    ...new Uint16Array(await data.arrayBuffer())\n            );\n            }\n        }\n        return JSON.stringify(data);\n    }\n\n    /**\n     * Obtain `Promise` to a data URL with the data.\n     * @param opts Options. The valid option is `utf8`, which defaults to true\n     * @returns A `Promise` that resolves to a data URL with the data.\n     */\n    async url(opts: DataOptions = { utf8: true }) {\n        const data = await this.getData('url', opts);\n        const mime = this?.['content-type'];\n        if (typeof data === 'string') {\n            return `data:${mime};UTF-8,${data}`;\n        }\n        const buf = await this.arrayBuffer();\n        const arr = new Uint8Array(buf);\n        const str = fromByteArray(arr)\n        return `data:${mime};base64,${str}`;\n    }\n\n    /**\n     * Return the data in an `ArrayBuffer` backed with a byte array.\n     * @param opts Options. The valid option is `utf8`, which defaults to true\n     * @returns A `Promise` which resolves to an array buffer with the data\n     */\n    async arrayBuffer(opts: DataOptions = { utf8: true }) {\n        const { utf8 = true } = opts;\n        const data = await this.getData('arrayBuffer', opts);\n        if (data instanceof ArrayBuffer) {\n            return data;\n        }\n        if (data instanceof Blob) {\n            return data.arrayBuffer();\n        }\n        // No direct path to arrayBuffer. Convert to text, then to array buffer.\n        return toArrayBuffer(await this.text(opts), opts);\n    }\n\n    /**\n     * Return the data in the form of a `Blob`\n     * @param opts Options. The valid option is `utf8`, which defaults to true\n     * @returns A `Promise` that resolves to a `Blob`\n     */\n    async blob(opts: DataOptions = {utf8: true}) {\n        const data = await this.getData('blob', opts);\n        if (data instanceof Blob) {\n            return data;\n        }\n        return new Blob([new Uint8Array(await this.arrayBuffer(opts))]);\n    }\n\n    /**\n     * Interpret the data as CSV text. Uses D3's CSV/TSV parser.\n     * @param opts Options. The valid option is `utf8`, which defaults to true\n     * @returns A `Promise` which returns the data parsed as CSV\n     */\n    async csv(opts: DataOptions = { utf8: true }) {\n        const data = await this.getData('csv', opts);\n        if (Array.isArray(data)) return data;\n        if (data.constructor === Object) return data;\n        return dsv(await this.text(), \",\", opts);\n    }\n\n    /**\n     * Interpret the data as TSV text. Uses D3's CSV/TSV parser.\n     * @param opts Options. The valid option is `utf8`, which defaults to true\n     * @returns A `Promise` which returns the data parsed as TSV\n     */\n    async tsv(opts: DataOptions = { utf8: true }) {\n        const data = await this.getData('tsv', opts);\n        if (Array.isArray(data)) return data;\n        if (data.constructor === Object) return data;\n        return dsv(await this.text(), \"\\t\", opts);\n    }\n\n    async stream(opts: DataOptions = { utf8: true }) {\n        let data = await this.getData('stream', opts);\n        if (data instanceof ReadableStream) {\n            return data;\n        }\n        return new ReadableStream({\n            pull: async controller => {\n            const data = await this.arrayBuffer();\n            const array = new Uint8Array(data);\n            controller.enqueue(array);\n            controller.close();\n            }\n        });\n    }\n\n    /**\n     * Preserve the class name across minification.\n     */\n    [Symbol.toStringTag]: 'AFile';\n}\n\n","/**\n * General utilities\n * @module util\n */\n\nimport { METADATA, TAGS } from \"./symbols\";\nimport { FileAttachment, Files, Metadata, Tree, Version, VFile, DataOptions, PromiseOr } from \"./types\";\n\nimport * as d3 from 'd3-dsv';\nimport { any } from \"ramda\";\nimport { AFile } from \"./AFile\";\n\n/**\n * like 'throw', but a function rather than a statement.\n * @param e The exception or string to be thrown.\n */\nexport const Throw = (e: Error | string) => {\n    if (e instanceof Error) {\n        throw e;\n    }\n    throw new Error(e);\n}\n\n/**\n * A type guard to distinguish directory trees and file arrays.\n * @param t The object, which should be a directory tree or a files array\n * @returns `true` if the argument is a `Files` array\n */\nexport const isFiles = (t?: Tree | Files): t is Files => Array.isArray(t);\n\n/**\n * A type guard to distinguish directory trees and file arrays.\n * @param t The object, which should be a directory tree or a files array\n * @returns `true` if the argument is a `Tree`\n */\nexport const isTree = (t?: Tree | Files): t is Tree => t instanceof Object;\n\n/**\n * A type checker that verifies the argument is a file array, not a directory tree.\n * Throws an error if given something else\n * @param t A tree or a file array\n * @returns A file array or `null` if the argument was undefined\n */\nexport const asFiles = (t?: Tree | Files): Files | null =>\n    isFiles(t)\n        ? t\n        : t === undefined || t === null\n            ? null\n            : Throw(`Unexpected file level`);\n\n/**\n * A type checker that verifies the argument is a tree, not a file array. Throws an error\n * if given something else.\n * @param t A tree or a file array\n * @returns Tree or `null` if the argument was undefined.\n */\nexport const asTree = (t?: Tree | Files): Tree | null =>\n    isTree(t)\n        ? t\n        : t === undefined || t === null\n            ? null\n            : Throw(`Unexpected directory level`);\n\nconst isFunction = (t: any) => t instanceof Function;\n\n/**\n * A type guard that determines if the argument is a [FileAttachment](https://observablehq.com/@observablehq/file-attachments)\n * @param a A [FileAttachment](https://observablehq.com/@observablehq/file-attachments) or [[AFile]]\n * @returns `true` if argument is a [FileAttachment](https://observablehq.com/@observablehq/file-attachments)\n */\nexport const isFileAttachment = (a: any): a is FileAttachment =>\n    a\n    && isFunction(a?.json)\n    && isFunction(a?.text)\n    && isFunction(a?.blob)\n    && isFunction(a?.buffer)\n    && isFunction(a?.stream)\n    && isFunction(a?.url)\n    && a.constructor !== Object;\n\n/**\n * Canonicalize the version. Produces:\n * * an index into the array\n * * a string index into the [[TAGS]] object\n * * `null`, if `0` version (state before any versions).\n * @param version\n * @param length the number of versions, to use for range checking and negative versions\n * @returns a number, string, or `null`\n */\nconst canonicalizeVersion = (version: Version | null | undefined, length: number): Version | null => {\n    version = version ?? -1;\n    if (typeof version === 'string') {\n        switch (version) {\n            case 'latest':\n                return length - 1;\n            case 'earliest':\n                return 0;\n            case '*':\n                throw new Error(`Illegal version: ${version}`);\n        }\n        // If a number passed as a string convert to a number.\n        if (/^[-+]?\\d+$/.test(version)) {\n            return canonicalizeVersion(Number.parseInt(version, 10), length);\n        }\n        // Tag\n        return version;\n    }\n    version = version ?? -1;\n    if (version === 0) {\n        // The initial state is no file.\n        return null;\n    }\n    // Negative versions count from most recent.\n    return version < 0\n        ? length + version < 0\n            ? null\n            : length + version\n        : version - 1;\n}\n\n/**\n * Add a file at a specific version or label in a [[Files]] array.\n * This is an internal tool for implementing [[FILE]] handlers.\n * @param files The Files array\n * @param version The version to delete. Either a version number or a label\n * @returns void\n */\nexport const getVersion = (files: Files, version: Version): VFile | null => {\n    const cVersion = canonicalizeVersion(version, files.length);\n    return cVersion === null\n        ? null\n        : typeof cVersion === 'string'\n            ? files[TAGS]?.[cVersion] ?? null\n            : files[cVersion] ?? null;\n};\n\n/**\n * Wrap an [[AFile]] in a [[Files]] version array, with the specified\n * versions or labels assigned to it.\n * @param file the [[AFile]]\n * @param versions zero or more [[Version]]s (positive numbers or strings)\n * @returns a [[Files]] array.\n */\nexport const versions = (file: AFile, ...versionList: Version[]) => {\n    if (versionList.length === 0) {\n        versionList = [1];\n    }\n    const files: Files = [];\n    versionList.forEach(v => setVersion(files, v, file));\n    return files;\n};\n\n/**\n * Convenience method to construct an entry in a [[AFileSystem]] tree.\n * Takes a name and a data item, optional metadata, and list of versions,\n * and constructs the appropriate [[Files]] array for the tree.\n *\n * Simplest usage:\n * ```javascript\n * F = new AFileSystem({\n *   myFile: file('myFile', (myData));\n * });\n *\n * Advanced usage that supplies a creation date as metadata, and gives the file\n * a version of 1 and a label of 'tested';\n * ```javascript\n * F = new AFileSystem({\n *   myFile: file('myFile', (myData), {creationDate}, 1, 'tested');\n * });\n * ```\n * @param name The name of the file\n * @param data The data to store\n * @param metadata The metadata to associate with both array and file\n * @param versionList A list of versions to store the file under, or `[1]`.\n * @returns\n */\nexport function file(name: string, data: any, metadata?: Partial<Metadata> | null | undefined, ...versionList: Version[]): Files;\nexport function file(name: string, data: any, ...versionList: Version[]): Files;\nexport function file(name: string, data: any, metadata?: Partial<Metadata>|Version|null|undefined, ...versionList: Version[]) {\n    if (!metadata) {\n        const mData = {name};\n        const file = new AFile(name, data);\n        const meta2 = {...mData, ...(file[METADATA] ?? {})};\n        return meta(versions(file, ...versionList), meta2)\n    } if (typeof metadata === 'string' || typeof metadata === 'number') {\n        const mData = {name};\n        const file = new AFile(name, data);\n        const meta2 = {...mData, ...(file[METADATA] ?? {})};\n        return meta(versions(file, metadata, ...versionList), meta2)\n    } else {\n        const mData = {name, ...(metadata ?? {})};\n        const file = new AFile(name, data, metadata);\n        const meta2 = {...mData, ...(file[METADATA] ?? {})};\n        return meta(versions(file, ...versionList), meta2);\n    }\n};\n\n/**\n * Convenience method to construct an entry in a [[AFileSystem]] tree,\n * without having to specifiy the name multiple times.\n * Takes a name and a data item, optional metadata, and list of versions,\n * and constructs the appropriate [[Files]] array for the tree.\n *\n * Simplest usage:\n * ```javascript\n * F = new AFileSystem({\n *   myFile: file('myFile', (myData));\n * });\n *\n * Advanced usage that supplies a creation date as metadata, and gives the file\n * a version of 1 and a label of 'tested';\n * ```javascript\n * F = new AFileSystem({\n *   ...entry('myFile', (myData), {creationDate}, 1, 'tested');\n * });\n * ```\n * @param name The name of the file\n * @param data The data to store\n * @param metadata The metadata to associate with both array and file\n * @param versionList A list of versions to store the file under, or `[1]`.\n * @returns\n */\nexport function entry(name: string, data: any, metadata?: Partial<Metadata> | null | undefined, ...versionList: Version[]): Tree;\nexport function entry(name: string, data: any, ...versionList: Version[]): Tree;\nexport function entry(name: string, data: any, metadata?: Partial<Metadata>|Version|null|undefined, ...versionList: Version[]) {\n    return {[name]: file(name, data, metadata as Partial<Metadata>, ...versionList)};\n};\n\n\n/**\n * Add a file at a specific version or label in a [[Files]] array.\n * This is an internal tool for implementing [[FILE]] handlers.\n * @param files The Files array\n * @param version The version to set. Either a version number or a label\n * @param newFile The [FileAttachment](https://observablehq.com/@observablehq/file-attachments) or [[AFile]]\n * @returns void\n */\nexport const setVersion = (files: Files, version: Version, newFile: VFile): void => {\n    const cVersion = canonicalizeVersion(version, files.length);\n    if (cVersion === null) {\n        throw new Error(`Cannot set version ${version}`);\n    } else if (typeof cVersion === 'string') {\n        if (!files[TAGS]) {\n            files[TAGS] = {};\n        }\n        files[TAGS]![version] = newFile;\n    } else {\n        files[cVersion] = newFile;\n    }\n};\n\n/**\n * Delete a specific version from a [[Files]] array. This is an internal tool for implementing\n * [[FILE]] handlers\n * @param files The Files array\n * @param version The version to delete. Either a version number or a label. The special label '*' deletes all versions.\n * @returns void\n */\nexport const deleteVersion = (files: Files, version: Version): void => {\n    switch (version) {\n        case '*':\n            files.length = 0;\n            files[TAGS] = {};\n            files[METADATA] = files[METADATA] ?? {name: files[METADATA]!.name};\n            return;\n    }\n    const cVersion = canonicalizeVersion(version, files.length);\n    if (cVersion === null) {\n        return;\n    } else if (typeof version === 'string') {\n        // Tag\n        const tags = files?.[TAGS];\n        if (tags) {\n            delete tags[version];\n        }\n        return;\n    } else {\n        delete files[version];\n    }\n};\n\n/**\n * Encode a `string` into an `ArrayBuffer`.\n * @param s The `string` to be encoded\n * @returns An `ArrayBuffer` with the string data as UTF-16\n */\nexport const encodeString16 = (s: string) => {\n    const ab = new ArrayBuffer(s.length * 2);\n    const buf = new Uint16Array(ab);\n    for (let i = 0; i < s.length; i++) {\n      buf[i] = s.codePointAt(i)!;\n    }\n    return ab;\n  };\n\n/**\n * Convert a `string` to an `ArrayBuffer`, in either UTF8 or UTF16 formats.\n * @param s\n * @param param1\n * @returns an `ArrayBuffer` with the `string`'s content in the requested format.\n */\nexport const toArrayBuffer = (s: string, {utf8 = true}: DataOptions = {utf8: true}) => {\n    if (utf8) {\n        return new TextEncoder().encode(s).buffer\n    } else {\n        return encodeString16(s);\n    }\n};\n\n/**\n * Convert an `ArrayBuffer` to a `string`.\n * @param ab An `ArrayBuffer`\n * @param param1\n * @returns the string\n */\nexport const fromArrayBuffer = (ab: ArrayBuffer, {utf8 = true}: DataOptions = {utf8: true}) => {\n    return new TextDecoder(utf8 ? 'utf-8' : 'utf-16').decode(ab);\n};\n\n/**\n * Associate a _metadata_ object with the specified file (or array of file\n * versions). This is normally used to annotate entries in the [[AFileSystem]]\n * tree.\n */\nexport const meta = <T>(obj: T, metadata: Metadata) =>\n   obj && Object.defineProperty(obj, METADATA, { value: metadata });\n\nconst nullTyper = undefined as unknown as typeof d3.autoType;\n/**\n *\n * @param data The data to be parsed\n * @param delimiter The field delimiter, either `\"\\t\"` or `\",\"`.\n * @param options\n * @returns\n */\nexport function dsv(data: string, delimiter: '\\t' | ',', { array = false, typed = false, utf8 = false }: DataOptions = {}) {\n    const typer = typed ? d3.autoType : nullTyper;\n    switch (delimiter) {\n        case '\\t':\n            if (array) {\n                return d3.tsvParseRows(data, typer);\n            } else {\n                return d3.tsvParse(data, typer);\n            }\n        case ',':\n            if (array) {\n                return d3.csvParseRows(data, typer);\n            } else {\n                return d3.csvParse(data, typer);\n            }\n    }\n  }","/**\n * Proxy wrapper for returned values.\n *\n *  @module\n */\n\nimport { CACHED_METADATA, METADATA } from \"./symbols\";\nimport { IAFile, IAFileAwait, JsonObject, Metadata, VFile } from \"./types\";\n\n/**\n * This accepts a `Promise`, and delegates its methods to the resolved result of the `Promise`.\n *\n * If the eventual result is null, the invoking the data access methods will return `undefined`.\n *\n * Use {@link AFileAwait.exists} to throw an {@link VirtualFileNotFound} error if the file is not found.\n * ```javascript\n * const data = FS.find('/nofile').exists.json();\n * ```\n */\nexport class AFileAwait implements IAFileAwait {\n    #target: Promise<VFile|null>;\n    #name: string | undefined = '(unresolved)';\n    /**\n     *\n     * @param target The `Promise` of a result.\n     * @param name The name of the file, if available.\n     */\n    constructor(target: Promise<VFile|null>, name?: string) {\n        if (name === undefined) {\n            this.#target = target\n                .then(t => {\n                    if (t) {\n                        this.#name = t.name ?? this.#name;\n                        this[METADATA] = {\n                            name: this.#name,\n                            ...(this[METADATA] ?? {}),\n                            ...(t[METADATA] ?? {})\n                        };\n                    }\n                    return t;\n                });\n        } else {\n            this.#name = name;\n            this.#target = target;\n        }\n    }\n    async url(): Promise<string|undefined> {\n        return (await this.#target)?.url();\n    }\n    async json(): Promise<JsonObject|undefined> {\n        return (await this.#target)?.json();\n    }\n    async blob(): Promise<Blob|undefined> {\n        return (await this.#target)?.blob();\n    }\n    async text(): Promise<string|undefined> {\n        return (await this.#target)?.text();\n    }\n    async arrayBuffer(): Promise<ArrayBuffer|undefined> {\n        return (await this.#target)?.arrayBuffer();\n    }\n\n    async csv(): Promise<string | undefined> {\n        return (await this.#target)?.text();\n    }\n\n    async tsv(): Promise<string | undefined> {\n        return (await this.#target)?.text();\n    }\n\n    /**\n     * @returns the name, if it was supplied on construction, or if\n     * the promise has resolved. Otherwise, returns `'(unresolved)'`;\n     */\n    get name(): string {\n        return this.#name ?? `(unresolved)`;\n    }\n\n    /**\n     * Awaiting on this will yield the original result, including `null` if not found.\n     */\n    get target() {\n        return this.#target;\n    }\n\n    /**\n     * Chaining method that throws an error if the file was not found.\n     * @returns The underlying file object.\n     */\n    get exists() {\n        const ntarget = this.#target\n            .then(t => {\n                if (!t) {\n                    throw new VirtualFileNotFound(`Virtual file not found: ${this.name}`);\n                }\n                return t;\n            });\n        return new AFileAwait(ntarget, this.#name);\n    }\n\n    [METADATA]: Metadata | undefined;\n    [CACHED_METADATA]: Metadata | undefined;\n\n    /**\n     * Preserve the class name across minification.\n     */\n    [Symbol.toStringTag]: 'AFileAwait';\n}\n\n/**\n * The error thrown when a file is not found in the virtual filesystem.\n * This is only thrown by [.check()](#AFileAwait.check).\n */\nexport class VirtualFileNotFound extends Error {\n    constructor(message = `Virtual file not found`) {\n        super(message);\n    }\n\n    /**\n     * Preserve the class name across minification.\n     */\n    [Symbol.toStringTag]: 'VirtualFileNotFound';\n}","/**\n * The main entry for creating a virtual data filesystem.\n *\n * ```javascript\n * import { AFileSystem, AFile} from '@bobkerns/file-attachments'\n *\n * F = new AFileSystem(\n *     {\n *         data: {\n *             // Arrays denote file versions.\n *             table1: [\n *                 FileAttachment('Table1.json'),\n *                 FileAttachment('Table1.json@2')\n *             ],\n *             table2: [AFile('table2', {data: [[1, 5, 3] [2, 6, 4]]})]\n *         },\n *         test: {\n *             table1: [FileAttachment('Table1-test.json')]\n *         }\n *     }\n *   });\n * // Make table2 appear in the /test directory as well.\n * F.copy('/data/table2', '/test/table2'); // Perhaps more like a hard link\n * // Label Version 2 of /data/table1 as 'release'\n * // It can then be referenced as /label/table1@release, even if additional\n * // versions are added later.\n * F.label('/data/table1@2', 'release');\n *\n * // The notebook awaits\n * TABLE1 = F.find('/data/table1').json();\n *\n * // Doesn't exist, so returns undefined\n * NO_FILE = F.find('/noFile').json();\n *\n * // To get an error if the file doesn't exist:\n * ERROR_FILE = F.find('/noFile').exists.json();\n *\n * // To get a file, once it is available\n * AWAIT_FILE = F.waitFor('/notYet').json();\n *\n * // To add a file:\n * F.add('/notYet', new AFile('notYet', {Some: 'data'}));\n *\n * // To get a file's data when added and receive updates.\n * UPDATED_FILE = F.watch('/updatedFile').json();\n *\n * // Add some updates.\n * {\n *     for (i in range(0, 10)) {\n *         await sleep(1000);\n *         F.add('/updatedFile', new AFile('/updatedFile', {data: i}));\n *     }\n * }\n *\n * // Metadata\n * METADATA_TABLE1 = F.metadata('/test/table2');\n * ```\n *\n * @module AFileSystem\n * @preferred\n * @packageDocumentation\n */\n\nimport {asFiles, asTree, getVersion, isFileAttachment, setVersion, Throw} from './util';\nimport { Files, Regenerable, Tree, Version, FileAttachment, Metadata, VFile, PromiseOr } from './types';\nimport { METADATA, FILE, DIRECTORY, CACHED_METADATA } from './symbols';\nimport { regenerator } from './regenerator';\nimport { AFileAwait } from './AFileAwait';\n\nlet nameNum = 0;\n\nconst meta = (obj: any, metadata: any) => obj && Object.defineProperty(obj, METADATA, { value: metadata });\n\ninterface Visitor<T> {\n    createFiles?: CreateFilesAction,\n    createDirectory?: CreateDirectoryAction,\n    file?: FileAction<T>,\n    directory?: DirectoryAction<T>\n}\n\ntype CreateFilesAction = (filesystem: AFileSystem, path: string, name: string, version: Version, tree: Tree, files: Files)\n    => PromiseOr<Files | null>;\n\ntype FileAction<T> = (path: string, name: string, version: Version, files: Files)\n        => PromiseOr<T>;\n\ntype CreateDirectoryAction =\n    ((filesystem: AFileSystem, path: string, name: string, rest: string[], tree: Tree) => PromiseOr<Tree> | null)\n    | (() => null);\n\ntype DirectoryAction<T> = (path: string, name: string, tree: Tree)\n    => PromiseOr<T>;\n\n/**\n * Traverse the filesystem, ultimately performing _action_ on the found file.\n * Missing files or directories are handled by createAction; the default is to\n * return null.\n * @param filesystem\n * @param path\n * @param tree\n * @param visitor\n * @returns\n */\nconst traverse = <T>(filesystem: AFileSystem, path: string, tree: Tree, visitor: Visitor<T | null>) => {\n    const {\n        file: fileAction = () => null,\n        directory: directoryAction = () => null,\n        createFiles = () => null,\n        createDirectory = () => null\n    } = visitor;\n    const recurse = async ([head, ...rest]: string[], tree: Tree | null): Promise<T | null> => {\n        if (!tree) return null;\n        if (head === '') {\n            // Allows an initial '/'.\n            return !tree ? null : recurse(rest, tree);\n        } if (head === undefined) {\n            throw new Error(`Accessing root as file.`);\n        } else if (rest.length === 0) {\n            // We're at the end of the path, so this names the file.\n            const [name, versionName] = head.split('@');\n\n            let files = asFiles(tree[name]);\n            if (!files) {\n                files = await tree[FILE]?.(filesystem, path, name, versionName, rest, tree)\n                    ?? await createFiles(filesystem, path, name, versionName, tree, files ?? [])\n                    ?? [];\n                if (files) {\n                    tree[name] = files;\n                }\n            }\n            if (!files) return null;\n            tree[name] = files;\n            return fileAction(path, name, versionName, files)\n        } else {\n            let ntree = asTree(tree[head]);\n            if (!ntree) {\n                ntree = await tree[DIRECTORY]?.(filesystem, path, head, rest, tree)\n                    ?? await createDirectory(filesystem, path, head, rest, tree)\n                    ?? null\n                if (ntree) {\n                    tree[head] = ntree;\n                }\n            }\n            directoryAction(path, head, tree)\n            return recurse(rest, ntree);\n        }\n    };\n    return recurse(path.split('/'), tree);\n};\n\nconst errorWrapper = (fs: AFileSystem, op: string, ...args: any[]) => <F extends Function>(fn: F) => {\n    try {\n        return fn();\n    } catch (e) {\n        e.message = `${fs.name}.${op}(${args.map(a => JSON.stringify(a)).join(', ')}) ${e.message}`;\n        throw e;\n    }\n};\n\n/**\n * The `AFileSystem` constructor takes a single argument, which represents an initial filesystem content.\n *\n * Every Object (not subclasses, but literal objects) represent a directory,\n * while every array holds the versions of a logical file.\n *\n * Versions are specified on lookup by appending _@version_ to the path. No version\n * specified is the same as `@latest`, which obtains the highest numbered version\n * (the last in the array). You can ignore named versions (labels), or even multiple\n * versions, but files are always identified by being in an array.\n *\n * A file can be any value, but normally they will be either an\n * [FileAttachment](https://observablehq.com/@observablehq/file-attachments) or an\n * [AFile](#AFile); they implement the same interface.\n *\n * The actual file is not returned, but rather an [AFileAwait](#AFileAwait). This is a proxy with the same\n * methods, but the methods return `undefined` if the file specified is not found.\n */\nexport class AFileSystem implements Regenerable {\n    readOnly: boolean;\n    name: string;\n    tree: Tree;\n    subscription: AsyncGenerator<this>;\n    updateCount: number;\n    errored: (e: Error) => void;\n    updated: (n: this) => void;\n\n    /**\n     *\n     * @param tree The specification of what directories and files to initialize the filesystem with\n     * @param options Optional options: _readOnly_ and _name_\n     */\n    constructor(tree: Tree, options: {readOnly?: boolean, name?: string} = {}) {\n        const {readOnly, name} = options;\n        this.readOnly = !!readOnly;\n        this.name = name || `FS_${++nameNum}`;\n        this.tree = tree || Throw(`Missing tree.`);\n        this.subscription = regenerator(this);\n        this.subscription.next();\n        this.updateCount = 0;\n        this.errored = () => undefined;\n        this.updated = () => undefined;\n    }\n\n    /**\n     * Find the file at the given (possibly versioned) path.\n     *\n     * @param path the full pathname to the desired file\n     * @returns An {@link AFileAwait}\n     */\n    find(path: string) {\n        return errorWrapper(this, 'find', path)(() => {\n            const getFile = (path: string, name: string, version: Version, files: Files): VFile | null => {\n                if (files.constructor === Object) {\n                    throw new Error(`${path} is a directory.`);\n                }\n                const file = getVersion(files, version);\n                if (!file) return null;\n                if (Array.isArray(file) || file.constructor === Object) {\n                    throw new Error(`${path} is a directory`);\n                }\n                return file;\n            };\n            return new AFileAwait(traverse(this, path, this.tree, {file: getFile}));\n        })\n    }\n\n    /**\n     * Wait for the requested path. The return value is an async generator\n     *  that yields when the requested path is available.\n     * @param path Path to the file\n     * @returns An async generator yielding a value for the file when it becomes available..\n     */\n    async *waitFor(path: string) {\n        let v = this.find(path);\n        if (v) {\n            yield v;\n            return;\n        }\n        for await (const fs of this.subscription) {\n            const nv = fs.find(path);\n            if (nv) {\n                v = nv;\n                yield v;\n                return;\n            }\n        }\n    }\n\n    /**\n     * Wait for the requested path. The return value is an async generator\n     * that yields once for each value stored at path.\n     * @param path Path to the file\n     * @param nullOK if true, `null` will be returned by the generator whenever the file does not exist; by default it is filtered out.\n     * @returns An async generator yielding values for a file as it changes (new versions created/deleted).\n     */\n    async *watch(path: string, nullOK = false) {\n        let v = this.find(path);\n        if (v || nullOK) {\n            yield v;\n        }\n        for await (const fs of this.subscription) {\n            const nv = fs.find(path);\n            if (nv !== v) {\n                v = nv;\n                if (nullOK || v) {\n                    yield v;\n                }\n            }\n        }\n    }\n\n    /**\n     * Return the metadata for the requested path. Metadata can be associated with either a specific\n     * version, or the entire collection of versions at a path. The results are merged.\n     * @param path Path to the file\n     * @returns Promise yielding Metadata or `null` if the file is not found.\n     */\n    async metadata(path: string): Promise<Metadata | null> {\n        return errorWrapper(this, 'metadata', path)(() => {\n            const getMeta = async (path: string, name: string, version: Version,\n                                   files: Files): Promise<Metadata | null> => {\n                const file = getVersion(files, version);\n                if (!file) return null;\n                const filesMeta = files[METADATA] || {};\n                if (isFileAttachment(file) && !file[CACHED_METADATA]) {\n                    const headers = await (await fetch(await file.url(), {\n                                                                        method: 'HEAD'\n                                                                })\n                                                        ).headers;\n                    const attachMeta: Metadata = { name: file.name, url: await file.url() };\n                    headers.forEach((v, k) => {\n                    switch (k) {\n                        case 'content-length':\n                            attachMeta.length = Number.parseInt(v);\n                            break;\n                        case 'last-modified':\n                            attachMeta.modificationDate = new Date(v);\n                            break;\n                        case 'etag':\n                            attachMeta.etag = v;\n                            break;\n                        case 'content-type':\n                            attachMeta.contentType = v;\n                            break;\n                        default:\n                    }\n                    });\n                    const fileMeta = file[METADATA] || {};\n                    Object.defineProperty(file, CACHED_METADATA, {value: { ...filesMeta, ...fileMeta, ...attachMeta }});\n                }\n                const contentType = file['content-type'];\n                const fileMeta = contentType ? { 'content-type': contentType } : {name};\n                return {name, ...filesMeta, ...fileMeta, ...(file[CACHED_METADATA] ?? {}) };\n            };\n        return traverse<Metadata>(this, path, this.tree, {file: getMeta});\n        });\n    }\n\n    /**\n     * Add a new file at the specified path. If no version, or 'latest', adds a new version.\n     * Otherwise sets the specified version or label.\n     * @param path Path to store the file\n     * @param file The file, either an [FileAttachment](https://observablehq.com/@observablehq/file-attachments) or an [[AFile]].\n     * @returns the file\n     */\n    add(path: string, file: VFile) {\n        return errorWrapper(this, 'add', path, file)(() => {\n            if (this.readOnly) throw new Error(`Read only filesystem.`);\n                const createDirectory = (fs: AFileSystem, path: string, name: string, rest: string[], tree: Tree) => {\n                if (rest.length === 0) {\n                    return (tree[name] = [file]);\n                }\n                return (tree[name] = {});\n            };\n            const setFile = (path: string, name: string, version: Version, files: Files) => {\n                setVersion(files, version, file);\n                return file;\n            }\n            try {\n                return traverse(this, path, this.tree, {file: setFile, createDirectory});\n            } catch (e) {\n                this.errored(e);\n                throw e;\n            } finally {\n                this.updated(this);\n            }\n        });\n    }\n\n    /**\n     * Copy file from to. If 'latest' or unspecified, copies only the latest.\n     * @param from Path to the existing file\n     * @param to Path to the destination\n     * @returns the file copied\n     */\n    copy(from: string, to: string) {\n        return this.add(to, this.find(from));\n    }\n\n    /**\n     * Label the version at the specified path with 'label'.  A label selects a specific version of a file;\n     * it is not a property of a file version.\n     * @param path Path to the file\n     * @param label Label to add to the file\n     * @returns The file labeled.\n     */\n    label(path: string, label: string) {\n        const exp = path.split('/');\n        // Get the file name, stripping away the label or version if present.\n        const end = exp[exp.length - 1].split('@')[0];\n        // Replace the exploded path with the name and the new label\n        exp[exp.length - 1] = `${end}@${label}`;\n        // Turn it back into a path string\n        const to = exp.join('/');\n        // And copy.\n        return this.copy(path, to);\n    }\n\n    /**\n     * Preserve the class name across minification.\n     */\n    [Symbol.toStringTag]: 'AFileSystem';\n}\n","/**\n * A generator that returns an object whenever it has been signaled that the object has been updated.\n *\n * @module regenerator\n */\n\nimport { Regenerable } from \"./types\";\n\nexport async function* regenerator<T extends Regenerable>(obj: T): AsyncGenerator<T> {\n    let p = Promise.resolve(obj);\n    obj.updateCount = 0;\n    while (true) {\n      p = new Promise((acc, rej) => {\n        obj.updated = acc;\n        obj.errored = rej;\n      });\n      yield obj;\n      await p;\n      obj.updateCount++;\n    }\n  }"],"names":["METADATA","Symbol","for","CACHED_METADATA","FILE","DIRECTORY","TAGS","EOL","EOF","objectConverter","columns","Function","map","name","i","JSON","stringify","join","inferColumns","rows","columnSet","Object","create","forEach","row","column","push","pad","value","width","s","length","Array","formatDate","date","year","hours","getUTCHours","minutes","getUTCMinutes","seconds","getUTCSeconds","milliseconds","getUTCMilliseconds","isNaN","getUTCFullYear","getUTCMonth","getUTCDate","delimiter","reFormat","RegExp","DELIMITER","charCodeAt","parseRows","text","f","t","N","I","n","eof","eol","token","c","j","slice","replace","preformatBody","formatValue","formatRow","Date","test","parse","convert","object","customConverter","format","concat","formatBody","formatRows","csv","dsv","csvParse","csvParseRows","tsv","tsvParse","tsvParseRows","autoType","key","number","m","trim","NaN","match","fixtz","getHours","uint8","tmp","len","extraBytes","parts","maxChunkLength","len2","encodeChunk","lookup","revLookup","code","start","end","num","output","AFile","[object Object]","data","metadata","this","contentType","constructor","type","opts","getData","Promise","resolve","then","d","ReadableStream","undefined","result","reader","getReader","done","count","r","read","byteLength","buffer","ArrayBuffer","ar","Uint8Array","offset","chunk","set","utf8","Blob","TextDecoder","decode","String","fromCodePoint","Uint16Array","arrayBuffer","mime","buf","arr","fromByteArray","toArrayBuffer","isArray","pull","async","controller","array","enqueue","close","Throw","e","Error","asFiles","isFiles","asTree","isTree","isFunction","canonicalizeVersion","version","Number","parseInt","getVersion","files","cVersion","versions","file","versionList","v","setVersion","mData","meta2","meta","newFile","TextEncoder","encode","ab","codePointAt","encodeString16","obj","defineProperty","typed","typer","d3.autoType","d3.tsvParseRows","d3.tsvParse","d3.csvParseRows","d3.csvParse","AFileAwait","target","url","json","blob","exists","ntarget","VirtualFileNotFound","message","super","nameNum","traverse","filesystem","path","tree","visitor","fileAction","directory","directoryAction","createFiles","createDirectory","recurse","head","rest","versionName","split","ntree","errorWrapper","fs","op","args","fn","a","options","readOnly","subscription","p","updateCount","acc","rej","updated","errored","regenerator","next","find","nv","nullOK","filesMeta","stream","headers","fetch","method","attachMeta","k","modificationDate","etag","fileMeta","content-type","setFile","from","to","add","label","exp","copy","tags"],"mappings":"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"}