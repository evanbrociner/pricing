/**
 * A wrapper for data from other than [FileAttachment](https://observablehq.com/@observablehq/file-attachments)
 * instances, presenting (nearly) the same interface.
 *
 * @module AFile
 */
import { CACHED_METADATA, METADATA } from './symbols';
import { IAFile, Metadata, DataOptions } from './types';
/**
 * The target data format for decision-making about conversions.
 */
export declare type DataFormat = 'json' | 'text' | 'url' | 'arrayBuffer' | 'blob' | 'csv' | 'tsv' | 'stream';
/**
 * `new AFile(`_name_, _data_, _metadata_`)`
 *
 * This implements the same interface as [FileAttachment](https://observablehq.com/@observablehq/file-attachments), but works with supplied data in a variety of forms:
 * * Stringâ€”depending on the type requested, this may involve parsing or converting to an ArrayBuffer, Blob, or ReadableStream. _options_ arguments to the various extractors can include `{utf8:` _false_`}` to use UTF16 rather than UTF8 encoding.
 * * ArrayBuffer
 * * ReadableStream
 * * Blob
 * * JSON-compatible objects
 * * Arrays such as would be returned from {@link csv | .csv()} or {@link tsv | .tsv() }. Non-arrays will be converted to strings and parsed.
 * * A function. returning the value or a promise to the value. This is the most useful form, as it defers computation until needed. Except in the case of a `ReadableStream`, the result is cached. The function is called with the following arguments:
 *     * _file_: the [[AFile]].
 *     * _method_: One of `json`, `text`. `arrayBuffer`, `stream`, `url`, `csv`, `tsv`. These indicate how the data will be used, allowing the function to choose how to represent it. the usual conversions will be applied as needed, however, so it may be safely ignored.
 *     * _options_: The options supplied to the method accessing the data.
 * * Arbitrary data not described above, which can be retrieved unchanged via the `.json()` method
 * * A `Promise` that resolves to any of the above.
 *
 * _metadata_ is either an object with metadata to be combined, or a string, which is interpreted as the `contentType`, as a shorthand when that is the only metadata being supplied.
 *
 * All operations are asynchronous.
 */
export declare class AFile implements IAFile {
    #private;
    [METADATA]: Metadata;
    [CACHED_METADATA]: Metadata;
    name: string;
    data: any;
    ['content-type']: string;
    /**
     * Construct a new [[AFile]]
     * @param name Name of the file
     * @param data Data for the file. It will be converted as needed.
     * @param metadata Optional metadata for the file.
     */
    constructor(name: string, data: any, metadata?: Partial<Metadata>);
    /**
     * Internal method.
     * @param type Method that is requesting the data, to handle any prepatory conversions needed
     * @param opts Any options passed to the original method
     * @returns A `Promise` resolving to the data in the requested form.
     */
    getData(type: DataFormat, opts: DataOptions): Promise<any>;
    /**
     * Return the data as JSON (as a Promise)
     * @param opts Options. The valid option is `utf8`, which defaults to true
     * @returns A `Promise` that resolves to a JSON value.
     */
    json(opts?: DataOptions): Promise<any>;
    /**
     * Return the data as a string.
     * @param opts Options. The valid option is `utf8`, which defaults to true
     * @returns A `Promise` that resolves to a text string.
     */
    text(opts?: DataOptions): Promise<string>;
    /**
     * Obtain `Promise` to a data URL with the data.
     * @param opts Options. The valid option is `utf8`, which defaults to true
     * @returns A `Promise` that resolves to a data URL with the data.
     */
    url(opts?: DataOptions): Promise<string>;
    /**
     * Return the data in an `ArrayBuffer` backed with a byte array.
     * @param opts Options. The valid option is `utf8`, which defaults to true
     * @returns A `Promise` which resolves to an array buffer with the data
     */
    arrayBuffer(opts?: DataOptions): Promise<ArrayBufferLike>;
    /**
     * Return the data in the form of a `Blob`
     * @param opts Options. The valid option is `utf8`, which defaults to true
     * @returns A `Promise` that resolves to a `Blob`
     */
    blob(opts?: DataOptions): Promise<Blob>;
    /**
     * Interpret the data as CSV text. Uses D3's CSV/TSV parser.
     * @param opts Options. The valid option is `utf8`, which defaults to true
     * @returns A `Promise` which returns the data parsed as CSV
     */
    csv(opts?: DataOptions): Promise<any>;
    /**
     * Interpret the data as TSV text. Uses D3's CSV/TSV parser.
     * @param opts Options. The valid option is `utf8`, which defaults to true
     * @returns A `Promise` which returns the data parsed as TSV
     */
    tsv(opts?: DataOptions): Promise<any>;
    stream(opts?: DataOptions): Promise<ReadableStream<any>>;
    /**
     * Preserve the class name across minification.
     */
    [Symbol.toStringTag]: 'AFile';
}
//# sourceMappingURL=AFile.d.ts.map