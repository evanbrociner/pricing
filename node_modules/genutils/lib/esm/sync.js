const t=t=>"function"==typeof t,e=t=>t&&(l(t)||u(t)),r=e=>e&&t(e.next)&&t(e.return)&&t(e.throw)&&t(e[Symbol.iterator]);function n(t){if(r(t))return t;if(l(t)){const e=t;return function*(){for(;;){const t=e.next();if(t.done)return t.value;yield t.value}}()}if(u(t))return n(t[Symbol.iterator]());throw new Error(`Not iterable: ${t}`)}function o(t){if(r(t))return t;if(l(t))return t;if(u(t))return t[Symbol.iterator]();throw new Error(`Not iterable: ${t}`)}function i(t){return u(t)?t:{[Symbol.iterator]:()=>t}}const l=t=>t&&"function"==typeof t.next,u=t=>t&&"function"==typeof t[Symbol.iterator],c=(t,e)=>(...r)=>{try{return t(...r)}catch(t){return e?.(t)}};class a{returning;[Symbol.toStringTag];asArray(){return this._impl.asArray(this)}limit(t){return this._impl.limit(t,this)}forEach(t,e){this._impl.forEach(t,e,this)}map(t,e){return this._impl.map(t,e,this)}filter(t,e){return this._impl.filter(t,e,this)}flat(t=1){return this._impl.flat(t,this)}flatMap(t,e=1){return this._impl.flatMap(t,e,this)}slice(t=0,e=Number.POSITIVE_INFINITY){return this._impl.slice(t,e,this)}concat(...t){return this._impl.concat(this,...t)}reduce(t,e){return this._impl.reduce(t,e,this)}some(t,e){return this._impl.some(t,e,this)}every(t,e){return this._impl.every(t,e,this)}repeatLast(t=Number.POSITIVE_INFINITY){return this._impl.repeatLast(this,t)}repeat(t,e=Number.POSITIVE_INFINITY){const r=this._impl.repeat(t,e);return this._impl.concat(this,r)}zip(...t){return this._impl.zip(this,...t)}join(t){return this._impl.join(this,t)}sort(t){return this._impl.sort(t)(this)}}class s extends a{[Symbol.toStringTag]}const f=new class{of(...t){return this.enhance(t)}asArray(t){return[...i(t)]}limit(t,e){let r;function*n(e){let n,o=!1;try{for(let r=0;r<t;r++){const t=e.next(n);if(t.done)return t.value;try{n=yield t.value}catch(t){e.throw?.(t)}}o=!0;const i=new RangeError(`Generator produced excessive values > ${t}.`);throw e.throw?.(i),i}finally{o||e.return?.(r?.returning)}}return e?r=this.enhance(n(o(e))):t=>this.enhance(n(o(t)))}forEach(t,r,n){const i=(t,e,r)=>{const n=o(r);let i=0;for(;;){const r=n.next();if(r.done)return;t.call(e,r.value,i++)}};return n?i(t,r,n):e(r)?i(t,void 0,r):(e,n)=>i(t,n??r,e)}map(t,r,o){const i=(e,r)=>{const o=n(r);let i;return i=this.enhance(function*(){let r,n=0;for(;;)for(;;)try{for(;;){const i=o.next(r);if(i.done)return i.value;const l=t.call(e,i.value,n++);try{r=yield l}catch(t){o.throw(t)}}}finally{if(!o.return(i?.returning).done)break}}())};return o?i(r,o):e(r)?i(void 0,r):(t,e)=>i(e??r,t)}filter(t,r,o){const i=(e,r)=>{const o=n(r);let i;return i=this.enhance(function*(t){let r,n=0;for(;;)for(;;)try{for(;;){const i=o.next(r);if(i.done)return i.value;if(t.call(e,i.value,n++))try{r=yield i.value}catch(t){o.throw(t)}}}finally{const t=o.return?.(i?.returning);if(!t?.done)break}}(t))};return o?i(r,o):e(r)?i(void 0,r):(t,e)=>i(e??r,t)}flat(t,n){const i=(t,e)=>{let n;const i=new Set;return r(e)&&i.add(e),n=this.enhance(function*t(e,c){let a;for(;;)for(;;)try{for(;;){const n=e.next(a);if(n.done)return n.value;const s=n.value;r(s)&&i.add(s);try{c>0&&l(s)?yield*t(s,c-1):c>0&&u(s)?yield*t(o(s),c-1):a=yield n.value}catch(t){e.throw?.(t)}}}finally{const t=e.return?.(n?.returning);if(r(e)&&i.delete(e),t&&!t.done)break;for(const t of i)t.return(n?.returning)}}(o(e),t))};if("number"==typeof t){if(n){if(e(n))return i(t,n);throw new TypeError(`Invalid Genable: ${n}`)}return e=>i(t,e)}if(e(t))return i(n??1,t);throw new TypeError("Illegal arguments to flat()")}flatMap(t,r,i){const c=(e,r)=>{let i,c=0;return i=this.enhance(function*e(r,a){let s;for(;;)for(;;)try{for(;;){const i=r.next(s);if(i.done)return i.value;const f=t(i.value,c++);try{l(f)?a>1?yield*e(f,a-1):1===a?yield*n(f):yield f:u(f)?a>1?yield*e(o(f),a-1):1===a?yield*n(f):yield f:s=yield f}catch(t){r.throw?.(t)}}}finally{const t=r.return?.(i?.returning);if(t&&!t.done)break}}(o(r),e))};return e(i)?c(r??1,i):e(r)?c(1,r):(t,e)=>c(r??e??1,t)}slice(t,e,r){const n=r=>{const n=o(r);return this.enhance(function*(t,e){for(let e=0;e<t;e++){const t=n.next();if(t.done)return t.value}if(e===Number.POSITIVE_INFINITY)yield*i(n);else{let r;for(;;)try{for(let o=t;o<e;o++){const t=n.next(r);if(t.done)return t.value;try{r=yield t.value}catch(t){const e=n.throw?.(t);if(e){if(e.done)return e.value;r=yield e.value}}}}finally{const t=n.return?.();if(t&&!t.done)break}}}(t,e))};return r?n(r):n}concat(...t){let e;return e=this.enhance(function*(){let n=0;try{for(;n<t.length;n++)yield*i(t[n])}finally{for(;n<t.length;n++){const o=t[n];r(o)&&o.return(e?.returning)}}}())}reduce(t,r,n){const i=(e,r)=>{let n=e;if(void 0===n){const t=r.next();if(t.done)throw new TypeError("No initial value in reduce");n=t.value}for(;;){const e=r.next();if(e.done)return n;n=t(n,e.value)}};return e(n)?i(r,o(n)):e(r)?i(void 0,o(r)):(t,e)=>i(e??r,o(t))}some(t,r,n){const i=(e,r)=>{let n=0;for(;;){const o=r.next();if(o.done)return!1;if(t.call(e,o.value,n++))return!0}};return e(n)?i(r,o(n)):e(r)?i(void 0,o(r)):(t,e)=>i(e??r,o(t))}every(t,r,n){const i=(e,r)=>{let n=0;for(;;){const o=r.next();if(o.done)return!0;if(!t.call(e,o.value,n++))return!1}};if(e(n))return i(r,o(n));if(e(n))return(t,e)=>i(e??r,o(t));throw new Error(`Invalid argument to every: ${n??r}`)}repeatLast(t,e=Number.POSITIVE_INFINITY){const r=o(t);let n,i;return i=this.enhance(function*(){try{let t;for(;;){const e=r.next(n);if(e.done)break;try{n=yield t=e.value}catch(e){const n=r.throw?.(e);if(n){if(n.done)break;yield t=n.value}}}for(let r=0;r<e;r++)yield t}finally{r.return?.(i?.returning)}}())}repeat(t,e=Number.POSITIVE_INFINITY){return this.enhance(function*(){for(let r=0;r<e;r++)yield t}())}zip(...t){if(0===t.length)return this.enhance([]);const e=t.map(o);let r,n=!1;return r=this.enhance(function*(){try{for(;;){let r=[];for(const t of e){const e=t.next();if(e.done)return n=!0,e.value;r.push(e.value)}try{yield r}catch(e){for(const r of t)try{r.throw?.(e)}catch{}throw e}}}finally{if(!n)for(const e of t)try{e.return?.(r?.returning)}catch{}}}())}join(t,e){return"string"==typeof t?(e=t,t=>this.join(t,e)):[...i(t)].join(e)}merge(...t){let e,r=t.map(o);return e=this.enhance(function*(t){let r,n=!1,o=!0;try{for(;o;){o=!1;for(let e=0;e<t.length;e++){const n=t[e];if(n){const i=n.next(r);if(i.done)t[e]=null;else{o=!0;try{r=yield i.value}catch(e){t.forEach(c((t=>t?.throw?.(e))))}}}}}n=!0}finally{n||t.forEach(c((t=>t?.return?.(e?.returning))))}return e?.returning}(r))}sort(t){return(...e)=>this.merge(...e).asArray().sort(t)}enhance(t){const e=n(t),r=Object.getPrototypeOf(e),o=Object.create(s.prototype);return o.return=t=>(e.returning=t,r.return.call(e,t)),o[Symbol.iterator]=()=>e,Object.setPrototypeOf(e,s.prototype),e}};const h=Object.getPrototypeOf(function*(){}());Object.setPrototypeOf(s.prototype,(t=>{const e=Object.create(t);return(t=>{for(const r of Reflect.ownKeys(t))"constructor"!==r&&(e[r]=t[r])})(a.prototype),e})(h)),Object.defineProperty(s.prototype,"_impl",{value:f,writable:!1,enumerable:!1,configurable:!1});export{s as EnhancedGenerator,h as GenProto,f as Sync};
//# sourceMappingURL=sync.js.map
