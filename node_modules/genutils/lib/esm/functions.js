const r=r=>"function"==typeof r,t=r=>r&&(h(r)||S(r)),n=r=>r&&(m(r)||x(r)||S(r)),e=t=>t&&r(t.next)&&r(t.return)&&r(t.throw)&&r(t[Symbol.iterator]),o=t=>t&&r(t.next)&&r(t.return)&&r(t.throw)&&r(t[Symbol.asyncIterator]);function i(r){if(e(r))return r;if(h(r)){const t=r;return function*(){for(;;){const r=t.next();if(r.done)return r.value;yield r.value}}()}if(S(r))return i(r[Symbol.iterator]());throw new Error(`Not iterable: ${r}`)}function u(r){if(o(r))return r;if(m(r)){const t=r;return async function*(){for(;;){const r=await t.next();if(r.done)return r.value;yield r.value}}()}if(x(r))return u(r[Symbol.asyncIterator]());if(S(r))return u(r[Symbol.iterator]());throw new Error(`Not iterable: ${r}`)}function a(r){if(e(r))return r;if(h(r))return r;if(S(r))return r[Symbol.iterator]();throw new Error(`Not iterable: ${r}`)}function f(r){if(o(r))return r;if(x(r))return r[Symbol.asyncIterator]();if(S(r))return c(a(r));throw new Error(`Not iterable: ${r}`)}const c=r=>{const t=r;let n;return n=async function*(){let e,o=!1;try{for(;;){const r=await Promise.resolve(t.next());if(r.done)return o=!0,r.value;try{e=yield r.value}catch(r){throw await(t.throw?.(r)),r}}}finally{o||await(r.return?.(n.returning))}}()};function l(r){return S(r)?r:{[Symbol.iterator]:()=>r}}function y(r){return x(r)?r:S(r)?w(r):{[Symbol.asyncIterator]:()=>r}}async function*w(r){const t=r[Symbol.iterator]();let n;for(;;){const r=await t.next(n);if(r.done)return r.value;n=yield r.value}}function s(r){if(S(r)&&h(r))return r;if(S(r)){let t;const n=()=>t??(t=r[Symbol.iterator]()),e={[Symbol.iterator]:()=>e,next:r=>n().next(r),return:n().return&&(r=>n().return(r)),throw:n().throw&&(r=>n().throw(r))};return e}if(h(r)){const t={[Symbol.iterator]:()=>t,next:t=>r.next(t),return:r.return&&(t=>r.return(t)),throw:r.throw&&(t=>r.throw(t))};return t}throw new Error(`Not iterator nor iterable: ${r}`)}function b(r){if(x(r)&&m(r))return r;if(x(r)){let t;const n=()=>t??(t=r[Symbol.asyncIterator]()),e={[Symbol.asyncIterator]:()=>e,next:()=>n().next(),return:n().return&&(r=>n().return(r)),throw:n().throw&&(r=>n().throw(r))};return e}if(S(r))return w(r);if(m(r)){const t={[Symbol.asyncIterator]:()=>t,next:t=>r.next(t),return:r.return&&(t=>r.return(t)),throw:r.throw&&(t=>r.throw(t))};return t}throw new Error(`Not iterator nor iterable: ${r}`)}const h=r=>r&&"function"==typeof r.next,m=r=>r&&"function"==typeof r.next,S=r=>r&&"function"==typeof r[Symbol.iterator],x=r=>r&&"function"==typeof r[Symbol.asyncIterator],v=r=>h(r)&&S(r),d=r=>m(r)&&x(r),I=(r,t)=>(...n)=>{try{return r(...n)}catch(r){return t?.(r)}};export{I as doCatch,n as isAsyncGenable,o as isAsyncGenerator,x as isAsyncIterable,d as isAsyncIterableIterator,m as isAsyncIterator,r as isFunction,t as isGenable,e as isGenerator,S as isIterable,v as isIterableIterator,h as isIterator,u as toAsyncGenerator,y as toAsyncIterable,b as toAsyncIterableIterator,f as toAsyncIterator,i as toGenerator,l as toIterable,s as toIterableIterator,a as toIterator};
//# sourceMappingURL=functions.js.map
