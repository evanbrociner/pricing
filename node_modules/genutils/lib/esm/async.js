const t=t=>"function"==typeof t,e=t=>t&&(s(t)||f(t)||u(t)),r=e=>e&&t(e.next)&&t(e.return)&&t(e.throw)&&t(e[Symbol.asyncIterator]);function n(t){if(r(t))return t;if(s(t)){const e=t;return async function*(){for(;;){const t=await e.next();if(t.done)return t.value;yield t.value}}()}if(f(t))return n(t[Symbol.asyncIterator]());if(u(t))return n(t[Symbol.iterator]());throw new Error(`Not iterable: ${t}`)}function i(e){if((r=e)&&t(r.next)&&t(r.return)&&t(r.throw)&&t(r[Symbol.iterator]))return e;var r;if(c(e))return e;if(u(e))return e[Symbol.iterator]();throw new Error(`Not iterable: ${e}`)}function a(t){if(r(t))return t;if(f(t))return t[Symbol.asyncIterator]();if(u(t))return o(i(t));throw new Error(`Not iterable: ${t}`)}const o=t=>{const e=t;let r;return r=async function*(){let n,i=!1;try{for(;;){const t=await Promise.resolve(e.next());if(t.done)return i=!0,t.value;try{n=yield t.value}catch(t){throw await(e.throw?.(t)),t}}}finally{i||await(t.return?.(r.returning))}}()};function l(t){return f(t)?t:u(t)?async function*(t){const e=t[Symbol.iterator]();let r;for(;;){const t=await e.next(r);if(t.done)return t.value;r=yield t.value}}(t):{[Symbol.asyncIterator]:()=>t}}const c=t=>t&&"function"==typeof t.next,s=t=>t&&"function"==typeof t.next,u=t=>t&&"function"==typeof t[Symbol.iterator],f=t=>t&&"function"==typeof t[Symbol.asyncIterator];class y{returning;[Symbol.toStringTag];asArray(){return this._impl.asArray(this)}limit(t){return this._impl.limit(t,this)}forEach(t,e){this._impl.forEach(t,e,this)}map(t,e){return this._impl.map(t,e,this)}filter(t,e){return this._impl.filter(t,e,this)}flat(t=1){return this._impl.flat(t,this)}flatMap(t,e=1){return this._impl.flatMap(t,e,this)}slice(t=0,e=Number.POSITIVE_INFINITY){return this._impl.slice(t,e,this)}concat(...t){return this._impl.concat(this,...t)}reduce(t,e){return this._impl.reduce(t,e,this)}some(t,e){return this._impl.some(t,e,this)}every(t,e){return this._impl.every(t,e,this)}repeatLast(t=Number.POSITIVE_INFINITY){return this._impl.repeatLast(this,t)}repeat(t,e=Number.POSITIVE_INFINITY){const r=this._impl.repeat(t,e);return this._impl.concat(this,r)}zip(...t){return this._impl.zip(this,...t)}join(t){return this._impl.join(this,t)}sort(t){return this._impl.sort(t)(this)}}const h=new class{of(...t){return this.enhance(t)}async asArray(t){const e=a(t),r=[];for(;;){const t=await e.next();if(t.done)return r;r.push(t.value)}}limit(t,e){let r;async function*n(e){let n,i=!1;try{for(let r=0;r<t;r++){const t=await e.next(n);if(t.done)return t.value;try{n=yield t.value}catch(t){await(e.throw?.(t))}}i=!0;const a=new RangeError(`Generator produced excessive values > ${t}.`);throw await(e.throw?.(a)),a}finally{i||await(e.return?.(r?.returning))}}return e?r=this.enhance(n(a(e))):t=>this.enhance(n(a(t)))}forEach(t,r,n){const i=async(t,e,r)=>{const n=a(r);let i=0;for(;;){const r=await n.next();if(r.done)return;await t.call(e,r.value,i++)}};return n?i(t,r,n):e(r)?i(t,void 0,r):(e,n)=>i(t,n??r,e)}map(t,r,i){const a=(e,r)=>{const i=n(r);let a;return a=this.enhance(async function*(){let r,n=0;for(;;)for(;;)try{for(;;){const a=await i.next(r);if(a.done)return a.value;const o=await t.call(e,await a.value,n++);try{r=yield o}catch(t){await i.throw(t)}}}finally{if(!(await i.return(a?.returning)).done)break}}())};return i?a(r,i):e(r)?a(void 0,r):(t,e)=>a(e??r,t)}filter(t,r,i){const a=(e,r)=>{const i=n(r);let a;return a=this.enhance(async function*(t){let r,n=0;for(;;)for(;;)try{for(;;){const a=await i.next(r);if(a.done)return a.value;if(await t.call(e,a.value,n++))try{r=yield a.value}catch(t){await i.throw(t)}}}finally{if(!(await(i.return?.(a?.returning)))?.done)break}}(t))};return i?a(r,i):e(r)?a(void 0,r):(t,e)=>a(e??r,t)}flat(t,n){const i=(t,e)=>{let n;const i=new Set;return r(e)&&i.add(e),n=this.enhance(async function*t(e,o){let l;for(;;)for(;;)try{for(;;){const n=await e.next(l);if(n.done)return n.value;const c=n.value;r(c)&&i.add(c);try{o>0&&s(c)?yield*t(c,o-1):o>0&&(f(c)||u(c))?yield*t(a(c),o-1):l=yield n.value}catch(t){await(e.throw?.(t))}}}finally{const t=await(e.return?.(n?.returning));if(r(e)&&i.delete(e),t&&!t.done)break;for(const t of i)await t.return(n?.returning)}}(a(e),t))};if("number"==typeof t){if(n){if(e(n))return i(t,n);throw new TypeError(`Invalid Genable: ${n}`)}return e=>i(t,e)}if(e(t))return i(n??1,t);throw new TypeError("Illegal arguments to flat()")}flatMap(t,r,i){const o=(e,r)=>{let i,o=0;return i=this.enhance(async function*e(r,l){let c;for(;;)for(;;)try{for(;;){const i=await r.next(c);if(i.done)return i.value;const y=await t(i.value,o++);try{if(s(y))if(l>1)yield*e(y,l-1);else if(1===l){const t=a(y);yield*n(t)}else yield y;else f(y)||u(y)?l>1?yield*e(a(y),l-1):1===l?yield*n(y):yield y:c=yield y}catch(t){await(r.throw?.(t))}}}finally{const t=await(r.return?.(i?.returning));if(t&&!t.done)break}}(a(r),e))};return e(i)?o(r??1,i):e(r)?o(1,r):(t,e)=>o(r??e??1,t)}slice(t,e,r){const n=r=>{const n=a(r);return this.enhance(async function*(t,e){for(let e=0;e<t;e++){const t=await n.next();if(t.done)return t.value}if(e===Number.POSITIVE_INFINITY)yield*l(n);else{let r;for(;;)try{for(let i=t;i<e;i++){const t=await n.next(r);if(t.done)return t.value;try{r=yield t.value}catch(t){const e=await(n.throw?.(t));if(e){if(e.done)return e.value;r=yield e.value}}}}finally{const t=await(n.return?.());if(t&&!t.done)break}}}(t,e))};return r?n(r):n}concat(...t){let e;return e=this.enhance(async function*(){let n=0;try{for(;n<t.length;n++){const e=l(t[n]);yield*e}}finally{for(;n<t.length;n++){const i=t[n];r(i)&&await i.return(e?.returning)}}}())}reduce(t,r,n){const i=async(e,r)=>{let n=await e;if(void 0===n){const t=await r.next();if(t.done)throw new TypeError("No initial value in reduce");n=t.value}for(;;){const e=await r.next();if(e.done)return n;n=await t(n,e.value)}};return e(n)?i(r,a(n)):e(r)?i(void 0,a(r)):(t,e)=>i(e??r,a(t))}some(t,r,n){const i=async(e,r)=>{let n=0;for(;;){const i=await r.next();if(i.done)return!1;if(t.call(e,i.value,n++))return!0}};if(e(n))return i(r,a(n));if(e(n))return(t,e)=>i(e??r,a(t));throw new Error(`Invalid argument to some: ${n??r}`)}every(t,r,n){const i=async(e,r)=>{let n=0;for(;;){const i=await r.next();if(i.done)return!0;if(!t.call(e,i.value,n++))return!1}};if(e(n))return i(r,a(n));if((o=n)&&(c(o)||u(o)))return(t,e)=>i(e??r,a(t));var o;throw new Error(`Invalid argument to every: ${n??r}`)}repeatLast(t,e=Number.POSITIVE_INFINITY){const r=a(t);let n,i;return i=this.enhance(async function*(){try{let t;for(;;){const e=await r.next(n);if(e.done)break;try{n=yield t=e.value}catch(e){const n=await(r.throw?.(e));if(n){if(n.done)break;yield t=n.value}}}for(let r=0;r<e;r++)yield await t}finally{await(r.return?.(i?.returning))}}())}repeat(t,e=Number.POSITIVE_INFINITY){return this.enhance(async function*(){for(let r=0;r<e;r++)yield await t}())}zip(...t){if(0===t.length)return this.enhance([]);const e=t.map(a);let r,n=!1;return r=this.enhance(async function*(){try{for(;;){let r=[];for(const t of e){const e=await t.next();if(e.done)return n=!0,e.value;r.push(e.value)}try{yield r}catch(e){for(const r of t)try{await(r.throw?.(e))}catch{}throw e}}}finally{if(!n)for(const e of t)try{await(e.return?.(r?.returning))}catch{}}}())}join(t,e){return"string"==typeof t?(e=t,t=>this.join(t,e)):Promise.resolve(this.enhance(t).asArray()).then((t=>t.join(e)))}merge(...t){let e,r;const n=new Promise((t=>r=t));let i,o=t.length;const l=new Promise((()=>null));let c=[];return i=[...t.map((async(t,e)=>{const n=a(t);c[e]=n;const s=async t=>()=>{if(t.done)return i[e]=l,--o>0?null:(r(t),t);{const r=n.next().then(s);return i[e]=r,t}};return await n.next().then(s)})),n],e=h.enhance(async function*(){try{let r;for(;o;){const t=[];i.forEach((e=>t.push(e)));const e=await await Promise.race(t);if("function"==typeof e){let t=e();if(t){if(t.done)return t.value;r=yield t.value}}else if(e&&e.done)return e.value}}finally{if(o)for(let r=0;r<t.length;r++)(null===i[r]?null:c[r])?.return?.(e?.returning)}}())}sort(t){return async(...e)=>(await this.merge(...e).asArray()).sort(t)}enhance(t){const e=n(t),r=Object.getPrototypeOf(e),i=Object.assign(Object.create(w.prototype),r);return i.return=t=>(e.returning=t,r.return.call(e,t)),i[Symbol.asyncIterator]=()=>e,Object.setPrototypeOf(e,i),e}};class w extends y{}const d=Object.getPrototypeOf(async function*(){}());Object.setPrototypeOf(w.prototype,(t=>{const e=Object.create(t);return(t=>{for(const r of Reflect.ownKeys(t))"constructor"!==r&&(e[r]=t[r])})(y.prototype),e})(d)),Object.defineProperty(w.prototype,"_impl",{value:h,writable:!1,enumerable:!1,configurable:!1});export{h as Async,d as AsyncGenProto,w as EnhancedAsyncGenerator};
//# sourceMappingURL=async.js.map
