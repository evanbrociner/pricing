{"version":3,"file":"sync.js","sources":["../../src/functions.ts","../../src/enhancements.ts","../../src/sync.ts"],"sourcesContent":["/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * Functions to test (as typeguards) and coerce generators, iterators, etc.\n *\n * @packageDocumentation\n * @module functions\n * @preferred\n */\n\n\nimport type {Async, Sync, Genable, FullIterable, FullIterableIterator} from \"./types\";\n\n/**\n * Predicate/Type Guard for any function.\n * @param f\n */\nexport const isFunction = <A extends Function>(f: (A | any)): f is A => {\n    return typeof f === 'function';\n}\n\n/**\n * Predicate/type guard to determine if an object is [[Genable]]. An object is [[Genable]] if it\n * supports the `Iterator` or `Iterable` protocols. (Generators support both).\n * @param g\n */\nexport const isGenable = <T, TReturn = T, TNext = T>(g: Iterator<T, TReturn, TNext>|Iterable<T>|Generator<T, TReturn, TNext>|any):\n    g is Genable<T, Sync, TReturn, TNext> =>\n        g && (isIterator(g) || isIterable(g));\n\n\nexport const isAsyncGenable = <T, TReturn, TNext>(g: AsyncIterator<T, TReturn, TNext>|AsyncIterable<T>|AsyncGenerator<T,TReturn,TNext>|any):\n    g is Genable<T, Async, TReturn, TNext> =>\n        g && (isAsyncIterator<T, TReturn, TNext>(g) || isAsyncIterable<T, TReturn, TNext>(g) || isIterable<T, TReturn, TNext>(g));\n\n/**\n * Predicate/type guard to determine if an object is (or looks like, structurally) a Generator.\n * @param g\n */\nexport const isGenerator = <T, TReturn, TNext>(g: Genable<T, Sync, TReturn, TNext>|any): g is Generator<T, TReturn, TNext> =>\n    g &&\n    isFunction(g.next)\n    && isFunction(g.return)\n    && isFunction(g.throw)\n    && isFunction(g[Symbol.iterator]);\n\n/**\n * Predicate/type guard to determine if an object is (or looks like, structurally) a AsyncGenerator.\n * @param g\n */\nexport const isAsyncGenerator = <T, TReturn, TNext>(g: Genable<T, Async, TReturn, TNext>|any): g is AsyncGenerator<T> =>\n    g &&\n    isFunction(g.next)\n    && isFunction(g.return)\n    && isFunction(g.throw)\n    && isFunction(g[Symbol.asyncIterator]);\n\n/**\n * Coerce an object to an object that can act as a generator (that is, satisfy both `Iterator`\n * and `Iterable`).\n *\n * If it is an `Iterator` but not `Iterable`, or `Iterable` but not `Iterator`, it is wrapped\n * in a generator. This generator is __not__ enhanced. Use [[Sync.enhance]] on the result if\n * you need an enhanced generator.\n * @param i\n */\nexport function toGenerator<T, TReturn = T, TNext = T>(i: Genable<T, Sync, TReturn, TNext>): Generator<T, TReturn, TNext> {\n    if (isGenerator(i)) return i;\n    if (isIterator(i)) {\n        const it = i;\n\n        function* wrap() {\n            while (true) {\n                const r = it.next();\n                if (r.done) return r.value;\n                yield r.value;\n            }\n        }\n\n        return wrap();\n    } else if (isIterable(i)) {\n        return toGenerator(i[Symbol.iterator]() as Iterator<T, TReturn, TNext>);\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\n\n/**\n * Coerce an object to an object that can act as a async generator (that is, satisfy both `Iterator`\n * and `Iterable`).\n *\n * If it is an `AsyncIterator` but not `AsyncIterable`, or `AsyncIterable` but not `AsyncIterator`,\n * it is wrapped in an async generator. This generator is __not__ enhanced. Use [[Async.enhance]] on the result if\n * you need an enhanced generator.\n * @param i\n */\nexport function toAsyncGenerator<T, TReturn, TNext>(i: Genable<T, Async, TReturn, TNext>|Genable<T, Sync, TReturn, TNext>):\n    AsyncGenerator<T, TReturn, TNext>\n{\n    if (isAsyncGenerator(i)) return i;\n    if (isAsyncIterator(i)) {\n        const it = i;\n        async function* wrap() {\n            while (true) {\n                const r = await it.next();\n                if (r.done) return r.value;\n                yield r.value;\n            }\n        }\n        return wrap();\n    } else if (isAsyncIterable(i)) {\n        return toAsyncGenerator(i[Symbol.asyncIterator]()) as AsyncGenerator<T, TReturn, TNext>;\n    } else if (isIterable(i)) {\n        return toAsyncGenerator(i[Symbol.iterator]() as Iterator<T, TReturn, TNext>);\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\n/**\n * Coerce a sync [[Genable]] object to an `Iterator`. If the object is a `Generator` or an `Iterator` it is returned,\n * while if it is an `Iterable`, `[Symbol.iterator]`() is invoked.\n * @param i\n */\nexport function toIterator<T, TReturn, TNext>(i: Genable<T, Sync, TReturn, TNext>): Iterator<T, TReturn, TNext> {\n    if (isGenerator(i)) return i;\n    if (isIterator(i)) return i;\n    if (isIterable(i)) {\n        return i[Symbol.iterator]() as Iterator<T, TReturn, TNext>;\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\n\n/**\n * Coerce an async [[Genable]] object to an `AsyncIterator`. If the object is a `Generator` or an `Iterator` it is returned,\n * while if it is an `Iterable`, `[Symbol.iterator]`() is invoked.\n * @param i\n */\nexport function toAsyncIterator<T, TReturn, TNext = T>(i: Genable<T, Async, TReturn, TNext>): AsyncIterator<T, TReturn, TNext> {\n    if (isAsyncGenerator(i)) return i;\n    if (isAsyncIterable(i)) {\n        return i[Symbol.asyncIterator]() as AsyncIterator<T, TReturn, TNext>;\n    } else if (isIterable(i)) {\n        return asyncAdaptor(toIterator(i));\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\nconst asyncAdaptor = <T, TReturn, TNext>(i: Iterator<T, TReturn, TNext>):\n    AsyncGenerator<T, TReturn, TNext> =>\n{\n    const it = i as unknown as AsyncIterator<T>;\n    let self: AsyncGenerator<T> & {returning?: any};\n    async function* asyncAdaptor(): AsyncGenerator<T> {\n        let nr: any;\n        let done = false;\n        try {\n            while (true) {\n                const r = await Promise.resolve(it.next());\n                if (r.done) {\n                    done = true;\n                    return r.value;\n                }\n                try {\n                    nr = yield r.value;\n                } catch (e) {\n                    await it.throw?.(e);\n                    throw(e);\n                }\n            }\n        } finally {\n            if (!done) {\n                await i.return?.(self.returning);\n            }\n        }\n    }\n    return self = asyncAdaptor();\n};\n\n/**\n * Coerce a [[Genable]] object to `Iterable`. If it is already an `Iterable`, it is returned\n * unchanged. If it is an `Iterator`, it is wrapped in an object with a `[Symbol.iterator]`\n * method that returns the supplied iterator.\n * @param i\n */\nexport function toIterable<T, TReturn = T, TNext = T>(i: Genable<T,Sync,TReturn,TNext>):\n    FullIterable<T, Sync, TReturn, TNext>\n{\n    if (isIterable(i)) return i as FullIterable<T, Sync, TReturn, TNext>;\n    return {\n        [Symbol.iterator]: () => i\n    } as FullIterable<T, Sync, TReturn, TNext>;\n}\n\n\n/**\n * Coerce a [[Genable]] object to `AsyncIterable`. If it is already an `AsyncIterable`, it is returned\n * unchanged. If it is an `AsyncIterator`, it is wrapped in an object with a `[Symbol.asyncIterator]`\n * method that returns the supplied iterator.\n * @param i\n */\nexport function toAsyncIterable<T, TReturn, TNext>(i: Genable<T, Async, TReturn, TNext>):\n    FullIterable<T, Async, TReturn, TNext>\n{\n    if (isAsyncIterable<T, TReturn, TNext>(i)) return i;\n    if (isIterable<T, TReturn, TNext>(i)) {\n        return toAsyncIterable_adaptor<T, TReturn, TNext>(i) as\n            FullIterable<T, Async, TReturn, TNext>;\n    }\n    return {\n        [Symbol.asyncIterator]: () => i\n    } as FullIterable<T, Async, TReturn, TNext>;\n}\nasync function* toAsyncIterable_adaptor<T, TReturn, TNext>(iterable: Iterable<T>):\n    AsyncGenerator<T, TReturn, TNext>\n{\n    const it = iterable[Symbol.iterator]();\n    let nr: any = undefined;\n    while (true) {\n        const r = await it.next(nr);\n        if (r.done) return r.value;\n        nr = yield r.value;\n    }\n}\n\n// noinspection JSUnusedGlobalSymbols\n/**\n * Similar to [[toGenerator]], but does not require the presence of `Generator.return` or `Generator.throw` methods.\n * @param i\n */\nexport function toIterableIterator<T, TReturn = T, TNext = T>(i: Genable<T, Sync, TReturn, TNext>): FullIterableIterator<T, Sync, TReturn, TNext> {\n    if (isIterable(i) && isIterator(i)) return i as FullIterableIterator<T, Sync, TReturn, TNext>;\n    if (isIterable(i)) {\n        // Invoke [Symbol.iterator]() just once, on first use.\n        let _it: Iterator<T>|undefined = undefined;\n        const it = () => _it ?? (_it = i[Symbol.iterator]());\n        const iit: FullIterableIterator<T, Sync, TReturn, TNext> = {\n            [Symbol.iterator]: () => iit,\n            next: (val?: TNext) => it().next(val as undefined),\n            return: it().return && ((val) => it().return!(val)),\n            throw: it().throw && ((val) => it().throw!(val))\n        };\n        return iit;\n    }\n    if (isIterator(i)) {\n        const iit: FullIterableIterator<T, Sync, TReturn, TNext> = {\n            [Symbol.iterator]: () => iit,\n            next: (val?: TNext) => i.next(val!),\n            return: i.return && ((val) => i.return!(val)),\n            throw: i.throw && ((val) => i.throw!(val))\n        }\n        return iit;\n    }\n    throw new Error(`Not iterator nor iterable: ${i}`);\n}\n\n\n/**\n * Similar to [[toAsyncGenerator]], but does not require the presence of `AsyncGenerator.return` or\n * `AsyncGenerator.throw` methods.\n * @param i\n */\nexport function toAsyncIterableIterator<T, TReturn, TNext>(i: Genable<T, Async, TReturn, TNext>):\n    FullIterableIterator<T, Async, TReturn, TNext>\n{\n    if (isAsyncIterable<T, TReturn, TNext>(i) && isAsyncIterator<T, TReturn, TNext>(i)) {\n        return i as unknown as FullIterableIterator<T, Async, TReturn, TNext>;\n    }\n    if (isAsyncIterable<T, TReturn, TNext>(i)) {\n        // Invoke [Symbol.iterator]() just once, on first use.\n        let _it: AsyncIterator<T, TReturn, TNext>|undefined = undefined;\n        const it = () => _it ?? (_it = i[Symbol.asyncIterator]() as AsyncIterator<T, TReturn, TNext>);\n        const iit: AsyncIterableIterator<T> = {\n            [Symbol.asyncIterator]: () => iit,\n            next: () => it().next(),\n            return: it().return && ((val) => it().return!(val)),\n            throw: it().throw && ((val) => it().throw!(val))\n        };\n        return iit;\n    }\n    if (isIterable<T, TReturn, TNext>(i)) {\n        return toAsyncIterable_adaptor(i);\n    }\n    if (isAsyncIterator(i)) {\n        const iit: AsyncIterableIterator<T> = {\n            [Symbol.asyncIterator]: () => iit,\n            next: (val: any) => i.next(val),\n            return: i.return && ((val) => i.return!(val)),\n            throw: i.throw && ((val) => i.throw!(val))\n        }\n        return iit;\n    }\n    throw new Error(`Not iterator nor iterable: ${i}`);\n}\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `Iterator` protocol (has a `next()` method).\n *\n * Note: There is no way to statically distinguish between an `Iterator` and an `AsyncIterator`. You will get\n * runtime errors if you don't anticipate the distinction.\n * @param i\n */\nexport const isIterator = <K, KReturn = K, KNext = K>(i: Iterable<K> | FullIterable<K, Sync, KReturn, KNext> | any):\n    i is Iterator<K, KReturn, KNext> =>\n        i && typeof i.next === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `AsyncIterator` protocol (has a `next()` method).\n *\n * Note: There is no way to statically distinguish between an `Iterator` and an `AsyncIterator`. You will get\n * runtime errors if you don't anticipate the distinction.\n * @param i\n */\nexport const isAsyncIterator = <K, KReturn = K, KNext = K>(i: AsyncIterable<K> | AsyncIterator<K, KReturn, KNext>| any):\n    i is AsyncIterator<K, KReturn, KNext> =>\n        i && typeof i.next === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `Iterable` protocol (has a `[Symbol.iterator]`\n * method).\n * @param i\n */\nexport const isIterable = <K, KReturn = K, KNext = K>(i: Iterable<K> | FullIterable<K, Sync, KReturn, KNext> | any): i is FullIterable<K, Sync, KReturn, KNext>  =>\n    i && typeof i[Symbol.iterator] === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `AsyncIterable` protocol (has a `[Symbol.asyncIterator]`\n * method).\n * @param i\n */\nexport const isAsyncIterable = <K, KReturn = K, KNext = K>(i: AsyncIterable<K> | FullIterable<K, Async, KReturn, KNext> | any):\n    i is FullIterable<K, Async, KReturn, KNext> =>\n        i && typeof i[Symbol.asyncIterator] === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `Iterable` protocol (has a `[Symbol.iterator]`\n * method) and the `Iterator` protocol (a next() method).\n * @param i\n */\nexport const isIterableIterator = <K, KReturn = K, KNext = K>(i: Iterable<K>|Iterator<K, KReturn, KNext>|any):\n    i is FullIterableIterator<K, Sync, KReturn, KNext> =>\n        isIterator(i) && isIterable(i);\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `AsyncIterable` protocol (has a `[Symbol.asyncIterator]`\n * method) and the `AsyncIterator` protocol (a next() method).\n * @param i\n */\nexport const isAsyncIterableIterator = <K, KReturn = K, KNext = K>(i: Iterable<K>|Iterator<K, KReturn, KNext>|any):\n    i is FullIterableIterator<K, Async, KReturn, KNext> =>\n        isAsyncIterator(i) && isAsyncIterable(i);\n\n/**\n * Wrap a function in a catch block.\n * @param f\n * @param onError Called when an error is thrown. The return value is returned. If not supplied, undefined is returned.\n */\nexport const doCatch = <A extends any[], R>(f: (...args: A) => R, onError?: (e: Error) => R):\n    ((...args: A) => (R | undefined)) => {\n    return (...args: A) => {\n        try {\n            return f(...args);\n        } catch (e) {\n            return onError?.(e);\n        }\n    };\n};\n","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * This provides the trampoline methods that are shared between synchronous and\n * asynchronous enhanced generators. Methods dispatch to {@link Sync} or {@link Async}\n * as appropriate.\n *\n * This becomes part of the prototype chain of enhanced generator instances. It does\n * __not__ modify any global prototypes.\n *\n * You should not need to reference this directly. In Typescript, if you need a\n * type that covers both sync and async enhanced generators, use {@link Enhanced} (for,\n * generators) or the {@link GeneratorOps} interface (for the functional interface).\n *\n * @packageDocumentation\n * @module enhancements\n * @preferred\n */\n\nimport {Async, Enhanced, FlatGen, Genable, GeneratorOps, IndexedFn, IndexedPredicate, Reducer, ReturnValue, SyncType, UnwrapArray} from \"./types\";\n\n/**\n * Enhancements for generators\n */\n\nexport type {Enhanced} from './types';\n\n/**\n * The trampoline methods that link enhanced generators to [[Sync]] or [[Async]]\n * methods.\n */\nexport abstract class Enhancements<\n        T, TReturn, TNext, S extends SyncType\n        >\n{\n    abstract _impl: GeneratorOps<S>;\n\n    // Set on a call to return().\n    returning?: any;\n\n    abstract next(...arg: [] | [arg: TNext]):\n        S extends Async\n            ? Promise<IteratorResult<T, TReturn>>\n            : IteratorResult<T, TReturn>;\n\n    abstract return(value: TReturn):\n        S extends Async\n            ? Promise<IteratorReturnResult<TReturn>>\n            : IteratorReturnResult<TReturn>;\n\n    abstract throw(e: any):\n        S extends Async\n            ? Promise<IteratorReturnResult<TReturn>>\n            : IteratorReturnResult<TReturn>;;\n\n    abstract [Symbol.iterator]:\n        S extends Async\n            ? undefined\n            : () => this & IterableIterator<T>;\n\n    abstract [Symbol.asyncIterator]:\n        S extends Async\n            ? () => this & AsyncIterableIterator<T>\n            : undefined;\n\n    [Symbol.toStringTag]:\n        S extends Async\n            ? 'EnhancedAsyncGenerator'\n            : 'EnhancedGenerator';\n\n    /**\n     * Return all of the values from this generator as an array. You do not want to call this on an\n     * infinite generator (for obvious reasons); consider using [[EnhancedGenerator.slice]] or\n     * [[EnhancedGenerator.limit]] to limit the size before calling this.\n     */\n    asArray(): ReturnValue<T[], S> {\n        return this._impl.asArray<T, TReturn, TNext>(this);\n    }\n\n    /**\n     * Limit the number of values that can be generated. A `RangeError` is thrown if this limit is\n     * exceeded. See [[EnhancedGenerator.slice]] if you want to truncate.\n     * @param max\n     */\n    limit(max: number): Enhanced<T, S, TReturn, TNext> {\n        return this._impl.limit(max, this);\n    }\n\n    /**\n     * Operate on each value produced by this generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @param thisArg Value to be supplied as context `this` for function _f_.\n     */\n    forEach(f: IndexedFn<T, void, S>, thisArg?: any): void {\n        this._impl.forEach<T, TReturn, TNext>(f, thisArg, this);\n    }\n\n    /**\n     * Apply the function to each value yielded by this generator. It is called with two arguments,\n     * the value yielded, and a sequential index. The return value is a generator that yields the\n     * values produced by the function.\n     * @param f\n     * @param thisArg Optional value to be supplied as context `this` for function _f_.\n     */\n    map<V>(f: IndexedFn<T, V, S>, thisArg?: any): Enhanced<V, S, TReturn, TNext> {\n        return this._impl.map(f, thisArg, this);\n    }\n\n\n    /**\n     * Return a new [[EnhancedGenerator]] that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     */\n    filter(f: IndexedPredicate<T, S>, thisArg?: any): Enhanced<T, S, TReturn, TNext> {\n        return this._impl.filter(f, thisArg, this);\n    }\n\n    /**\n     * Flatten the values yielded by this generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param depth (default = 1)\n     */\n    flat<D extends number>(depth: D = 1 as D): Enhanced<S, FlatGen<T, D>, TReturn, TNext> {\n        return this._impl.flat<D, T, TReturn, TNext>(depth, this);\n    }\n\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a generator that yields the individual values at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param depth\n     */\n    flatMap<D extends number = 1>(f: IndexedFn<T, FlatGen<T, D>, S>, depth: D = 1 as D):\n        Enhanced<S, FlatGen<T, D>, TReturn, TNext>\n    {\n        return this._impl.flatMap<D, T, FlatGen<T, D>, TReturn, TNext>(f, depth, this);\n    }\n\n    /**\n     * Return a new [[EnhancedGenerator]] that only yields the indicated values, skipping _start_ initial values\n     * and continuing until the _end_.\n     * @param start\n     * @param end\n     */\n    slice(start: number = 0, end: number = Number.POSITIVE_INFINITY): Enhanced<T, S, TReturn | undefined, TNext> {\n        return this._impl.slice(start, end, this);\n    }\n\n    /**\n     * Concatenates generators (or iterators or iterables).\n     *\n     * Ensures that any supplied generators are terminated when this is terminated.\n     * @param gens zero or more additional [[Genable]] to provide values.\n     */\n\n    concat<T, TReturn, TNext>(...gens: Array<Genable<T, S, TReturn, TNext>>):\n        Enhanced<T, S, TReturn | void, TNext>\n    {\n        const self = this as UnwrapArray<typeof gens>;\n        return this._impl.concat(self, ...gens);\n    }\n\n\n    /**\n     * Like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\") is omitted\n     * because there is no array.\n     * @param f\n     */\n    reduce<A, T, TReturn, TNext>(f: Reducer<A, T, T, S>): ReturnValue<A, S>;\n    /**\n     * Like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\") is omitted\n     * because there is no array.\n     * @param f\n     * @param init\n     */\n    reduce<A, T, TReturn = T, TNext = T>(f: Reducer<A, T, A, S>, init: A): ReturnValue<A, S>;\n    reduce<A>(f: Reducer<A, T, A, S>, init?: A): ReturnValue<A, S> {\n        return this._impl.reduce<A, T, TReturn, TNext>(f, init as A, this);\n    }\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    some<T>(p: IndexedPredicate<T, S>, thisArg?: any): ReturnValue<boolean, S> {\n        // Why is type typecast to Genable needed here?\n        // Yet the seemingly identical case of 'every' below does not?\n        return this._impl.some(p, thisArg, this as Genable<T, S, TReturn, TNext>);\n    }\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    every(p: IndexedPredicate<T, S>, thisArg?: any): ReturnValue<boolean, S> {\n        return this._impl.every(p, thisArg, this as Genable<T, S, TReturn, TNext>);\n    }\n\n\n    /**\n     * Returns a new generator that repeats the last value returned by this (or `undefined` if this\n     * did not return any values).\n     *\n     * @param max\n     */\n    repeatLast(max: number = Number.POSITIVE_INFINITY): Enhanced<T, S, TReturn | void, TNext> {\n        return this._impl.repeatLast(this, max);\n    }\n\n\n    /**\n     * Returns a new generator that repeats the supplied value after this generator\n     * completes.\n     *\n     * @param value the value to repeat\n     * @param repetitions The number repetitions; the default is infinite.\n     */\n\n    repeat<N>(value: N, repetitions: number = Number.POSITIVE_INFINITY): Enhanced<T | N, S, void, TNext> {\n        const tail = this._impl.repeat<T|N, void, TNext>(value, repetitions);\n        const result = this._impl.concat(\n            this as Genable<T|N, S, undefined, TNext>,\n            tail as Genable<T|N, S, undefined, TNext>\n        );\n        return result as Enhanced<T | N, S, undefined, TNext>;\n    }\n\n    /**\n     * Combines this generator with additional ones, returning a generator that produces a tuple with\n     * each of their results, with this generator's result first.\n     *\n     * Terminates when any generator terminates. To get other behaviors, use with [[EnhancedGenerator.repeat]] or\n     * [[EnhancedGenerator.repeatLast]].\n     * @param gens\n     */\n\n    zip<G extends (Genable<T, S, TReturn, TNext>)[], T, TReturn, TNext>(...gens: G):\n        Enhanced<Array<T>, S, TReturn, TNext>\n    {\n        return this._impl.zip(this as Genable<T, S, TReturn, TNext>, ...gens) as\n            Enhanced<Array<T>, S, TReturn, TNext>;\n    }\n\n    /**\n     * Trivial, but handy, same as **Array.prototype.join**.\n     * @param sep (default = ',').\n     *\n     * See also [[EnhancedGenerator.join]]\n     */\n    join(sep?: string): ReturnValue<string, S> {\n        return this._impl.join(this, sep);\n    }\n\n    /**\n     * Sorts the supplied values and returns a sorted array.\n     * @param cmp a comparison function\n     */\n    sort(cmp?: (a: T, b: T) => number): ReturnValue<T[], S> {\n        return this._impl.sort(cmp)(this as Genable<T, S, TReturn, TNext>);\n    }\n}\n","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * This entry point loads synchronous extended generators\n * @packageDocumentation\n * @module sync\n * @preferred\n */\n\nimport type {Enhanced, FlatGen, Genable, GeneratorOps, GenOp, GenOpValue, GenVoid, IndexedFn, IndexedPredicate, Reducer, ReturnValue, UnwrapArray} from \"./types\";\n// Should be 'import type' but that makes TS insist it can't be a value here even after defining it.\nimport {Sync} from './types';\nimport {doCatch, isGenable, isGenerator, isIterable, isIterator, toGenerator, toIterable, toIterator} from \"./functions\";\nimport {Enhancements} from \"./enhancements\";\n\n/**\n * An extension to generators, that provides for operations like:\n * * map<T, R>(gen: Generator<T>) => (fn: T => R) => Generator<R>\n * * EnhancedGenerator<T>.map<R>(fn: T => R) => Generator<R>\n * @packageDocumentation\n * @module Generators\n * @preferred\n */\n\nclass Sync_ implements GeneratorOps<Sync> {\n    /**\n     * Return a generator that yields the supplied values.\n     * @param values\n     */\n    of<T extends any[], TReturn, TNext>(...values: T):\n        Enhanced<UnwrapArray<T>, Sync, TReturn, TNext>\n    {\n        return this.enhance(values);\n    }\n    /**\n     * Return all of the values from this generator as an array. You do not want to call this on an\n     * infinite generator (for obvious reasons); consider using [[EnhancedGenerator.slice]] or\n     * [[EnhancedGenerator.limit]] to limit the size before calling this.\n     */\n    asArray<T, TReturn, TNext>(gen: Genable<T, Sync, TReturn, TNext>):\n        T[]\n    {\n        return [...toIterable<T, TReturn, TNext>(gen)];\n    };\n\n    limit<T, TReturn, TNext>(max: number, gen: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<T, Sync, TReturn, TNext>;\n    limit(max: number): GenOp<Sync>;\n\n    limit<T, TReturn, TNext>(max: number, gen?: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<T, Sync, TReturn, TNext>\n        | GenOp<Sync>\n    {\n        let self: EnhancedGenerator<T, TReturn, TNext>;\n        function *limit<X, XReturn, XNext>(gen: Iterator<X, XReturn, XNext>): Generator<X, XReturn, XNext> {\n            let nr: XNext;\n            let limited: boolean = false;\n            try {\n                for (let i = 0; i < max; i++) {\n                    const r = gen.next(nr!);\n                    if (r.done) {\n                        return r.value;\n                    }\n                    try {\n                        nr = yield r.value;\n                    } catch (e) {\n                        gen.throw?.(e);\n                    }\n                }\n                limited = true;\n                const err = new RangeError(`Generator produced excessive values > ${max}.`);\n                gen.throw?.(err);\n                throw err;\n            } finally {\n                if (!limited) {\n                    gen.return?.(self?.returning);\n                    // Even if the supplied generator refuses to terminate, we terminate.\n                }\n            }\n        }\n        if (gen) {\n            return self = this.enhance(limit(toIterator(gen)));\n        }\n        return <X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) =>\n            this.enhance(limit(toIterator(gen)));\n    }\n\n    forEach<T, TReturn, TNext>(f: IndexedFn<T, void, Sync>, thisArg: any, gen: Genable<T, Sync, TReturn, TNext>):\n        GenVoid<Sync>;\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @param gen the generator.\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T, TReturn, TNext>(f: IndexedFn<T, void, Sync>, gen: Genable<T, Sync, TReturn, TNext>):\n        GenVoid<Sync>;\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @param thisArg Optional value to be supplied as context `this` for function _f_.\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T>(f: IndexedFn<T, void, Sync>, thisArg?: any):\n        <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>) =>\n            GenVoid<Sync>;\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T>(f: IndexedFn<T, void, Sync>):\n        <TReturn, TNext>(gen: Genable<T, Sync, TReturn, TNext>, thisArg?: any) =>\n            GenVoid<Sync>;\n\n    forEach<T, TReturn, TNext>(\n            f: IndexedFn<T, void, Sync>,\n            thisArgOrGen?: Genable<T, Sync, TReturn, TNext>|any,\n            gen?: Genable<T, Sync, TReturn, TNext>\n        )\n    {\n        const forEach = <XReturn, XNext>(f: IndexedFn<T, void, Sync>, thisArg: any, gen: Genable<T, Sync, XReturn, XNext>):\n                GenVoid<Sync> =>\n            {\n                const it = toIterator(gen);\n                let idx = 0;\n                while (true) {\n                    const r = it.next();\n                    if (r.done) return;\n                    f.call(thisArg, r.value, idx++);\n                }\n            };\n        if (gen) return forEach(f, thisArgOrGen, gen);\n        if (isGenable<T>(thisArgOrGen)) return forEach(f, undefined, thisArgOrGen);\n        return <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, thisArg?: any) =>\n            forEach<XReturn, XNext>(f, thisArg ?? thisArgOrGen, gen);\n    }\n\n    map<T, V>(f: IndexedFn<T, V, Sync>):\n        GenOpValue<Sync, T, V>;\n    map<T, V>(f: IndexedFn<T, V, Sync>, thisArg?: any):\n        GenOpValue<Sync, T, V>;\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Sync>, gen: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<V, Sync, TReturn, TNext>;\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Sync>, thisArg: any, gen: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<V, Sync, TReturn, TNext>;\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Sync>, thisArg?: any | Genable<T, Sync, TReturn, TNext>, iter?: Genable<T, Sync, TReturn, TNext>):\n        EnhancedGenerator<V, TReturn, TNext>\n        | (<XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>) => EnhancedGenerator<V, XReturn, XNext>)\n        | (<XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, thisArg?: any) => EnhancedGenerator<V, XReturn, XNext>)\n    {\n        const map = <XReturn, XNext>(thisArg: any, iter: Genable<T, Sync, XReturn, XNext>) => {\n            const gen = toGenerator(iter);\n            let self: EnhancedGenerator<V, XReturn, XNext>;\n            function* map(): Generator<V, XReturn, XNext> {\n                let nr: XNext;\n                let idx = 0;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = gen.next(nr!);\n                                if (r.done) return r.value;\n                                const v: V = f.call(thisArg, r.value, idx++);\n                                try {\n                                    nr = yield v;\n                                } catch (e) {\n                                    gen.throw(e);\n                                }\n                            }\n                        } finally {\n                            const x = gen.return(self?.returning);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (!x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            return self = this.enhance(map());\n        };\n        if (iter) return map(thisArg, iter);\n        if (isGenable<T, TReturn, TNext>(thisArg)) return map(undefined, thisArg);\n        return <XReturn, XNext>(gen: Genable<T, Sync,XReturn, XNext>, genThisArg?: any) =>\n            map(genThisArg ?? thisArg, gen);\n    }\n\n    /**\n     * Return a function that filters a [[Genable]] and yields a new [[EnhancedGenerator]]\n     * that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @typeParam T the type of value.\n     */\n    filter<T>(f: IndexedPredicate<T, Sync>):\n        GenOpValue<Sync, T, T>;\n\n    /**\n     * Return a function that filters a [[Genable]] and yields a new [[EnhancedGenerator]]\n     * that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     * @typeParam T the type of value.\n     */\n    filter<T>(f: IndexedPredicate<T, Sync>, thisArg: any):\n        GenOpValue<Sync, T, T>;\n\n    /**\n     * Return a new [[EnhancedGenerator]] that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param iter a [[Genable|Genable<T>]]\n     * @typeParam T the type of value.\n     */\n    filter<T, TReturn, TNext>(f: IndexedPredicate<T, Sync>, iter: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<T, Sync, TReturn, TNext>;\n    /**\n     * Return a new [[EnhancedGenerator]] that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     * @param iter a [[Genable|Genable<T>]]\n     * @typeParam T the type of value.\n     */\n    filter<T, TReturn, TNext>(f: IndexedPredicate<T, Sync>, thisArg: any, iter: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<T, Sync, TReturn, TNext>;\n\n    /**\n     * Return a function that filters a [[Genable]] and yields a new [[EnhancedGenerator]]\n     * that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     * @param iter the [[Genable]] to filter.\n     * @typeParam T the type of value.\n     */\n    filter<T, TReturn, TNext>(\n        f: IndexedPredicate<T, Sync>,\n        thisArg?: any | Genable<T, Sync, TReturn, TNext>,\n        iter?: Genable<T, Sync, TReturn, TNext>\n    ):\n        Enhanced<T, Sync, TReturn, TNext>\n        | GenOpValue<Sync, T, T>\n    {\n        const filter = <XReturn, XNext>(thisArg: any, iter: Genable<T, Sync, XReturn, XNext>) => {\n            const gen = toGenerator(iter);\n            let self: EnhancedGenerator<T, TReturn, TNext>;\n            function* filter<V>(f: IndexedPredicate<T, Sync>): Generator<T> {\n                let nr: any = undefined;\n                let idx = 0;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = gen.next(nr);\n                                if (r.done) return r.value;\n                                if (f.call(thisArg, r.value, idx++)) {\n                                    try {\n                                        nr = yield r.value;\n                                    } catch (e) {\n                                        gen.throw(e);\n                                    }\n                                }\n                            }\n                        } finally {\n                            const x = gen.return?.(self?.returning);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (!x?.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            return self = this.enhance(filter(f));\n        };\n\n        if (iter) return filter(thisArg, iter);\n        if (isGenable<T>(thisArg)) return filter(undefined, thisArg);\n        return <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, genThisArg?: any) =>\n            filter(genThisArg ?? thisArg, gen);\n    }\n\n    /**\n     * Flatten the values yielded by the generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param depth\n     */\n    flat<D extends number>(depth: D):\n        <X, XReturn = X, XNext = X>(gen: Genable<X, Sync, XReturn, XNext>) =>\n            Enhanced<Sync, FlatGen<X, D>, XReturn, XNext>;\n    /**\n     * Flatten the values yielded by the generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param depth\n     * @param gen\n     */\n    flat<D extends number, T, TReturn, TNext>(depth: D, gen: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<Sync, FlatGen<T, D>, TReturn, TNext>;\n    /**\n     * Flatten the values yielded by the generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param gen\n     * @param depth default = 1\n     */\n    flat<D extends number, T, TReturn, TNext>(gen: Genable<T, Sync, TReturn, TNext>, depth?: D):\n        Enhanced<Sync, FlatGen<T, D>, TReturn, TNext>;\n\n    flat<D extends number, T, TReturn, TNext>(\n        depth: D|Genable<T, Sync, TReturn, TNext>,\n        gen?: Genable<T, Sync, TReturn, TNext> | D\n    ):\n        Enhanced<Sync, FlatGen<T, D>, TReturn, TNext>\n        | (<X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) => Enhanced<Sync, FlatGen<X, D>, XReturn, XNext>)\n    {\n        const flat = <X, XReturn, XNext>(depth: D, gen: Genable<X, Sync, XReturn, XNext>) => {\n            let self: EnhancedGenerator<FlatGen<X, D>, XReturn, XNext>;\n            const gens = new Set<Generator>();\n            if (isGenerator(gen)) gens.add(gen);\n\n            function* flat<D extends number>(it: Iterator<unknown, XReturn, XNext>, depth: D): Generator<FlatGen<X, D>, XReturn, XNext> {\n                let nr: any = undefined;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = it.next(nr);\n                                if (r.done) return r.value;\n                                const v = r.value;\n                                if (isGenerator(v)) {\n                                    gens.add(v);\n                                }\n                                try {\n                                    if (depth > 0 && isIterator<unknown, XReturn, XNext>(v)) {\n                                        yield* flat(v, depth - 1);\n                                    } else if (depth > 0 && isIterable(v)) {\n                                        yield* flat(toIterator<unknown, XReturn, XNext>(v), depth - 1)\n                                    } else {\n                                        nr = yield r.value as FlatGen<T, D>;\n                                    }\n                                } catch (e) {\n                                    it.throw?.(e);\n                                }\n                            }\n                        } finally {\n                            const x = it.return?.(self?.returning);\n                            if (isGenerator(it)) gens.delete(it);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (x && !x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                            for (const g of gens) {\n                                g.return(self?.returning);\n                            }\n                        }\n                    }\n                }\n            }\n\n            return self = this.enhance(flat(toIterator(gen), depth));\n        }\n        if (typeof depth === 'number') {\n            if (gen) {\n                if (isGenable(gen)) {\n                    return flat(depth, gen);\n                } else {\n                    throw new TypeError(`Invalid Genable: ${gen}`);\n                }\n            }\n            return <X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) =>\n                flat(depth, gen);\n        } else if (isGenable(depth)) {\n            return flat((gen ?? 1) as D, depth);\n        }\n        throw new TypeError(`Illegal arguments to flat()`);\n    }\n\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a function that accepts a generator, and returns another generator that yields the individual value\n     * at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param depth\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T>(f: IndexedFn<T, R, Sync>, depth: D):\n        <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>) =>\n            Enhanced<R, Sync, XReturn, XNext>;\n\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a function that accepts a generator, and returns another generator that yields the individual value\n     * at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T>(f: IndexedFn<T, R, Sync>):\n        <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, depth?: D) =>\n            Enhanced<R, Sync, XReturn, XNext>;\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a generator that yields the individual values at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param gen\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T, TReturn, TNext>(f: IndexedFn<T, R, Sync>, gen: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<R, Sync, TReturn, TNext>;\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a generator that yields the individual values at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param depth\n     * @param gen\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T, TReturn, TNext>(f: IndexedFn<T, R, Sync>, depth: D, gen: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<R, Sync, TReturn, TNext>;\n\n    flatMap<D extends number, R extends FlatGen<T, D>, T, TReturn, TNext>(\n            f: IndexedFn<T, R, Sync>,\n            depthOrGen?: D | Genable<T, Sync, TReturn, TNext>,\n            gen?: Genable<T, Sync, TReturn, TNext>\n        ):\n            Enhanced<R, Sync, TReturn, TNext>\n            | (\n                <X, Y extends FlatGen<T, D>, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) =>\n                Enhanced<Y, Sync, XReturn, XNext>\n            )\n            | (\n                <X, Y extends FlatGen<T, D>, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>, depth?: D) =>\n                    Enhanced<Y, Sync, XReturn, XNext>\n            )\n    {\n        const flatMap = <X, XReturn, XNext>(depth: D, gen: Genable<X, Sync, XReturn, XNext>) => {\n            let self: Enhanced<FlatGen<X, D>, Sync, XReturn, XNext>;\n            let idx = 0;\n\n            function* flatMap<D extends number, Y, YReturn, YNext>(it: Iterator<Y, YReturn, YNext>, depth: D):\n                Generator<FlatGen<X, D>, XReturn, XNext>\n            {\n                let nr: YNext;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = it.next(nr!);\n                                if (r.done) return r.value as unknown as XReturn;\n                                const v = f(r.value as unknown as T, idx++);\n                                try {\n                                    if (isIterator<unknown, XReturn, XNext>(v)) {\n                                        if (depth > 1) {\n                                            yield* flatMap(v, depth - 1);\n                                        } else if (depth === 1) {\n                                            yield* toGenerator(v);\n                                        } else {\n                                            yield v;\n                                        }\n                                    } else if (isIterable(v)) {\n                                        if (depth > 1) {\n                                            yield* flatMap(toIterator<unknown, XReturn, XNext>(v), depth - 1);\n                                        } else if (depth === 1) {\n                                            yield* toGenerator(v);\n                                        } else {\n                                            yield v;\n                                        }\n                                    } else {\n                                        nr = (yield v) as unknown as YNext;\n                                    }\n                                } catch (e) {\n                                    it.throw?.(e);\n                                }\n                            }\n                        } finally {\n                            const x = it.return?.(self?.returning);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (x && !x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            return self = this.enhance(flatMap(toIterator(gen), depth));\n        }\n\n        if (isGenable(gen)) {\n            return flatMap(depthOrGen as D ?? 1 as D, gen);\n        } else if (isGenable( depthOrGen)) {\n            return flatMap(1 as D, depthOrGen);\n        }\n        return <X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>, depth?: D) =>\n            flatMap(depthOrGen ?? depth ?? 1 as D, gen);\n    }\n\n    /**\n     * Return a new [[EnhancedGenerator]] that only yields the indicated values, skipping _start_ initial values\n     * and continuing until the _end_.\n     * @param start\n     * @param end\n     */\n    slice<T>(start: number, end: number):\n        <X, XReturn, XNext>(iter: Genable<X, Sync, XReturn, XNext>) =>\n            Enhanced<X, Sync, XReturn | undefined, XNext>;\n\n    /**\n     * Return a new [[EnhancedGenerator]] that only yields the indicated values, skipping _start_ initial values\n     * and continuing until the _end_.\n     * @param start\n     * @param end\n     * @param iter\n     */\n    slice<T, TReturn, TNext>(start: number, end: number, iter: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<T, Sync, TReturn | undefined, TNext>;\n\n    slice<T, TReturn, TNext>(start: number, end: number, iter?: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<T, Sync, TReturn | undefined, TNext>\n        | (\n            <X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) =>\n                Enhanced<X, Sync, XReturn | undefined, XNext>\n        )\n    {\n        const slice = <X, XReturn, XNext>(iter: Genable<X, Sync, XReturn, XNext>):\n                Enhanced<X, Sync, XReturn | undefined, XNext> =>\n            {\n                const it = toIterator(iter);\n                function* slice(start: number, end: number) {\n                    for (let i = 0; i < start; i++) {\n                        const r = it.next();\n                        if (r.done) return r.value;\n                    }\n                    if (end === Number.POSITIVE_INFINITY) {\n                        yield* toIterable(it);\n                    } else {\n                        let nv: XNext;\n                        while (true) {\n                            try {\n                                for (let i = start; i < end; i++) {\n                                    const r = it.next(nv!);\n                                    if (r.done) return r.value;\n                                    try {\n                                        nv = yield r.value;\n                                    } catch (e) {\n                                        const re = it.throw?.(e);\n                                        if (re) {\n                                            if (re.done) return re.value;\n                                            nv = yield re.value;\n                                        }\n                                    }\n                                }\n                            } finally {\n                                const x = it.return?.();\n                                // If the wrapped generator aborted the return, we will, too.\n                                if (x && !x.done) {\n                                    // noinspection ContinueOrBreakFromFinallyBlockJS\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    return;\n                }\n                return this.enhance(slice(start, end));\n        };\n        if (!iter) return slice;\n        return slice(iter);\n    }\n\n    /**\n     * Concatenates generators (or iterators or iterables).\n     *\n     * Ensures that any supplied generators are terminated when this is terminated.\n     * @param gens zero or more additional [[Genable]] to provide values.\n     */\n    concat<\n        T, TReturn, TNext,\n        A extends Array<Genable<T, Sync, TReturn, TNext>>\n    >(...gens: A):\n        Enhanced<T, Sync, TReturn | void, TNext>\n    {\n        let self: Enhanced<T, Sync, TReturn | void, TNext>;\n        function* concat(): Generator<T, TReturn | void, TNext> {\n            let i = 0;\n            try {\n                for (; i < gens.length; i++) {\n                    yield* toIterable<T,TReturn, TNext>(gens[i]);\n                }\n            } finally {\n                // Terminate any remaining generators.\n                for (; i < gens.length; i++) {\n                    const g = gens[i];\n                    if (isGenerator(g)) {\n                        g.return(self?.returning);\n                    }\n                }\n            }\n        }\n        return self = this.enhance(concat()) ;\n    }\n\n    /**\n     * Reduces **gen** like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     * @param f\n     * @param gen\n     */\n    reduce<A, T, TReturn, TNext>(f: Reducer<A, T, T, Sync>, gen: Genable<T, Sync, TReturn, TNext>):\n        A;\n    /**\n     *\n     * Returns a reducer function that, when applied to a `Generator` **gen**, reduces **gen** like\n     * **Array.prototype.reduce**. The 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     *\n     * @param f\n     */\n    reduce<A, T, TReturn, TNext>(f: Reducer<A, T, T, Sync>):\n        (gen: Genable<T, Sync, TReturn, TNext>) =>\n            A;\n    /**\n     *\n     * Returns a reducer function that, when applied to a `Generator` **gen**, reduces **gen** like\n     * `Array.prototype.reduce`. The 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     *\n     * @param f\n     */\n    reduce<A, T>(f: Reducer<A, T, A, Sync>):\n        <TReturn, TNext>(init: A, gen: Genable<T, Sync, TReturn, TNext>) =>\n            A;\n\n    /**\n     * Reduces **gen** like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     * @param f\n     * @param init\n     * @param gen\n     */\n    reduce<A, T, TReturn, TNext>(f: Reducer<A, T, A, Sync>, init: A, gen: Genable<T, Sync, TReturn, TNext>):\n        A;\n\n    /**\n     * Returns a reducer function that, when applied to a `Generator` **gen**, reduces **gen** like\n     * `Array.prototype.reduce`. The 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     *\n     * Alternatively, the init value can be supplied along with the generator as a second argument.\n     * @param f\n     * @param init\n     */\n    reduce<A, T>(f: Reducer<A, T, A, Sync>, init: A):\n        <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>) =>\n            A;\n\n    reduce<A, T, TReturn, TNext>(\n        f: Reducer<A, T, A | T, Sync>,\n        initOrGen?: A | Genable<T, Sync, TReturn, TNext>,\n        gen?: Genable<T, Sync, TReturn, TNext>\n    ): A\n        | (<XHome, XNext>(gen: Genable<T, Sync, XHome, XNext>) => A)\n        | ((f: (acc: A, v: T) => A, init: A) => A)\n        | ((f: (acc: A | T, v: T) => A) => A)\n    {\n\n        const reduce = (init: A | undefined, it: Iterator<T,unknown,unknown>): A => {\n            let acc: A | T | undefined = init;\n            if (acc === undefined) {\n                const r = it.next();\n                if (r.done) throw new TypeError(`No initial value in reduce`);\n                acc = r.value;\n            }\n            while (true) {\n                const r = it.next();\n                if (r.done) return acc as A;\n                acc = f(acc, r.value);\n            }\n        };\n        if (isGenable(gen)) {\n            return reduce(initOrGen as A, toIterator(gen));\n        } else if (isGenable(initOrGen)) {\n            return reduce(undefined, toIterator(initOrGen));\n        }\n        return <XHome, XNext>(gen: Genable<T, Sync, XHome, XNext>, init?: A) =>\n            reduce(init ?? initOrGen, toIterator(gen));\n    }\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    some<T>(p: IndexedPredicate<T, Sync>, thisArg?: any):\n        <XHome, XNext>(gen: Genable<T, Sync, XHome, XNext>) =>\n            ReturnValue<boolean, Sync>;\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     */\n    some<T>(p: IndexedPredicate<T, Sync>):\n        <XHome, XNext>(gen: Genable<T, Sync, XHome, XNext>, thisArg?: any) =>\n            ReturnValue<boolean, Sync>;\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param gen the generator\n     */\n    some<T, TReturn, TNext>(p: IndexedPredicate<T, Sync>, gen: Genable<T, Sync, TReturn, TNext>):\n        ReturnValue<boolean, Sync>;\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     * @param gen the generator\n     */\n    some<T, TReturn, TNext>(p: IndexedPredicate<T, Sync>, thisArg: any, gen: Genable<T, Sync, TReturn, TNext>):\n        ReturnValue<boolean, Sync>;\n\n    some<T, TReturn, TNext>(\n        pred: IndexedPredicate<T, Sync>,\n        thisOrGen?: any | Genable<T, Sync, TReturn, TNext>,\n        gen?: Genable<T, Sync, TReturn, TNext>\n    ):\n        ReturnValue<boolean, Sync>\n        | (<XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, thisArg?: any) =>\n            ReturnValue<boolean, Sync>)\n    {\n        const some = <XReturn, XNext>(thisArg: any, it: Iterator<T, XReturn, XNext>): boolean => {\n            let i = 0;\n            while (true) {\n                const r = it.next();\n                if (r.done) return false;\n                if (pred.call(thisArg, r.value, i++)) return true;\n            }\n        };\n        if (isGenable(gen)) {\n            return some(thisOrGen, toIterator(gen));\n        } else if (isGenable<T, TReturn, TNext>(thisOrGen)) {\n            return some(undefined, toIterator(thisOrGen));\n        } else {\n            return <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, thisArg?: any) =>\n                some<XReturn, XNext>(thisArg ?? thisOrGen, toIterator(gen));\n        }\n    }\n\n    /**\n     * Returns `false` and terminates the generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    every<T>(p: IndexedPredicate<T, Sync>, thisArg?: any):\n        <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>) =>\n            ReturnValue<boolean, Sync>;\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     */\n    every<T>(p: IndexedPredicate<T, Sync>):\n        <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext >, thisArg?: any) =>\n            ReturnValue<boolean, Sync>;\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param gen the generator\n     */\n    every<T, TReturn, TNext>(p: IndexedPredicate<T, Sync>, gen: Genable<T, Sync, TReturn, TNext>):\n        ReturnValue<boolean, Sync>;\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     * @param gen the generator\n     */\n    every<T, TReturn, TNext>(p: IndexedPredicate<T, Sync>, thisArg: any, gen: Genable<T, Sync, TReturn, TNext>):\n        ReturnValue<boolean, Sync>;\n\n    every<T, TReturn, TNext>(\n        pred: IndexedPredicate<T, Sync>,\n        genOrThis?: any | Genable<T, Sync, TReturn, TNext>,\n        gen?: Genable<T, Sync, TReturn, TNext>\n    ):\n        ReturnValue<boolean, Sync>\n        | (\n            <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>) =>\n                ReturnValue<boolean, Sync>\n        )\n    {\n        const every = <XReturn, XNext>(thisArg: any, it: Iterator<T, XReturn, XNext>): boolean => {\n            let i = 0;\n            while (true) {\n                const r = it.next();\n                if (r.done) return true;\n                if (!pred.call(thisArg, r.value, i++)) return false;\n            }\n        };\n        if (isGenable(gen)) {\n            return every(genOrThis, toIterator(gen));\n        } else if (isGenable(gen)) {\n            return <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, thisArg?: any) =>\n                every(thisArg ?? genOrThis, toIterator(gen));\n        }\n        throw new Error(`Invalid argument to every: ${gen ?? genOrThis}`);\n    }\n\n    /**\n     * Returns a new generator that repeats the last value returned by **gen** (or `undefined` if **gen**\n     * did not return any values).\n     *\n     * @param gen\n     * @param max\n     */\n    repeatLast<T, TReturn, TNext>(\n        gen: Genable<T, Sync, TReturn, TNext>,\n        max: number = Number.POSITIVE_INFINITY\n    ):\n        Enhanced<T, Sync, TReturn | void, TNext>\n    {\n        const it = toIterator(gen);\n        let nr: any;\n        let self: EnhancedGenerator<T, TReturn | void, TNext>;\n\n        function* repeatLast(): Generator<T, TReturn | void, TNext> {\n            try {\n                let last: T;\n                while (true) {\n                    const r = it.next(nr)\n                    if (r.done) break;\n                    try {\n                        nr = yield (last = r.value);\n                    } catch (e) {\n                        const re = it.throw?.(e);\n                        if (re) {\n                            if (re.done) break;\n                            yield last = re.value;\n                        }\n                    }\n                }\n                for (let i = 0; i < max; i++) {\n                    yield last!;\n                }\n            } finally {\n                it.return?.(self?.returning);\n            }\n        }\n\n        return self = this.enhance(repeatLast());\n    }\n\n    /**\n     * Returns a new generator that repeats the supplied value.\n     *\n     * @param value the value to repeat\n     * @param repetitions The number repetitions; the default is infinite.\n     */\n    repeat<T, TReturn, TNext>(value: T, repetitions: number = Number.POSITIVE_INFINITY):\n        Enhanced<T, Sync, TReturn | void, TNext>\n    {\n        function* repeat(): Generator<T, TReturn | void, TNext> {\n            for (let i = 0; i < repetitions; i++) {\n                yield value;\n            }\n        }\n\n        return this.enhance(repeat());\n    }\n\n    /**\n     * Combines generators, returning a generator that produces a tuple with each of their results.\n     *\n     * Terminates when the first generator terminates. To get other behaviors, use with [[EnhancedGenerator.repeat]] or\n     * [[EnhancedGenerator.repeatLast]].\n     * @param gens\n     */\n\n    zip<T, TReturn, TNext>(...gens: Array<Genable<T, Sync, TReturn, TNext>>):\n        Enhanced<Array<T>, Sync, TReturn, TNext>\n    {\n        if (gens.length === 0) return this.enhance([]);\n        const its = gens.map(toIterator);\n        let done = false;\n        let self: Enhanced<Array<T>, Sync, TReturn, TNext>;\n\n        function* zip2(): Generator<Array<T>, TReturn, TNext> {\n            try {\n                while (true) {\n                    let result: Array<T> = [];\n                    for (const g of its) {\n                        const r = g.next();\n                        if (r.done) {\n                            done = true;\n                            return r.value as TReturn;\n                        }\n                        (result as any[]).push(r.value);\n                    }\n                    try {\n                        yield result;\n                    } catch (e) {\n                        for (const g of gens) {\n                            try {\n                                // Weird need for a typecast here.\n                                (g as any).throw?.(e);\n                            } catch {\n                                // Ignore\n                            }\n                        }\n                        throw e;\n                    }\n                }\n            } finally {\n                if (!done) {\n                    for (const g of gens) {\n                        try {\n                            // Weird need for a typecast here.\n                            (g as any).return?.(self?.returning);\n                        } catch {\n                            // Ignore\n                        }\n                    }\n                }\n            }\n        }\n\n        return self = this.enhance(zip2());\n    }\n\n    /**\n     * Returns a function that joins the elements produced by a [[Genable]], analogous to `Array.prototype.join`.\n     * @param sep (default = ',')\n     */\n    join(sep: string):\n        <X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) =>\n            ReturnValue<string, Sync>;\n\n    /**\n     * Joins the elements produced by a [[Genable]], analogous to `Array.prototype.join`.\n     * @param gen\n     * @param sep\n     */\n    join<T, TReturn, TNext>(gen: Genable<T, Sync, TReturn, TNext>, sep?: string):\n        ReturnValue<string, Sync>;\n\n    join<T, TReturn, TNext>(\n        genOrSeparator: Genable<T, Sync, TReturn, TNext>|string,\n        sep?: string\n    ):\n        string\n        | (<X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) => string)\n    {\n        if (typeof genOrSeparator === 'string') {\n            sep = genOrSeparator;\n            return <X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) =>\n                this.join(gen, sep);\n        }\n        return [...toIterable(genOrSeparator)].join(sep);\n    }\n\n    /**\n     * Returns a new generator that returns values from each of the supplied sources as they are available.\n     * These will be taken in round-robin fashion from each non-terminated generator, until all have\n     * terminated. The yielded values will not be distinguished by which which source they are taken; for\n     * that, another method will be supplied.\n     *\n     * Any calls to `Generator.throw()` or `Generator.return()` will be passed to all non-terminated\n     * sources.\n     * @param sources\n     */\n\n    merge<T, TReturn, TNext>(...sources: Array<Genable<T, Sync, TReturn, TNext>>):\n        Enhanced<T, Sync, TReturn, TNext>\n    {\n        let self: Enhanced<T, Sync, TReturn, TNext>;\n        let gens: Array<Iterator<T, TReturn, TNext> | null> = sources.map(toIterator);\n        function* merge<X, XReturn, XNext>(gens: Array<Iterator<X, XReturn, XNext> | null>):\n            Generator<X, XReturn, XNext>\n        {\n            let done = false;\n            let running = true;\n            let nv: XNext;\n            try {\n                while (running) {\n                    running = false;\n                    for (let i = 0; i < gens.length; i++) {\n                        const g = gens[i];\n                        if (g) {\n                            const r = g.next(nv!);\n                            if (r.done) {\n                                gens[i] = null;\n                            } else {\n                                running = true;\n                                try {\n                                    nv = yield r.value;\n                                } catch (e) {\n                                    gens.forEach(doCatch(g => g?.throw?.(e)));\n                                }\n                            }\n                        }\n                    }\n                }\n                done = true;\n            } finally {\n                if (!done) {\n                    gens.forEach(doCatch(g => g?.return?.(self?.returning)));\n                }\n            }\n            return self?.returning;\n        }\n        return self = this.enhance(merge(gens));\n    }\n\n    /**\n     * Returns a function that sorts the supplied sources and returns a sorted array.\n     * @param cmp a comparison function\n     */\n    sort<T>(cmp?: ((a: T, b: T) => number)) {\n        return <TReturn, TNext>(...sources: Array<Genable<T, Sync, TReturn, TNext>>) => {\n            const result: T[] = this.merge(...sources).asArray();\n            return result.sort(cmp);\n        }\n    }\n\n    /**\n     * Enhance an existing generator (or iterator or iterable) to be a EnhancedGenerator.\n     * @param gen\n     */\n    enhance<T, TReturn, TNext>(gen: Genable<T, Sync, TReturn, TNext>):\n        EnhancedGenerator<T, TReturn, TNext>\n    {\n        const gen2 = toGenerator(gen) as Partial<EnhancedGenerator<T, TReturn, TNext>>;\n        const old = Object.getPrototypeOf(gen2);\n        const proto = Object.create(EnhancedGenerator.prototype);\n        proto.return = (v: TReturn) => (gen2.returning = v, old.return.call(gen2, v));\n        proto[Symbol.iterator] = () => gen2;\n        Object.setPrototypeOf(gen2, EnhancedGenerator.prototype);\n        return gen2 as EnhancedGenerator<T, TReturn, TNext>;\n    }\n}\n\n/**\n * Utilities to create and use generators which can be manipulated in various ways.\n *\n * Most methods come both as instance (prototype) methods and as static methods. They\n * provide equivalent functionality, but the static methods allow use on `Iterator` and\n * `Iterable` objects without first converting to a generator.\n *\n * The [[EnhancedGenerator.enhance]] method will add additional instance methods to\n * an ordinary generator's prototype (a new prototype, **not** modifying any global prototype!).\n * It can also be used to convert `Iterator` and `Iterable` objects to [[EnhancedGenerator]].\n *\n * For methods which return a EnhancedGenerator, care is take to propagate any `Generator.throw`\n * and `Generator.return` calls to any supplied generators, so they can properly terminate.\n *\n * The exception is [[EnhancedGenerator.flat]] (and by extension, [[EnhancedGenerator.flatMap]]), which cannot know what nested generators\n * they might encounter in the future. Any generators encountered so far will be terminated, however.\n *\n * @typeParam T the type of values returned in the iteration result.\n * @typeParam TReturn the type of values returned in the iteration result when the generator terminates\n * @typeParam TNext the type of value which can be passed to `.next(val)`.\n */\nexport abstract class EnhancedGenerator<T, TReturn, TNext>\n    extends Enhancements<T, TReturn, TNext, Sync>\n    implements Generator<T, TReturn, TNext>, Iterable<T>,\n        Iterator<T, TReturn, TNext>\n{\n    [Symbol.toStringTag]: 'EnhancedGenerator';\n}\n\n/**\n * Factory for synchronous generator operators. See [[GeneratorOps]] for details.\n */\nconst Sync: GeneratorOps<Sync> = new Sync_();\nexport {Sync};\n\nconst makeProto = (base: any) => {\n    const newProto = Object.create(base);\n    const inherit = (proto: any) => {\n        for (const k of Reflect.ownKeys(proto)) {\n            if (k !== 'constructor') {\n                newProto[k] = proto[k];\n            }\n        }\n    };\n    inherit(Enhancements.prototype);\n    return newProto;\n}\n\n/**\n * @internal\n * @constructor\n */\nfunction* Foo() {\n}\n\n/**\n * @internal\n */\nexport const GenProto = Object.getPrototypeOf(Foo());\n\n// Make EnhancedGenerator inherit generator methods.\nObject.setPrototypeOf(EnhancedGenerator.prototype, makeProto(GenProto));\nObject.defineProperty(EnhancedGenerator.prototype, '_impl', {\n    value: Sync,\n    writable: false,\n    enumerable: false,\n    configurable: false\n});\n"],"names":["isFunction","f","isGenable","g","isIterator","isIterable","isGenerator","next","return","throw","Symbol","iterator","toGenerator","i","it","r","done","value","wrap","Error","toIterator","toIterable","doCatch","onError","args","e","Enhancements","returning","toStringTag","asArray","this","_impl","limit","max","forEach","thisArg","map","filter","flat","depth","flatMap","slice","start","end","Number","POSITIVE_INFINITY","concat","gens","reduce","init","some","p","every","repeatLast","repeat","repetitions","tail","zip","join","sep","sort","cmp","EnhancedGenerator","Sync","of","values","enhance","gen","self","nr","limited","err","RangeError","thisArgOrGen","idx","call","undefined","iter","v","genThisArg","x","Set","add","delete","TypeError","depthOrGen","nv","re","length","initOrGen","acc","pred","thisOrGen","genOrThis","last","its","result","push","zip2","genOrSeparator","merge","sources","running","gen2","old","Object","getPrototypeOf","proto","create","prototype","setPrototypeOf","GenProto","Foo","base","newProto","k","Reflect","ownKeys","inherit","makeProto","defineProperty","writable","enumerable","configurable"],"mappings":"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"}