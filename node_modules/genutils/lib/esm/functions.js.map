{"version":3,"file":"functions.js","sources":["../../src/functions.ts"],"sourcesContent":["/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * Functions to test (as typeguards) and coerce generators, iterators, etc.\n *\n * @packageDocumentation\n * @module functions\n * @preferred\n */\n\n\nimport type {Async, Sync, Genable, FullIterable, FullIterableIterator} from \"./types\";\n\n/**\n * Predicate/Type Guard for any function.\n * @param f\n */\nexport const isFunction = <A extends Function>(f: (A | any)): f is A => {\n    return typeof f === 'function';\n}\n\n/**\n * Predicate/type guard to determine if an object is [[Genable]]. An object is [[Genable]] if it\n * supports the `Iterator` or `Iterable` protocols. (Generators support both).\n * @param g\n */\nexport const isGenable = <T, TReturn = T, TNext = T>(g: Iterator<T, TReturn, TNext>|Iterable<T>|Generator<T, TReturn, TNext>|any):\n    g is Genable<T, Sync, TReturn, TNext> =>\n        g && (isIterator(g) || isIterable(g));\n\n\nexport const isAsyncGenable = <T, TReturn, TNext>(g: AsyncIterator<T, TReturn, TNext>|AsyncIterable<T>|AsyncGenerator<T,TReturn,TNext>|any):\n    g is Genable<T, Async, TReturn, TNext> =>\n        g && (isAsyncIterator<T, TReturn, TNext>(g) || isAsyncIterable<T, TReturn, TNext>(g) || isIterable<T, TReturn, TNext>(g));\n\n/**\n * Predicate/type guard to determine if an object is (or looks like, structurally) a Generator.\n * @param g\n */\nexport const isGenerator = <T, TReturn, TNext>(g: Genable<T, Sync, TReturn, TNext>|any): g is Generator<T, TReturn, TNext> =>\n    g &&\n    isFunction(g.next)\n    && isFunction(g.return)\n    && isFunction(g.throw)\n    && isFunction(g[Symbol.iterator]);\n\n/**\n * Predicate/type guard to determine if an object is (or looks like, structurally) a AsyncGenerator.\n * @param g\n */\nexport const isAsyncGenerator = <T, TReturn, TNext>(g: Genable<T, Async, TReturn, TNext>|any): g is AsyncGenerator<T> =>\n    g &&\n    isFunction(g.next)\n    && isFunction(g.return)\n    && isFunction(g.throw)\n    && isFunction(g[Symbol.asyncIterator]);\n\n/**\n * Coerce an object to an object that can act as a generator (that is, satisfy both `Iterator`\n * and `Iterable`).\n *\n * If it is an `Iterator` but not `Iterable`, or `Iterable` but not `Iterator`, it is wrapped\n * in a generator. This generator is __not__ enhanced. Use [[Sync.enhance]] on the result if\n * you need an enhanced generator.\n * @param i\n */\nexport function toGenerator<T, TReturn = T, TNext = T>(i: Genable<T, Sync, TReturn, TNext>): Generator<T, TReturn, TNext> {\n    if (isGenerator(i)) return i;\n    if (isIterator(i)) {\n        const it = i;\n\n        function* wrap() {\n            while (true) {\n                const r = it.next();\n                if (r.done) return r.value;\n                yield r.value;\n            }\n        }\n\n        return wrap();\n    } else if (isIterable(i)) {\n        return toGenerator(i[Symbol.iterator]() as Iterator<T, TReturn, TNext>);\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\n\n/**\n * Coerce an object to an object that can act as a async generator (that is, satisfy both `Iterator`\n * and `Iterable`).\n *\n * If it is an `AsyncIterator` but not `AsyncIterable`, or `AsyncIterable` but not `AsyncIterator`,\n * it is wrapped in an async generator. This generator is __not__ enhanced. Use [[Async.enhance]] on the result if\n * you need an enhanced generator.\n * @param i\n */\nexport function toAsyncGenerator<T, TReturn, TNext>(i: Genable<T, Async, TReturn, TNext>|Genable<T, Sync, TReturn, TNext>):\n    AsyncGenerator<T, TReturn, TNext>\n{\n    if (isAsyncGenerator(i)) return i;\n    if (isAsyncIterator(i)) {\n        const it = i;\n        async function* wrap() {\n            while (true) {\n                const r = await it.next();\n                if (r.done) return r.value;\n                yield r.value;\n            }\n        }\n        return wrap();\n    } else if (isAsyncIterable(i)) {\n        return toAsyncGenerator(i[Symbol.asyncIterator]()) as AsyncGenerator<T, TReturn, TNext>;\n    } else if (isIterable(i)) {\n        return toAsyncGenerator(i[Symbol.iterator]() as Iterator<T, TReturn, TNext>);\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\n/**\n * Coerce a sync [[Genable]] object to an `Iterator`. If the object is a `Generator` or an `Iterator` it is returned,\n * while if it is an `Iterable`, `[Symbol.iterator]`() is invoked.\n * @param i\n */\nexport function toIterator<T, TReturn, TNext>(i: Genable<T, Sync, TReturn, TNext>): Iterator<T, TReturn, TNext> {\n    if (isGenerator(i)) return i;\n    if (isIterator(i)) return i;\n    if (isIterable(i)) {\n        return i[Symbol.iterator]() as Iterator<T, TReturn, TNext>;\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\n\n/**\n * Coerce an async [[Genable]] object to an `AsyncIterator`. If the object is a `Generator` or an `Iterator` it is returned,\n * while if it is an `Iterable`, `[Symbol.iterator]`() is invoked.\n * @param i\n */\nexport function toAsyncIterator<T, TReturn, TNext = T>(i: Genable<T, Async, TReturn, TNext>): AsyncIterator<T, TReturn, TNext> {\n    if (isAsyncGenerator(i)) return i;\n    if (isAsyncIterable(i)) {\n        return i[Symbol.asyncIterator]() as AsyncIterator<T, TReturn, TNext>;\n    } else if (isIterable(i)) {\n        return asyncAdaptor(toIterator(i));\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\nconst asyncAdaptor = <T, TReturn, TNext>(i: Iterator<T, TReturn, TNext>):\n    AsyncGenerator<T, TReturn, TNext> =>\n{\n    const it = i as unknown as AsyncIterator<T>;\n    let self: AsyncGenerator<T> & {returning?: any};\n    async function* asyncAdaptor(): AsyncGenerator<T> {\n        let nr: any;\n        let done = false;\n        try {\n            while (true) {\n                const r = await Promise.resolve(it.next());\n                if (r.done) {\n                    done = true;\n                    return r.value;\n                }\n                try {\n                    nr = yield r.value;\n                } catch (e) {\n                    await it.throw?.(e);\n                    throw(e);\n                }\n            }\n        } finally {\n            if (!done) {\n                await i.return?.(self.returning);\n            }\n        }\n    }\n    return self = asyncAdaptor();\n};\n\n/**\n * Coerce a [[Genable]] object to `Iterable`. If it is already an `Iterable`, it is returned\n * unchanged. If it is an `Iterator`, it is wrapped in an object with a `[Symbol.iterator]`\n * method that returns the supplied iterator.\n * @param i\n */\nexport function toIterable<T, TReturn = T, TNext = T>(i: Genable<T,Sync,TReturn,TNext>):\n    FullIterable<T, Sync, TReturn, TNext>\n{\n    if (isIterable(i)) return i as FullIterable<T, Sync, TReturn, TNext>;\n    return {\n        [Symbol.iterator]: () => i\n    } as FullIterable<T, Sync, TReturn, TNext>;\n}\n\n\n/**\n * Coerce a [[Genable]] object to `AsyncIterable`. If it is already an `AsyncIterable`, it is returned\n * unchanged. If it is an `AsyncIterator`, it is wrapped in an object with a `[Symbol.asyncIterator]`\n * method that returns the supplied iterator.\n * @param i\n */\nexport function toAsyncIterable<T, TReturn, TNext>(i: Genable<T, Async, TReturn, TNext>):\n    FullIterable<T, Async, TReturn, TNext>\n{\n    if (isAsyncIterable<T, TReturn, TNext>(i)) return i;\n    if (isIterable<T, TReturn, TNext>(i)) {\n        return toAsyncIterable_adaptor<T, TReturn, TNext>(i) as\n            FullIterable<T, Async, TReturn, TNext>;\n    }\n    return {\n        [Symbol.asyncIterator]: () => i\n    } as FullIterable<T, Async, TReturn, TNext>;\n}\nasync function* toAsyncIterable_adaptor<T, TReturn, TNext>(iterable: Iterable<T>):\n    AsyncGenerator<T, TReturn, TNext>\n{\n    const it = iterable[Symbol.iterator]();\n    let nr: any = undefined;\n    while (true) {\n        const r = await it.next(nr);\n        if (r.done) return r.value;\n        nr = yield r.value;\n    }\n}\n\n// noinspection JSUnusedGlobalSymbols\n/**\n * Similar to [[toGenerator]], but does not require the presence of `Generator.return` or `Generator.throw` methods.\n * @param i\n */\nexport function toIterableIterator<T, TReturn = T, TNext = T>(i: Genable<T, Sync, TReturn, TNext>): FullIterableIterator<T, Sync, TReturn, TNext> {\n    if (isIterable(i) && isIterator(i)) return i as FullIterableIterator<T, Sync, TReturn, TNext>;\n    if (isIterable(i)) {\n        // Invoke [Symbol.iterator]() just once, on first use.\n        let _it: Iterator<T>|undefined = undefined;\n        const it = () => _it ?? (_it = i[Symbol.iterator]());\n        const iit: FullIterableIterator<T, Sync, TReturn, TNext> = {\n            [Symbol.iterator]: () => iit,\n            next: (val?: TNext) => it().next(val as undefined),\n            return: it().return && ((val) => it().return!(val)),\n            throw: it().throw && ((val) => it().throw!(val))\n        };\n        return iit;\n    }\n    if (isIterator(i)) {\n        const iit: FullIterableIterator<T, Sync, TReturn, TNext> = {\n            [Symbol.iterator]: () => iit,\n            next: (val?: TNext) => i.next(val!),\n            return: i.return && ((val) => i.return!(val)),\n            throw: i.throw && ((val) => i.throw!(val))\n        }\n        return iit;\n    }\n    throw new Error(`Not iterator nor iterable: ${i}`);\n}\n\n\n/**\n * Similar to [[toAsyncGenerator]], but does not require the presence of `AsyncGenerator.return` or\n * `AsyncGenerator.throw` methods.\n * @param i\n */\nexport function toAsyncIterableIterator<T, TReturn, TNext>(i: Genable<T, Async, TReturn, TNext>):\n    FullIterableIterator<T, Async, TReturn, TNext>\n{\n    if (isAsyncIterable<T, TReturn, TNext>(i) && isAsyncIterator<T, TReturn, TNext>(i)) {\n        return i as unknown as FullIterableIterator<T, Async, TReturn, TNext>;\n    }\n    if (isAsyncIterable<T, TReturn, TNext>(i)) {\n        // Invoke [Symbol.iterator]() just once, on first use.\n        let _it: AsyncIterator<T, TReturn, TNext>|undefined = undefined;\n        const it = () => _it ?? (_it = i[Symbol.asyncIterator]() as AsyncIterator<T, TReturn, TNext>);\n        const iit: AsyncIterableIterator<T> = {\n            [Symbol.asyncIterator]: () => iit,\n            next: () => it().next(),\n            return: it().return && ((val) => it().return!(val)),\n            throw: it().throw && ((val) => it().throw!(val))\n        };\n        return iit;\n    }\n    if (isIterable<T, TReturn, TNext>(i)) {\n        return toAsyncIterable_adaptor(i);\n    }\n    if (isAsyncIterator(i)) {\n        const iit: AsyncIterableIterator<T> = {\n            [Symbol.asyncIterator]: () => iit,\n            next: (val: any) => i.next(val),\n            return: i.return && ((val) => i.return!(val)),\n            throw: i.throw && ((val) => i.throw!(val))\n        }\n        return iit;\n    }\n    throw new Error(`Not iterator nor iterable: ${i}`);\n}\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `Iterator` protocol (has a `next()` method).\n *\n * Note: There is no way to statically distinguish between an `Iterator` and an `AsyncIterator`. You will get\n * runtime errors if you don't anticipate the distinction.\n * @param i\n */\nexport const isIterator = <K, KReturn = K, KNext = K>(i: Iterable<K> | FullIterable<K, Sync, KReturn, KNext> | any):\n    i is Iterator<K, KReturn, KNext> =>\n        i && typeof i.next === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `AsyncIterator` protocol (has a `next()` method).\n *\n * Note: There is no way to statically distinguish between an `Iterator` and an `AsyncIterator`. You will get\n * runtime errors if you don't anticipate the distinction.\n * @param i\n */\nexport const isAsyncIterator = <K, KReturn = K, KNext = K>(i: AsyncIterable<K> | AsyncIterator<K, KReturn, KNext>| any):\n    i is AsyncIterator<K, KReturn, KNext> =>\n        i && typeof i.next === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `Iterable` protocol (has a `[Symbol.iterator]`\n * method).\n * @param i\n */\nexport const isIterable = <K, KReturn = K, KNext = K>(i: Iterable<K> | FullIterable<K, Sync, KReturn, KNext> | any): i is FullIterable<K, Sync, KReturn, KNext>  =>\n    i && typeof i[Symbol.iterator] === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `AsyncIterable` protocol (has a `[Symbol.asyncIterator]`\n * method).\n * @param i\n */\nexport const isAsyncIterable = <K, KReturn = K, KNext = K>(i: AsyncIterable<K> | FullIterable<K, Async, KReturn, KNext> | any):\n    i is FullIterable<K, Async, KReturn, KNext> =>\n        i && typeof i[Symbol.asyncIterator] === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `Iterable` protocol (has a `[Symbol.iterator]`\n * method) and the `Iterator` protocol (a next() method).\n * @param i\n */\nexport const isIterableIterator = <K, KReturn = K, KNext = K>(i: Iterable<K>|Iterator<K, KReturn, KNext>|any):\n    i is FullIterableIterator<K, Sync, KReturn, KNext> =>\n        isIterator(i) && isIterable(i);\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `AsyncIterable` protocol (has a `[Symbol.asyncIterator]`\n * method) and the `AsyncIterator` protocol (a next() method).\n * @param i\n */\nexport const isAsyncIterableIterator = <K, KReturn = K, KNext = K>(i: Iterable<K>|Iterator<K, KReturn, KNext>|any):\n    i is FullIterableIterator<K, Async, KReturn, KNext> =>\n        isAsyncIterator(i) && isAsyncIterable(i);\n\n/**\n * Wrap a function in a catch block.\n * @param f\n * @param onError Called when an error is thrown. The return value is returned. If not supplied, undefined is returned.\n */\nexport const doCatch = <A extends any[], R>(f: (...args: A) => R, onError?: (e: Error) => R):\n    ((...args: A) => (R | undefined)) => {\n    return (...args: A) => {\n        try {\n            return f(...args);\n        } catch (e) {\n            return onError?.(e);\n        }\n    };\n};\n"],"names":["isFunction","f","isGenable","g","isIterator","isIterable","isAsyncGenable","isAsyncIterator","isAsyncIterable","isGenerator","next","return","throw","Symbol","iterator","isAsyncGenerator","asyncIterator","toGenerator","i","it","r","done","value","wrap","Error","toAsyncGenerator","async","toIterator","toAsyncIterator","asyncAdaptor","self","nr","Promise","resolve","e","returning","toIterable","toAsyncIterable","toAsyncIterable_adaptor","iterable","toIterableIterator","_it","iit","val","toAsyncIterableIterator","isIterableIterator","isAsyncIterableIterator","doCatch","onError","args"],"mappings":"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"}