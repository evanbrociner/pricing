{"version":3,"file":"async.js","sources":["../../src/functions.ts","../../src/enhancements.ts","../../src/async.ts"],"sourcesContent":["/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * Functions to test (as typeguards) and coerce generators, iterators, etc.\n *\n * @packageDocumentation\n * @module functions\n * @preferred\n */\n\n\nimport type {Async, Sync, Genable, FullIterable, FullIterableIterator} from \"./types\";\n\n/**\n * Predicate/Type Guard for any function.\n * @param f\n */\nexport const isFunction = <A extends Function>(f: (A | any)): f is A => {\n    return typeof f === 'function';\n}\n\n/**\n * Predicate/type guard to determine if an object is [[Genable]]. An object is [[Genable]] if it\n * supports the `Iterator` or `Iterable` protocols. (Generators support both).\n * @param g\n */\nexport const isGenable = <T, TReturn = T, TNext = T>(g: Iterator<T, TReturn, TNext>|Iterable<T>|Generator<T, TReturn, TNext>|any):\n    g is Genable<T, Sync, TReturn, TNext> =>\n        g && (isIterator(g) || isIterable(g));\n\n\nexport const isAsyncGenable = <T, TReturn, TNext>(g: AsyncIterator<T, TReturn, TNext>|AsyncIterable<T>|AsyncGenerator<T,TReturn,TNext>|any):\n    g is Genable<T, Async, TReturn, TNext> =>\n        g && (isAsyncIterator<T, TReturn, TNext>(g) || isAsyncIterable<T, TReturn, TNext>(g) || isIterable<T, TReturn, TNext>(g));\n\n/**\n * Predicate/type guard to determine if an object is (or looks like, structurally) a Generator.\n * @param g\n */\nexport const isGenerator = <T, TReturn, TNext>(g: Genable<T, Sync, TReturn, TNext>|any): g is Generator<T, TReturn, TNext> =>\n    g &&\n    isFunction(g.next)\n    && isFunction(g.return)\n    && isFunction(g.throw)\n    && isFunction(g[Symbol.iterator]);\n\n/**\n * Predicate/type guard to determine if an object is (or looks like, structurally) a AsyncGenerator.\n * @param g\n */\nexport const isAsyncGenerator = <T, TReturn, TNext>(g: Genable<T, Async, TReturn, TNext>|any): g is AsyncGenerator<T> =>\n    g &&\n    isFunction(g.next)\n    && isFunction(g.return)\n    && isFunction(g.throw)\n    && isFunction(g[Symbol.asyncIterator]);\n\n/**\n * Coerce an object to an object that can act as a generator (that is, satisfy both `Iterator`\n * and `Iterable`).\n *\n * If it is an `Iterator` but not `Iterable`, or `Iterable` but not `Iterator`, it is wrapped\n * in a generator. This generator is __not__ enhanced. Use [[Sync.enhance]] on the result if\n * you need an enhanced generator.\n * @param i\n */\nexport function toGenerator<T, TReturn = T, TNext = T>(i: Genable<T, Sync, TReturn, TNext>): Generator<T, TReturn, TNext> {\n    if (isGenerator(i)) return i;\n    if (isIterator(i)) {\n        const it = i;\n\n        function* wrap() {\n            while (true) {\n                const r = it.next();\n                if (r.done) return r.value;\n                yield r.value;\n            }\n        }\n\n        return wrap();\n    } else if (isIterable(i)) {\n        return toGenerator(i[Symbol.iterator]() as Iterator<T, TReturn, TNext>);\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\n\n/**\n * Coerce an object to an object that can act as a async generator (that is, satisfy both `Iterator`\n * and `Iterable`).\n *\n * If it is an `AsyncIterator` but not `AsyncIterable`, or `AsyncIterable` but not `AsyncIterator`,\n * it is wrapped in an async generator. This generator is __not__ enhanced. Use [[Async.enhance]] on the result if\n * you need an enhanced generator.\n * @param i\n */\nexport function toAsyncGenerator<T, TReturn, TNext>(i: Genable<T, Async, TReturn, TNext>|Genable<T, Sync, TReturn, TNext>):\n    AsyncGenerator<T, TReturn, TNext>\n{\n    if (isAsyncGenerator(i)) return i;\n    if (isAsyncIterator(i)) {\n        const it = i;\n        async function* wrap() {\n            while (true) {\n                const r = await it.next();\n                if (r.done) return r.value;\n                yield r.value;\n            }\n        }\n        return wrap();\n    } else if (isAsyncIterable(i)) {\n        return toAsyncGenerator(i[Symbol.asyncIterator]()) as AsyncGenerator<T, TReturn, TNext>;\n    } else if (isIterable(i)) {\n        return toAsyncGenerator(i[Symbol.iterator]() as Iterator<T, TReturn, TNext>);\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\n/**\n * Coerce a sync [[Genable]] object to an `Iterator`. If the object is a `Generator` or an `Iterator` it is returned,\n * while if it is an `Iterable`, `[Symbol.iterator]`() is invoked.\n * @param i\n */\nexport function toIterator<T, TReturn, TNext>(i: Genable<T, Sync, TReturn, TNext>): Iterator<T, TReturn, TNext> {\n    if (isGenerator(i)) return i;\n    if (isIterator(i)) return i;\n    if (isIterable(i)) {\n        return i[Symbol.iterator]() as Iterator<T, TReturn, TNext>;\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\n\n/**\n * Coerce an async [[Genable]] object to an `AsyncIterator`. If the object is a `Generator` or an `Iterator` it is returned,\n * while if it is an `Iterable`, `[Symbol.iterator]`() is invoked.\n * @param i\n */\nexport function toAsyncIterator<T, TReturn, TNext = T>(i: Genable<T, Async, TReturn, TNext>): AsyncIterator<T, TReturn, TNext> {\n    if (isAsyncGenerator(i)) return i;\n    if (isAsyncIterable(i)) {\n        return i[Symbol.asyncIterator]() as AsyncIterator<T, TReturn, TNext>;\n    } else if (isIterable(i)) {\n        return asyncAdaptor(toIterator(i));\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\nconst asyncAdaptor = <T, TReturn, TNext>(i: Iterator<T, TReturn, TNext>):\n    AsyncGenerator<T, TReturn, TNext> =>\n{\n    const it = i as unknown as AsyncIterator<T>;\n    let self: AsyncGenerator<T> & {returning?: any};\n    async function* asyncAdaptor(): AsyncGenerator<T> {\n        let nr: any;\n        let done = false;\n        try {\n            while (true) {\n                const r = await Promise.resolve(it.next());\n                if (r.done) {\n                    done = true;\n                    return r.value;\n                }\n                try {\n                    nr = yield r.value;\n                } catch (e) {\n                    await it.throw?.(e);\n                    throw(e);\n                }\n            }\n        } finally {\n            if (!done) {\n                await i.return?.(self.returning);\n            }\n        }\n    }\n    return self = asyncAdaptor();\n};\n\n/**\n * Coerce a [[Genable]] object to `Iterable`. If it is already an `Iterable`, it is returned\n * unchanged. If it is an `Iterator`, it is wrapped in an object with a `[Symbol.iterator]`\n * method that returns the supplied iterator.\n * @param i\n */\nexport function toIterable<T, TReturn = T, TNext = T>(i: Genable<T,Sync,TReturn,TNext>):\n    FullIterable<T, Sync, TReturn, TNext>\n{\n    if (isIterable(i)) return i as FullIterable<T, Sync, TReturn, TNext>;\n    return {\n        [Symbol.iterator]: () => i\n    } as FullIterable<T, Sync, TReturn, TNext>;\n}\n\n\n/**\n * Coerce a [[Genable]] object to `AsyncIterable`. If it is already an `AsyncIterable`, it is returned\n * unchanged. If it is an `AsyncIterator`, it is wrapped in an object with a `[Symbol.asyncIterator]`\n * method that returns the supplied iterator.\n * @param i\n */\nexport function toAsyncIterable<T, TReturn, TNext>(i: Genable<T, Async, TReturn, TNext>):\n    FullIterable<T, Async, TReturn, TNext>\n{\n    if (isAsyncIterable<T, TReturn, TNext>(i)) return i;\n    if (isIterable<T, TReturn, TNext>(i)) {\n        return toAsyncIterable_adaptor<T, TReturn, TNext>(i) as\n            FullIterable<T, Async, TReturn, TNext>;\n    }\n    return {\n        [Symbol.asyncIterator]: () => i\n    } as FullIterable<T, Async, TReturn, TNext>;\n}\nasync function* toAsyncIterable_adaptor<T, TReturn, TNext>(iterable: Iterable<T>):\n    AsyncGenerator<T, TReturn, TNext>\n{\n    const it = iterable[Symbol.iterator]();\n    let nr: any = undefined;\n    while (true) {\n        const r = await it.next(nr);\n        if (r.done) return r.value;\n        nr = yield r.value;\n    }\n}\n\n// noinspection JSUnusedGlobalSymbols\n/**\n * Similar to [[toGenerator]], but does not require the presence of `Generator.return` or `Generator.throw` methods.\n * @param i\n */\nexport function toIterableIterator<T, TReturn = T, TNext = T>(i: Genable<T, Sync, TReturn, TNext>): FullIterableIterator<T, Sync, TReturn, TNext> {\n    if (isIterable(i) && isIterator(i)) return i as FullIterableIterator<T, Sync, TReturn, TNext>;\n    if (isIterable(i)) {\n        // Invoke [Symbol.iterator]() just once, on first use.\n        let _it: Iterator<T>|undefined = undefined;\n        const it = () => _it ?? (_it = i[Symbol.iterator]());\n        const iit: FullIterableIterator<T, Sync, TReturn, TNext> = {\n            [Symbol.iterator]: () => iit,\n            next: (val?: TNext) => it().next(val as undefined),\n            return: it().return && ((val) => it().return!(val)),\n            throw: it().throw && ((val) => it().throw!(val))\n        };\n        return iit;\n    }\n    if (isIterator(i)) {\n        const iit: FullIterableIterator<T, Sync, TReturn, TNext> = {\n            [Symbol.iterator]: () => iit,\n            next: (val?: TNext) => i.next(val!),\n            return: i.return && ((val) => i.return!(val)),\n            throw: i.throw && ((val) => i.throw!(val))\n        }\n        return iit;\n    }\n    throw new Error(`Not iterator nor iterable: ${i}`);\n}\n\n\n/**\n * Similar to [[toAsyncGenerator]], but does not require the presence of `AsyncGenerator.return` or\n * `AsyncGenerator.throw` methods.\n * @param i\n */\nexport function toAsyncIterableIterator<T, TReturn, TNext>(i: Genable<T, Async, TReturn, TNext>):\n    FullIterableIterator<T, Async, TReturn, TNext>\n{\n    if (isAsyncIterable<T, TReturn, TNext>(i) && isAsyncIterator<T, TReturn, TNext>(i)) {\n        return i as unknown as FullIterableIterator<T, Async, TReturn, TNext>;\n    }\n    if (isAsyncIterable<T, TReturn, TNext>(i)) {\n        // Invoke [Symbol.iterator]() just once, on first use.\n        let _it: AsyncIterator<T, TReturn, TNext>|undefined = undefined;\n        const it = () => _it ?? (_it = i[Symbol.asyncIterator]() as AsyncIterator<T, TReturn, TNext>);\n        const iit: AsyncIterableIterator<T> = {\n            [Symbol.asyncIterator]: () => iit,\n            next: () => it().next(),\n            return: it().return && ((val) => it().return!(val)),\n            throw: it().throw && ((val) => it().throw!(val))\n        };\n        return iit;\n    }\n    if (isIterable<T, TReturn, TNext>(i)) {\n        return toAsyncIterable_adaptor(i);\n    }\n    if (isAsyncIterator(i)) {\n        const iit: AsyncIterableIterator<T> = {\n            [Symbol.asyncIterator]: () => iit,\n            next: (val: any) => i.next(val),\n            return: i.return && ((val) => i.return!(val)),\n            throw: i.throw && ((val) => i.throw!(val))\n        }\n        return iit;\n    }\n    throw new Error(`Not iterator nor iterable: ${i}`);\n}\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `Iterator` protocol (has a `next()` method).\n *\n * Note: There is no way to statically distinguish between an `Iterator` and an `AsyncIterator`. You will get\n * runtime errors if you don't anticipate the distinction.\n * @param i\n */\nexport const isIterator = <K, KReturn = K, KNext = K>(i: Iterable<K> | FullIterable<K, Sync, KReturn, KNext> | any):\n    i is Iterator<K, KReturn, KNext> =>\n        i && typeof i.next === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `AsyncIterator` protocol (has a `next()` method).\n *\n * Note: There is no way to statically distinguish between an `Iterator` and an `AsyncIterator`. You will get\n * runtime errors if you don't anticipate the distinction.\n * @param i\n */\nexport const isAsyncIterator = <K, KReturn = K, KNext = K>(i: AsyncIterable<K> | AsyncIterator<K, KReturn, KNext>| any):\n    i is AsyncIterator<K, KReturn, KNext> =>\n        i && typeof i.next === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `Iterable` protocol (has a `[Symbol.iterator]`\n * method).\n * @param i\n */\nexport const isIterable = <K, KReturn = K, KNext = K>(i: Iterable<K> | FullIterable<K, Sync, KReturn, KNext> | any): i is FullIterable<K, Sync, KReturn, KNext>  =>\n    i && typeof i[Symbol.iterator] === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `AsyncIterable` protocol (has a `[Symbol.asyncIterator]`\n * method).\n * @param i\n */\nexport const isAsyncIterable = <K, KReturn = K, KNext = K>(i: AsyncIterable<K> | FullIterable<K, Async, KReturn, KNext> | any):\n    i is FullIterable<K, Async, KReturn, KNext> =>\n        i && typeof i[Symbol.asyncIterator] === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `Iterable` protocol (has a `[Symbol.iterator]`\n * method) and the `Iterator` protocol (a next() method).\n * @param i\n */\nexport const isIterableIterator = <K, KReturn = K, KNext = K>(i: Iterable<K>|Iterator<K, KReturn, KNext>|any):\n    i is FullIterableIterator<K, Sync, KReturn, KNext> =>\n        isIterator(i) && isIterable(i);\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `AsyncIterable` protocol (has a `[Symbol.asyncIterator]`\n * method) and the `AsyncIterator` protocol (a next() method).\n * @param i\n */\nexport const isAsyncIterableIterator = <K, KReturn = K, KNext = K>(i: Iterable<K>|Iterator<K, KReturn, KNext>|any):\n    i is FullIterableIterator<K, Async, KReturn, KNext> =>\n        isAsyncIterator(i) && isAsyncIterable(i);\n\n/**\n * Wrap a function in a catch block.\n * @param f\n * @param onError Called when an error is thrown. The return value is returned. If not supplied, undefined is returned.\n */\nexport const doCatch = <A extends any[], R>(f: (...args: A) => R, onError?: (e: Error) => R):\n    ((...args: A) => (R | undefined)) => {\n    return (...args: A) => {\n        try {\n            return f(...args);\n        } catch (e) {\n            return onError?.(e);\n        }\n    };\n};\n","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * This provides the trampoline methods that are shared between synchronous and\n * asynchronous enhanced generators. Methods dispatch to {@link Sync} or {@link Async}\n * as appropriate.\n *\n * This becomes part of the prototype chain of enhanced generator instances. It does\n * __not__ modify any global prototypes.\n *\n * You should not need to reference this directly. In Typescript, if you need a\n * type that covers both sync and async enhanced generators, use {@link Enhanced} (for,\n * generators) or the {@link GeneratorOps} interface (for the functional interface).\n *\n * @packageDocumentation\n * @module enhancements\n * @preferred\n */\n\nimport {Async, Enhanced, FlatGen, Genable, GeneratorOps, IndexedFn, IndexedPredicate, Reducer, ReturnValue, SyncType, UnwrapArray} from \"./types\";\n\n/**\n * Enhancements for generators\n */\n\nexport type {Enhanced} from './types';\n\n/**\n * The trampoline methods that link enhanced generators to [[Sync]] or [[Async]]\n * methods.\n */\nexport abstract class Enhancements<\n        T, TReturn, TNext, S extends SyncType\n        >\n{\n    abstract _impl: GeneratorOps<S>;\n\n    // Set on a call to return().\n    returning?: any;\n\n    abstract next(...arg: [] | [arg: TNext]):\n        S extends Async\n            ? Promise<IteratorResult<T, TReturn>>\n            : IteratorResult<T, TReturn>;\n\n    abstract return(value: TReturn):\n        S extends Async\n            ? Promise<IteratorReturnResult<TReturn>>\n            : IteratorReturnResult<TReturn>;\n\n    abstract throw(e: any):\n        S extends Async\n            ? Promise<IteratorReturnResult<TReturn>>\n            : IteratorReturnResult<TReturn>;;\n\n    abstract [Symbol.iterator]:\n        S extends Async\n            ? undefined\n            : () => this & IterableIterator<T>;\n\n    abstract [Symbol.asyncIterator]:\n        S extends Async\n            ? () => this & AsyncIterableIterator<T>\n            : undefined;\n\n    [Symbol.toStringTag]:\n        S extends Async\n            ? 'EnhancedAsyncGenerator'\n            : 'EnhancedGenerator';\n\n    /**\n     * Return all of the values from this generator as an array. You do not want to call this on an\n     * infinite generator (for obvious reasons); consider using [[EnhancedGenerator.slice]] or\n     * [[EnhancedGenerator.limit]] to limit the size before calling this.\n     */\n    asArray(): ReturnValue<T[], S> {\n        return this._impl.asArray<T, TReturn, TNext>(this);\n    }\n\n    /**\n     * Limit the number of values that can be generated. A `RangeError` is thrown if this limit is\n     * exceeded. See [[EnhancedGenerator.slice]] if you want to truncate.\n     * @param max\n     */\n    limit(max: number): Enhanced<T, S, TReturn, TNext> {\n        return this._impl.limit(max, this);\n    }\n\n    /**\n     * Operate on each value produced by this generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @param thisArg Value to be supplied as context `this` for function _f_.\n     */\n    forEach(f: IndexedFn<T, void, S>, thisArg?: any): void {\n        this._impl.forEach<T, TReturn, TNext>(f, thisArg, this);\n    }\n\n    /**\n     * Apply the function to each value yielded by this generator. It is called with two arguments,\n     * the value yielded, and a sequential index. The return value is a generator that yields the\n     * values produced by the function.\n     * @param f\n     * @param thisArg Optional value to be supplied as context `this` for function _f_.\n     */\n    map<V>(f: IndexedFn<T, V, S>, thisArg?: any): Enhanced<V, S, TReturn, TNext> {\n        return this._impl.map(f, thisArg, this);\n    }\n\n\n    /**\n     * Return a new [[EnhancedGenerator]] that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     */\n    filter(f: IndexedPredicate<T, S>, thisArg?: any): Enhanced<T, S, TReturn, TNext> {\n        return this._impl.filter(f, thisArg, this);\n    }\n\n    /**\n     * Flatten the values yielded by this generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param depth (default = 1)\n     */\n    flat<D extends number>(depth: D = 1 as D): Enhanced<S, FlatGen<T, D>, TReturn, TNext> {\n        return this._impl.flat<D, T, TReturn, TNext>(depth, this);\n    }\n\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a generator that yields the individual values at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param depth\n     */\n    flatMap<D extends number = 1>(f: IndexedFn<T, FlatGen<T, D>, S>, depth: D = 1 as D):\n        Enhanced<S, FlatGen<T, D>, TReturn, TNext>\n    {\n        return this._impl.flatMap<D, T, FlatGen<T, D>, TReturn, TNext>(f, depth, this);\n    }\n\n    /**\n     * Return a new [[EnhancedGenerator]] that only yields the indicated values, skipping _start_ initial values\n     * and continuing until the _end_.\n     * @param start\n     * @param end\n     */\n    slice(start: number = 0, end: number = Number.POSITIVE_INFINITY): Enhanced<T, S, TReturn | undefined, TNext> {\n        return this._impl.slice(start, end, this);\n    }\n\n    /**\n     * Concatenates generators (or iterators or iterables).\n     *\n     * Ensures that any supplied generators are terminated when this is terminated.\n     * @param gens zero or more additional [[Genable]] to provide values.\n     */\n\n    concat<T, TReturn, TNext>(...gens: Array<Genable<T, S, TReturn, TNext>>):\n        Enhanced<T, S, TReturn | void, TNext>\n    {\n        const self = this as UnwrapArray<typeof gens>;\n        return this._impl.concat(self, ...gens);\n    }\n\n\n    /**\n     * Like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\") is omitted\n     * because there is no array.\n     * @param f\n     */\n    reduce<A, T, TReturn, TNext>(f: Reducer<A, T, T, S>): ReturnValue<A, S>;\n    /**\n     * Like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\") is omitted\n     * because there is no array.\n     * @param f\n     * @param init\n     */\n    reduce<A, T, TReturn = T, TNext = T>(f: Reducer<A, T, A, S>, init: A): ReturnValue<A, S>;\n    reduce<A>(f: Reducer<A, T, A, S>, init?: A): ReturnValue<A, S> {\n        return this._impl.reduce<A, T, TReturn, TNext>(f, init as A, this);\n    }\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    some<T>(p: IndexedPredicate<T, S>, thisArg?: any): ReturnValue<boolean, S> {\n        // Why is type typecast to Genable needed here?\n        // Yet the seemingly identical case of 'every' below does not?\n        return this._impl.some(p, thisArg, this as Genable<T, S, TReturn, TNext>);\n    }\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    every(p: IndexedPredicate<T, S>, thisArg?: any): ReturnValue<boolean, S> {\n        return this._impl.every(p, thisArg, this as Genable<T, S, TReturn, TNext>);\n    }\n\n\n    /**\n     * Returns a new generator that repeats the last value returned by this (or `undefined` if this\n     * did not return any values).\n     *\n     * @param max\n     */\n    repeatLast(max: number = Number.POSITIVE_INFINITY): Enhanced<T, S, TReturn | void, TNext> {\n        return this._impl.repeatLast(this, max);\n    }\n\n\n    /**\n     * Returns a new generator that repeats the supplied value after this generator\n     * completes.\n     *\n     * @param value the value to repeat\n     * @param repetitions The number repetitions; the default is infinite.\n     */\n\n    repeat<N>(value: N, repetitions: number = Number.POSITIVE_INFINITY): Enhanced<T | N, S, void, TNext> {\n        const tail = this._impl.repeat<T|N, void, TNext>(value, repetitions);\n        const result = this._impl.concat(\n            this as Genable<T|N, S, undefined, TNext>,\n            tail as Genable<T|N, S, undefined, TNext>\n        );\n        return result as Enhanced<T | N, S, undefined, TNext>;\n    }\n\n    /**\n     * Combines this generator with additional ones, returning a generator that produces a tuple with\n     * each of their results, with this generator's result first.\n     *\n     * Terminates when any generator terminates. To get other behaviors, use with [[EnhancedGenerator.repeat]] or\n     * [[EnhancedGenerator.repeatLast]].\n     * @param gens\n     */\n\n    zip<G extends (Genable<T, S, TReturn, TNext>)[], T, TReturn, TNext>(...gens: G):\n        Enhanced<Array<T>, S, TReturn, TNext>\n    {\n        return this._impl.zip(this as Genable<T, S, TReturn, TNext>, ...gens) as\n            Enhanced<Array<T>, S, TReturn, TNext>;\n    }\n\n    /**\n     * Trivial, but handy, same as **Array.prototype.join**.\n     * @param sep (default = ',').\n     *\n     * See also [[EnhancedGenerator.join]]\n     */\n    join(sep?: string): ReturnValue<string, S> {\n        return this._impl.join(this, sep);\n    }\n\n    /**\n     * Sorts the supplied values and returns a sorted array.\n     * @param cmp a comparison function\n     */\n    sort(cmp?: (a: T, b: T) => number): ReturnValue<T[], S> {\n        return this._impl.sort(cmp)(this as Genable<T, S, TReturn, TNext>);\n    }\n}\n","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * This entry point loads asynchronous extended generators\n * @packageDocumentation\n * @module async\n * @preferred\n */\n\nimport type {\n    Enhanced, FlatGen, Genable, GeneratorOps, GenOp, GenOpValue, IndexedFn, IndexedPredicate, Reducer, ReturnValue, UnwrapArray\n    } from \"./types\";\n// Should be 'import type' but that makes TS insist it can't be a value here even after defining it.\nimport {Async} from './types';\nimport {\n    isAsyncGenable, isAsyncGenerator, isAsyncIterable, isAsyncIterator, isGenable, isIterable,\n    toAsyncGenerator, toAsyncIterable, toAsyncIterator\n} from \"./functions\";\nimport {Enhancements} from \"./enhancements\";\n\n/**\n * Asynchronous implementation of enhanced generators\n */\n\n\nclass Async_ implements GeneratorOps<Async> {\n    /**\n     * Return a generator that yields the supplied values.\n     * @param values\n     */\n    of<T extends any[], TReturn, TNext>(...values: T):\n        Enhanced<UnwrapArray<T>, Async, TReturn, TNext>\n    {\n        return this.enhance(values);\n    }\n\n    async asArray<T, TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>):\n        Promise<T[]>\n    {\n        const it = toAsyncIterator(gen);\n        const result: T[] = []\n        while (true) {\n            const r = await it.next();\n            if (r.done) {\n                return result;\n            }\n            result.push(r.value);\n        }\n    }\n\n    limit<T, TReturn, TNext>(max: number, gen: Genable<T, Async, TReturn, TNext>):\n        Enhanced<T, Async, TReturn, TNext>;\n\n    limit(max: number):\n        GenOp<Async>;\n\n    limit<T, TReturn, TNext>(\n        max: number,\n        gen?: Genable<T, Async, TReturn, TNext>\n    ):\n         Enhanced<T, Async, TReturn, TNext>\n         | GenOp<Async>\n    {\n        let self: EnhancedAsyncGenerator<T, TReturn, TNext>;\n        async function *limit<X, XReturn = X, XNext = X>(gen: AsyncIterator<X, XReturn, XNext>) {\n            let nr: XNext;\n            let limited: boolean = false;\n            try {\n                for (let i = 0; i < max; i++) {\n                    const r: any = await gen.next(nr!);\n                    if (r.done) {\n                        return r.value;\n                    }\n                    try {\n                        nr = yield r.value;\n                    } catch (e) {\n                        await gen.throw?.(e);\n                    }\n                }\n                limited = true;\n                const err = new RangeError(`Generator produced excessive values > ${max}.`);\n                await gen.throw?.(err);\n                throw err;\n            } finally {\n                if (!limited) {\n                    await gen.return?.(self?.returning);\n                    // Even if the supplied generator refuses to terminate, we terminate.\n                }\n            }\n        }\n        if (gen) {\n            return self = this.enhance(limit(toAsyncIterator(gen)));\n        }\n        return <X, XReturn = X, XNext = X>(gen: Genable<X, Async, XReturn, XNext>) =>\n            this.enhance<X, XReturn, XNext>(limit(toAsyncIterator(gen)));\n    }\n\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @param thisArg Optional value to be supplied as context `this` for function _f_.\n     * @param gen the generator.\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T, TReturn, TNext>(f: IndexedFn<T, undefined, Async>, thisArg: any, gen: Genable<T, Async, TReturn, TNext>):\n        Promise<undefined>;\n\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @param gen the generator.\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T, TReturn, TNext>(f: IndexedFn<T, undefined, Async>, gen: Genable<T, Async, TReturn, TNext>):\n        Promise<undefined>;\n\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @param thisArg Optional value to be supplied as context `this` for function _f_.\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T>(f: IndexedFn<T, undefined, Async>, thisArg?: any):\n        <TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>) =>\n            Promise<undefined>;\n\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T>(f: IndexedFn<T, undefined, Async>):\n        <TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>, thisArg?: any) =>\n            Promise<undefined>;\n\n    forEach<T, TReturn = T, TNext = T>(\n        f: IndexedFn<T, undefined, Async>,\n        thisArgOrGen?: Genable<T, Async, TReturn, TNext>|any,\n        gen?: Genable<T, Async, TReturn, TNext>\n        ): Promise<undefined>\n            | (<XReturn = TReturn, XNext = TNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n                                                Promise<undefined>)\n    {\n        const forEach = async <XReturn, XNext>(\n                                f: IndexedFn<T, XReturn, Async>,\n                                thisArg: any,\n                                gen: Genable<T, Async, XReturn, XNext>\n                            ): Promise<undefined> =>\n            {\n                const it = toAsyncIterator(gen);\n                let idx = 0;\n                while (true) {\n                    const r = await it.next();\n                    if (r.done) return;\n                    await f.call(thisArg, r.value, idx++);\n                }\n            };\n        if (gen) return forEach(f, thisArgOrGen, gen!);\n        if (isAsyncGenable<T, TReturn, TNext>(thisArgOrGen)) return forEach(f, undefined, thisArgOrGen);\n        return <XReturn = T, XNext = T>(gen: Genable<T, Async, XReturn, XNext>, thisArg?: any) =>\n            forEach(f, thisArg ?? thisArgOrGen, gen);\n    }\n\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Async>):\n            GenOpValue<Async, T, V>;\n\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Async>, thisArg?: any):\n            GenOpValue<Async, T, V>;\n\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Async>, gen: Genable<T, Async, TReturn, TNext>):\n            Enhanced<V, Async, TReturn, TNext>;\n\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Async>, thisArg: any, gen: Genable<T, Async, TReturn, TNext>):\n            Enhanced<V, Async, TReturn, TNext>;\n\n    map<T, V,TReturn, TNext>(\n        f: IndexedFn<T, V, Async>,\n        thisArg?: any | Genable<T, Async, TReturn, TNext>,\n        iter?: Genable<T, Async, TReturn, TNext>\n    ):\n        EnhancedAsyncGenerator<V, TReturn, TNext>\n        | (<XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n                EnhancedAsyncGenerator<V, XReturn, XNext>)\n        | (<XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, thisArg?: any) =>\n                EnhancedAsyncGenerator<V, XReturn, XNext>)\n    {\n        const map = <XReturn = T, XNext = T>(thisArg: any, iter: Genable<T, Async, XReturn, XNext>) => {\n            const gen = toAsyncGenerator(iter);\n            let self: EnhancedAsyncGenerator<V, XReturn, XNext>;\n            async function* map(): AsyncGenerator<V, XReturn, XNext> {\n                let nr: any = undefined;\n                let idx = 0;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = await gen.next(nr);\n                                if (r.done) return r.value;\n                                const v = await f.call(thisArg, await r.value, idx++);\n                                try {\n                                    nr = yield v;\n                                } catch (e) {\n                                    await gen.throw(e);\n                                }\n                            }\n                        } finally {\n                            const x = await gen.return(self?.returning);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (!x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            return self = this.enhance(map());\n        };\n        if (iter) return map(thisArg, iter);\n        if (isAsyncGenable<T, TReturn, TNext>(thisArg)) return map(undefined, thisArg);\n        return <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, genThisArg?: any) =>\n                    map(genThisArg ?? thisArg, gen);\n    }\n\n    /**\n     * Return a function that filters a [[Genable]] and yields a new [[EnhancedGenerator]]\n     * that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @typeParam T the type of value.\n     */\n    filter<T>(f: IndexedPredicate<T, Async>):\n        GenOpValue<Async, T, T>;\n\n    /**\n     * Return a function that filters a [[Genable]] and yields a new [[EnhancedGenerator]]\n     * that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     * @typeParam T the type of value.\n     */\n    filter<T>(f: IndexedPredicate<T, Async>, thisArg: any):\n        GenOpValue<Async, T, T>;\n\n    /**\n     * Return a new [[EnhancedGenerator]] that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param iter a [[Genable|Genable<T>]]\n     * @typeParam T the type of value.\n     */\n    filter<T, TReturn, TNext>(f: IndexedPredicate<T, Async>, iter: Genable<T, Async, TReturn, TNext>):\n        Enhanced<T, Async, TReturn, TNext>;\n\n    /**\n     * Return a new [[EnhancedGenerator]] that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     * @param iter a [[Genable|Genable<T>]]\n     * @typeParam T the type of value.\n     */\n    filter<T, TReturn, TNext>(f: IndexedPredicate<T, Async>, thisArg: any, iter: Genable<T, Async, TReturn, TNext>):\n        Enhanced<T, Async, TReturn, TNext>;\n\n    /**\n     * Return a function that filters a [[Genable]] and yields a new [[EnhancedGenerator]]\n     * that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     * @param iter the [[Genable]] to filter.\n     * @typeParam T the type of value.\n     */\n    filter<T, TReturn, TNext>(\n        f: IndexedPredicate<T, Async>,\n        thisArg?: any | Genable<T, Async, TReturn, TNext>,\n        iter?: Genable<T, Async, TReturn, TNext>\n    ):\n        Enhanced<T, Async, TReturn, TNext>\n        | GenOpValue<Async, T, T>\n    {\n        const filter = <XReturn, XNext>(thisArg: any, iter: Genable<T, Async, XReturn, XNext>) => {\n            const gen = toAsyncGenerator<T, XReturn, XNext>(iter);\n            let self: EnhancedAsyncGenerator<T, XReturn, XNext>;\n            async function* filter<V>(f: IndexedPredicate<T, Async>): AsyncGenerator<T, XReturn, XNext> {\n                let nr: any = undefined;\n                let idx = 0;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = await gen.next(nr);\n                                if (r.done) return r.value;\n                                if (await f.call(thisArg, r.value, idx++)) {\n                                    try {\n                                        nr = yield r.value;\n                                    } catch (e) {\n                                        await gen.throw(e);\n                                    }\n                                }\n                            }\n                        } finally {\n                            const x = await gen.return?.(self?.returning);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (!x?.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            return self = this.enhance(filter(f));\n        };\n\n        if (iter) return filter(thisArg, iter);\n        if (isAsyncGenable<T, TReturn, TNext>(thisArg)) return filter(undefined, thisArg);\n        return <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, genThisArg?: any) =>\n            filter<XReturn, XNext>(genThisArg ?? thisArg, gen);\n    }\n\n\n    /**\n     * Flatten the values yielded by the generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param depth\n     */\n    flat<D extends number>(depth: D):\n        <T, TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>) =>\n            Enhanced<FlatGen<T, D>, Async, TReturn, TNext>;\n\n    /**\n     * Flatten the values yielded by the generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param depth\n     * @param gen\n     */\n\n    flat<D extends number, T, TReturn, TNext>(depth: D, gen: Genable<T, Async, TReturn, TNext>):\n        Enhanced<FlatGen<T, D>, Async, TReturn, TNext>;\n\n    /**\n     * Flatten the values yielded by the generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param gen\n     * @param depth default = 1\n     */\n    flat<D extends number, T, TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>, depth?: D):\n        Enhanced<FlatGen<T, D>, Async, TReturn, TNext>;\n\n    flat<D extends number, T, TReturn, TNext>(depth: D|Genable<T, Async, TReturn, TNext>, gen?: Genable<T, Async, TReturn, TNext> | D):\n        Enhanced<FlatGen<T, D>, Async, TReturn, TNext>\n        | (<X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>) =>\n                Enhanced<FlatGen<X, D>, Async, XReturn, XNext>)\n    {\n        const flat = <X, XReturn, XNext>(depth: D, gen: Genable<X, Async, XReturn, XNext>) => {\n            let self: Enhanced<FlatGen<X, D>, Async, XReturn, XNext>;\n            const gens = new Set<AsyncGenerator>();\n            if (isAsyncGenerator(gen)) gens.add(gen);\n\n            async function* flat<D extends number, Y, YReturn, YNext>(it: AsyncIterator<Y, YReturn, YNext>, depth: D): AsyncGenerator<FlatGen<Y, D>, YReturn, YNext> {\n                let nr: any = undefined;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = await it.next(nr);\n                                if (r.done) return r.value;\n                                const v: any = r.value;\n                                if (isAsyncGenerator(v)) {\n                                    gens.add(v);\n                                }\n                                try {\n                                    if (depth > 0 && isAsyncIterator(v)) {\n                                        yield* flat(v, depth - 1);\n                                    } else if (depth > 0 && (isAsyncIterable(v) || isIterable(v))) {\n                                        yield* flat(toAsyncIterator(v), depth - 1)\n                                    } else {\n                                        nr = yield r.value as FlatGen<T, D>;\n                                    }\n                                } catch (e) {\n                                    await it.throw?.(e);\n                                }\n                            }\n                        } finally {\n                            const x = await it.return?.(self?.returning);\n                            if (isAsyncGenerator(it)) gens.delete(it);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (x && !x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                            for (const g of gens) {\n                                await g.return(self?.returning);\n                            }\n                        }\n                    }\n                }\n            }\n\n            return self = this.enhance(flat(toAsyncIterator(gen), depth));\n        }\n        if (typeof depth === 'number') {\n            if (gen) {\n                if (isAsyncGenable(gen)) {\n                    return flat(depth, gen);\n                } else {\n                    throw new TypeError(`Invalid Genable: ${gen}`);\n                }\n            }\n            return <X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>) =>\n                flat(depth, gen);\n        } else if (isAsyncGenable(depth)) {\n            return flat((gen ?? 1) as D, depth);\n        }\n        throw new TypeError(`Illegal arguments to flat()`);\n    }\n\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a function that accepts a generator, and returns another generator that yields the individual value\n     * at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param depth\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T>(f: IndexedFn<T, R, Async>, depth: D):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n            Enhanced<R, Async, XReturn, XNext>;\n\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a function that accepts a generator, and returns another generator that yields the individual value\n     * at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T>(f: IndexedFn<T, R, Async>):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, depth?: D) =>\n            Enhanced<R, Async, XReturn, XNext>;\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a generator that yields the individual values at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param gen\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T, TReturn, TNext>(\n            f: IndexedFn<T, R, Async>,\n            gen: Genable<T, Async, TReturn, TNext>\n    ):\n        Enhanced<R, Async, TReturn, TNext>;\n\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a generator that yields the individual values at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param depth\n     * @param gen\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T, TReturn, TNext>(\n        f: IndexedFn<T, R, Async>,\n        depth: D,\n        gen: Genable<T, Async, TReturn, TNext>\n    ):\n        Enhanced<R, Async, TReturn, TNext>;\n\n    flatMap<D extends number, R extends FlatGen<T, D>, T, TReturn, TNext>(\n        f: IndexedFn<T, R, Async>,\n        depthOrGen?: D | Genable<T, Async, TReturn, TNext>,\n        gen?: Genable<T, Async, TReturn, TNext>\n    ):\n        Enhanced<R, Async, TReturn, TNext>\n        | (\n            <Y extends FlatGen<T, D>, X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>) =>\n                Enhanced<Y, Async, XReturn, XNext>\n        )\n        | (\n            <Y extends FlatGen<T, D>, X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>, depth?: D) =>\n                Enhanced<Y, Async, XReturn, XNext>\n        )\n    {\n        const flatMap = <X, XReturn, XNext>(depth: D, gen: Genable<X, Async, XReturn, XNext>) => {\n            let self: Enhanced<FlatGen<X, D>, Async, XReturn, XNext>;\n            let idx = 0;\n\n            async function* flatMap<D extends number, Y, YReturn, YNext>(\n                    it: AsyncIterator<Y, YReturn, YNext>, depth: D\n                ):\n                    AsyncGenerator<FlatGen<T, D>, YReturn, YNext>\n                {\n                let nr: any = undefined;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = await it.next(nr);\n                                if (r.done) return r.value;\n                                const v = await f(r.value as FlatGen<T, D>, idx++);\n                                try {\n                                    if (isAsyncIterator<unknown, YReturn, YNext>(v)) {\n                                        if (depth > 1) {\n                                            yield* flatMap(v, depth - 1);\n                                        } else if (depth === 1) {\n                                            const it = toAsyncIterator(v);\n                                            yield* toAsyncGenerator(it);\n                                        } else {\n                                            yield v;\n                                        }\n                                    } else if (isAsyncIterable<unknown, YReturn, YNext>(v) || isIterable<unknown, YReturn, YNext>(v)) {\n                                        if (depth > 1) {\n                                            yield* flatMap(toAsyncIterator(v), depth - 1);\n                                        } else if (depth === 1) {\n                                            yield* toAsyncGenerator(v);\n                                        } else {\n                                            yield v;\n                                        }\n                                    } else {\n                                        nr = yield v;\n                                    }\n                                } catch (e) {\n                                    await it.throw?.(e);\n                                }\n                            }\n                        } finally {\n                            const x = await it.return?.(self?.returning);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (x && !x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            return self = this.enhance(flatMap(toAsyncIterator(gen), depth));\n        }\n\n        if (isAsyncGenable(gen)) {\n            return flatMap(depthOrGen as D ?? 1 as D, gen);\n        } else if (isAsyncGenable( depthOrGen)) {\n            return flatMap(1 as D, depthOrGen);\n        }\n        return <X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>, depth?: D) =>\n            flatMap(depthOrGen ?? depth ?? 1 as D, gen);\n    }\n\n    /**\n     * Return a new [[EnhancedGenerator]] that only yields the indicated values, skipping _start_ initial values\n     * and continuing until the _end_.\n     * @param start\n     * @param end\n     */\n    slice<T>(start: number, end: number):\n        <X, XReturn, XNext>(iter: Genable<X, Async, XReturn, XNext>) =>\n            Enhanced<X, Async, XReturn, XNext>;\n    /**\n     * Return a new [[EnhancedGenerator]] that only yields the indicated values, skipping _start_ initial values\n     * and continuing until the _end_.\n     * @param start\n     * @param end\n     * @param iter\n     */\n    slice<T, TReturn, TNext>(start: number, end: number, iter: Genable<T, Async, TReturn, TNext>):\n        Enhanced<T, Async, TReturn, TNext>;\n\n    slice<T, TReturn, TNext>(\n        start: number,\n        end: number,\n        iter?: Genable<T, Async, TReturn, TNext>\n    ):\n        Enhanced<T, Async, TReturn | undefined, TNext>\n        | (\n            <X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>) =>\n                Enhanced<X, Async, XReturn | undefined, XNext>\n        )\n    {\n        const slice = <X, XReturn, XNext>(iter: Genable<X, Async, XReturn, XNext>):\n            Enhanced<X, Async, XReturn | undefined, XNext> =>\n        {\n            const it = toAsyncIterator(iter);\n            async function* slice(start: number, end: number) {\n                for (let i = 0; i < start; i++) {\n                    const r = await it.next();\n                    if (r.done) return r.value;\n                }\n                if (end === Number.POSITIVE_INFINITY) {\n                    yield* toAsyncIterable(it);\n                } else {\n                    let nv: XNext;\n                    while (true) {\n                        try {\n                            for (let i = start; i < end; i++) {\n                                const r = await it.next(nv!);\n                                if (r.done) return r.value;\n                                try {\n                                    nv = yield r.value;\n                                } catch (e) {\n                                    const re = await it.throw?.(e);\n                                    if (re) {\n                                        if (re.done) return re.value;\n                                        nv = yield re.value;\n                                    }\n                                }\n                            }\n                        } finally {\n                            const x = await it.return?.();\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (x && !x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n                return;\n            }\n            return this.enhance(slice(start, end));\n        };\n        if (!iter) return slice;\n        return slice(iter);\n    }\n\n    /**\n     * Concatenates generators (or iterators or iterables).\n     *\n     * Ensures that any supplied generators are terminated when this is terminated.\n     * @param gens zero or more additional [[Genable]] to provide values.\n     */\n    concat<T, TReturn, TNext>(...gens: Array<Genable<T, Async, TReturn, TNext>>):\n        Enhanced<T, Async, TReturn | void, TNext>\n    {\n        let self: Enhanced<T, Async, TReturn | void, TNext>;\n        async function* concat(): AsyncGenerator<T, TReturn | void, TNext> {\n            let i = 0;\n            try {\n                for (; i < gens.length; i++) {\n                    const it = toAsyncIterable(gens[i]);\n                    yield* it;\n                }\n            } finally {\n                // Terminate any remaining generators.\n                for (; i < gens.length; i++) {\n                    const g = gens[i];\n                    if (isAsyncGenerator(g)) {\n                        await g.return(self?.returning);\n                    }\n                }\n            }\n        }\n\n        return self = this.enhance(concat());\n    }\n\n    /**\n     * Reduces **gen** like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     * @param f\n     * @param gen\n     */\n    reduce<A, T, TReturn, TNext>(f: Reducer<A, T, T, Async>, gen: Genable<T, Async, TReturn, TNext>):\n        A;\n\n    /**\n     *\n     * Returns a reducer function that, when applied to a `Generator` **gen**, reduces **gen** like\n     * **Array.prototype.reduce**. The 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     *\n     * @param f\n     */\n    reduce<A, T>(f: Reducer<A, T, T, Async>):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n            A;\n\n    /**\n     *\n     * Returns a reducer function that, when applied to a `Generator` **gen**, reduces **gen** like\n     * `Array.prototype.reduce`. The 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     *\n     * @param f\n     */\n    reduce<A, T>(f: Reducer<A, T, A, Async>):\n        <XReturn, XNext>(init: A, gen: Genable<T, Async, XReturn, XNext>) =>\n            A;\n\n    /**\n     * Reduces **gen** like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     * @param f\n     * @param init\n     * @param gen\n     */\n    reduce<A, T, TReturn, TNext>(f: Reducer<A, T, A, Async>, init: A, gen: Genable<T, Async, TReturn, TNext>):\n        A;\n\n    /**\n     * Returns a reducer function that, when applied to a `Generator` **gen**, reduces **gen** like\n     * `Array.prototype.reduce`. The 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     *\n     * Alternatively, the init value can be supplied along with the generator as a second argument.\n     * @param f\n     * @param init\n     */\n    reduce<A, T>(f: Reducer<A, T, A, Async>, init: A):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n            A;\n\n    reduce<A, T, TReturn, TNext>(\n        f: Reducer<A, T, A | T, Async>,\n        initOrGen?: A | Genable<T, Async, TReturn, TNext>,\n        gen?: Genable<T, Async, TReturn, TNext>\n    ): A\n        | Promise<A>\n        | (\n            (gen: Genable<T, Async, TReturn, TNext>) =>\n                A | Promise<A>\n        )\n        | (\n            (f: (acc: A, v: T) => A, init: A) =>\n                A | Promise<A>\n        )\n        | (\n            (f: (acc: A | T, v: T) => A) =>\n                A | Promise<A>\n        )\n    {\n\n        const reduce = async <XReturn, XNext>(init: A | PromiseLike<A> | undefined, it: AsyncIterator<T, XReturn, XNext>):\n            Promise<A> =>\n        {\n            let acc: A | T | undefined = await init;\n            if (acc === undefined) {\n                const r = await it.next();\n                if (r.done) throw new TypeError(`No initial value in reduce`);\n                acc = r.value;\n            }\n            while (true) {\n                const r = await it.next();\n                if (r.done) return acc as A;\n                acc = await f(acc, r.value);\n            }\n        };\n        if (isAsyncGenable(gen)) {\n            return reduce(initOrGen as A, toAsyncIterator(gen));\n        } else if (isAsyncGenable(initOrGen)) {\n            return reduce(undefined, toAsyncIterator(initOrGen));\n        }\n        return (gen: Genable<T, Async, TReturn, TNext>, init?: A) =>\n            reduce(init ?? initOrGen, toAsyncIterator(gen));\n    }\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    some<T, TReturn, TNext>(p: IndexedPredicate<T, Async>, thisArg?: any):\n        (gen: Genable<T, Async, TReturn, TNext>) =>\n            ReturnValue<boolean, Async>;\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     */\n    some<T>(p: IndexedPredicate<T, Async>):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, thisArg?: any) =>\n            ReturnValue<boolean, Async>;\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param gen the generator\n     */\n    some<T, TReturn, TNext>(p: IndexedPredicate<T, Async>, gen: Genable<T, Async, TReturn, TNext>):\n        ReturnValue<boolean, Async>;\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     * @param gen the generator\n     */\n    some<T, TReturn, TNext>(p: IndexedPredicate<T, Async>, thisArg: any, gen: Genable<T, Async, TReturn, TNext>):\n        ReturnValue<boolean, Async>;\n\n    some<T, TReturn, TNext>(\n        pred: IndexedPredicate<T, Async>,\n        thisOrGen?: any | Genable<T, Async, TReturn, TNext>,\n        gen?: Genable<T, Async, TReturn, TNext>\n    ):\n        ReturnValue<boolean, Async>\n        | (\n            (gen: Genable<T, Async, TReturn, TNext>) =>\n                ReturnValue<boolean, Async>\n        )\n    {\n        const some = async <XReturn, XNext>(thisArg: any, it: AsyncIterator<T, XReturn, XNext>): Promise<boolean> => {\n            let i = 0;\n            while (true) {\n                const r = await it.next();\n                if (r.done) return false;\n                if (pred.call(thisArg, r.value, i++)) return true;\n            }\n        };\n        if (isAsyncGenable(gen)) {\n            return some(thisOrGen, toAsyncIterator(gen));\n        } else if (isAsyncGenable(gen)) {\n            return (gen: Genable<T, Async, TReturn, TNext>, thisArg?: any) =>\n                some(thisArg ?? thisOrGen, toAsyncIterator(gen));\n        }\n        throw new Error(`Invalid argument to some: ${gen ?? thisOrGen}`);\n    }\n\n\n    /**\n     * Returns `false` and terminates the generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    every<T>(p: IndexedPredicate<T, Async>, thisArg?: any):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n            ReturnValue<boolean, Async>;\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     */\n    every<T>(p: IndexedPredicate<T, Async>):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, thisArg?: any) =>\n            ReturnValue<boolean, Async>;\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param gen the generator\n     */\n    every<T, TReturn, TNext>(p: IndexedPredicate<T, Async>, gen: Genable<T, Async,TReturn, TNext>):\n        ReturnValue<boolean, Async>;\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     * @param gen the generator\n     */\n    every<T, TReturn, TNext>(p: IndexedPredicate<T, Async>, thisArg: any, gen: Genable<T, Async, TReturn, TNext>):\n        ReturnValue<boolean, Async>;\n\n    every<T, TReturn, TNext>(\n        pred: IndexedPredicate<T, Async>,\n        genOrThis?: any | Genable<T, Async, TReturn, TNext>,\n        gen?: Genable<T, Async, TReturn, TNext>\n    ):\n        ReturnValue<boolean, Async>\n        | (\n            <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n                ReturnValue<boolean, Async>\n        )\n    {\n        const every = async <XReturn, XNext>(thisArg: any, it: AsyncIterator<T, XReturn, XNext>):\n            Promise<boolean> =>\n        {\n            let i = 0;\n            while (true) {\n                const r = await it.next();\n                if (r.done) return true;\n                if (!pred.call(thisArg, r.value, i++)) return false;\n            }\n        };\n        if (isAsyncGenable(gen)) {\n            return every(genOrThis, toAsyncIterator(gen));\n        } else if (isGenable(gen)) {\n            return <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, thisArg?: any) =>\n                every(thisArg ?? genOrThis, toAsyncIterator(gen));\n        }\n        throw new Error(`Invalid argument to every: ${gen ?? genOrThis}`);\n    }\n\n    /**\n     * Returns a new generator that repeats the last value returned by **gen** (or `undefined` if **gen**\n     * did not return any values).\n     *\n     * @param gen\n     * @param max\n     */\n    repeatLast<T, TReturn, TNext>(\n        gen: Genable<T, Async, TReturn, TNext>,\n        max: number = Number.POSITIVE_INFINITY\n    ):\n        Enhanced<T, Async, TReturn | undefined, TNext>\n    {\n        const it = toAsyncIterator(gen);\n        let nr: TNext;\n        let self: Enhanced<T, Async, TReturn | undefined, TNext>;\n\n        async function* repeatLast(): AsyncGenerator<T, TReturn | undefined, TNext> {\n            try {\n                let last: T;\n                while (true) {\n                    const r = await it.next(nr as unknown as TNext)\n                    if (r.done) break;\n                    try {\n                        nr = yield (last = r.value);\n                    } catch (e) {\n                        const re = await it.throw?.(e);\n                        if (re) {\n                            if (re.done) break;\n                            yield last = re.value;\n                        }\n                    }\n                }\n                for (let i = 0; i < max; i++) {\n                    // Important to await at the expected point for consistent behavior.\n                    yield await last!;\n                }\n            } finally {\n                await it.return?.(self?.returning);\n            }\n            return;\n        }\n\n        return self = this.enhance(repeatLast());\n    }\n\n\n    /**\n     * Returns a new generator that repeats the supplied value.\n     *\n     * @param value the value to repeat\n     * @param repetitions The number repetitions; the default is infinite.\n     */\n    repeat<T, TNext>(value: T, repetitions: number = Number.POSITIVE_INFINITY):\n        Enhanced<T, Async, void, TNext>\n    {\n        async function* repeat(): AsyncGenerator<T, void, TNext> {\n            for (let i = 0; i < repetitions; i++) {\n                // Important to await at the expected point for consistent behavior.\n                yield await value;\n            }\n        }\n\n        return this.enhance(repeat());\n    }\n\n    /**\n     * Combines generators, returning a generator that produces a tuple with each of their results.\n     *\n     * Terminates when the first generator terminates. To get other behaviors, use with [[EnhancedGenerator.repeat]] or\n     * [[EnhancedGenerator.repeatLast]].\n     * @param gens\n     */\n    zip<T, TReturn, TNext>(...gens: Array<Genable<T, Async, TReturn, TNext>>):\n        Enhanced<Array<T>, Async, TReturn, TNext>\n    {\n        if (gens.length === 0) return this.enhance([]);\n        const its = gens.map(toAsyncIterator);\n        let done = false;\n        let self: Enhanced<Array<T>, Async, TReturn, TNext>;\n\n        async function* zip2(): AsyncGenerator<Array<T>, TReturn, TNext> {\n            try {\n                while (true) {\n                    let result: Array<T> = [];\n                    for (const g of its) {\n                        const r = await g.next();\n                        if (r.done) {\n                            done = true;\n                            return r.value;\n                        }\n                        (result as any[]).push(r.value);\n                    }\n                    try {\n                        yield result;\n                    } catch (e) {\n                        for (const g of gens) {\n                            try {\n                                // Weird need for a typecast here.\n                                await (g as any).throw?.(e);\n                            } catch {\n                                // Ignore\n                            }\n                        }\n                        throw e;\n                    }\n                }\n            } finally {\n                if (!done) {\n                    for (const g of gens) {\n                        try {\n                            // Weird need for a typecast here.\n                            await (g as any).return?.(self?.returning);\n                        } catch {\n                            // Ignore\n                        }\n                    }\n                }\n            }\n        }\n\n        return self = this.enhance(zip2());\n    }\n\n\n    /**\n     * Returns a function that joins the elements produced by a [[Genable]], analogous to `Array.prototype.join`.\n     * @param sep (default = ',')\n     */\n    join(sep: string):\n        <T, TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>) =>\n            ReturnValue<string, Async>;\n\n    /**\n     * Joins the elements produced by a [[Genable]], analogous to `Array.prototype.join`.\n     * @param gen\n     * @param sep\n     */\n    join<T, TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>, sep?: string):\n        ReturnValue<string, Async>;\n\n    join<T, TReturn, TNext>(\n        genOrSeparator: Genable<T, Async, TReturn, TNext>|string,\n        sep?: string\n    ):\n        ReturnValue<string, Async>\n        | (\n            <X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>) =>\n                ReturnValue<string, Async>\n        )\n    {\n        if (typeof genOrSeparator === 'string') {\n            sep = genOrSeparator;\n            return <X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>) =>\n                this.join(gen, sep);\n        }\n        return Promise.resolve(this.enhance(genOrSeparator).asArray())\n            .then(a => a.join(sep));\n    }\n\n    /**\n     * Returns a new generator that returns values from each of the supplied sources as they are available.\n     * Values will be taken as they become available from any source.\n     * The yielded values will not be distinguished by which which source they are taken; for\n     * that, another method will be supplied.\n     *\n     * Any calls to `Generator.throw()` or `Generator.return()` will be passed to all non-terminated\n     * sources.\n     * @param sources\n     */\n    merge<T, TReturn, TNext>(...sources: Array<Genable<T, Async, TReturn, TNext>>):\n        Enhanced<T, Async, TReturn | void, TNext>\n    {\n        let self: Enhanced<T, Async, void | TReturn, TNext>;\n        let done: (r: IteratorReturnResult<TReturn>) => void;\n        const donePromise = new Promise<IteratorReturnResult<TReturn>>(r => (done = r));\n        let activeCount = sources.length;\n        let active: Array<Promise<() => (IteratorResult<T, TReturn> | null)> | Promise<IteratorReturnResult<TReturn>>>;\n        const dead = new Promise<() => (IteratorResult<T, TReturn> | null)>(() => null); // Never completes\n        let gens: Array<AsyncIterator<T, TReturn, TNext>> = [];\n        const wrap = async (g: Genable<T, Async, TReturn, TNext>, k: number) => {\n            const ag = toAsyncIterator(g);\n            gens[k] = ag;\n            const handle = async (val: IteratorResult<T, TReturn>): Promise<() => (IteratorResult<T, TReturn> | null)> =>\n                () => {\n                    if (val.done) {\n                        active[k] = dead;\n                        // Unless this is the last active generator, we return null to indicate\n                        // to the loop to go on to the next one.\n                        return --activeCount > 0\n                            ? null\n                            : (done(val), val);\n                    } else {\n                        const v = ag.next().then(handle);\n                        active[k] = v;\n                        return val;\n                    }\n                };\n            return (await ag.next().then(handle));\n        };\n        active = [...sources.map(wrap), donePromise];\n        async function* merge(): AsyncGenerator<T, TReturn | void, TNext> {\n            try {\n                let nv: TNext;\n                while (activeCount) {\n                    const race: Array<Promise<() => (IteratorResult<T, TReturn> | null)> | Promise<IteratorReturnResult<TReturn>>> = [];\n                    active.forEach(a => race.push(a))\n                    const result = await (await Promise.race(race));\n                    if (typeof result === 'function') {\n                        let r = result();\n                        if (r) {\n                            if (r.done) {\n                                return r.value;\n                            }\n                            nv = (yield r.value);\n                        }\n                    } else if (result && result.done) {\n                        return result.value;\n                    }\n                }\n            } finally {\n                if (activeCount) {\n                    for (let i = 0; i < sources.length; i++) {\n                        (active[i] === null ? null : gens[i])?.return?.(self?.returning);\n                    }\n                }\n            }\n        }\n        return self = Async.enhance(merge());\n    }\n\n    /**\n     * Returns a function that sorts the supplied sources and returns a sorted array.\n     * @param cmp a comparison function\n     */\n    sort<T>(cmp?: ((a: T, b: T) => number)) {\n        return async <TReturn, TNext>(...sources: Array<Genable<T, Async, TReturn, TNext>>) => {\n            const array: T[] = await this.merge(...sources).asArray();\n            return array.sort(cmp);\n        };\n    }\n\n    /**\n     * Enhance an existing generator (or iterator or iterable) to be a EnhancedGenerator.\n     * @param gen\n     */\n    enhance<T, TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>):\n        EnhancedAsyncGenerator<T, TReturn, TNext>\n    {\n        const gen2 = toAsyncGenerator(gen)as\n            unknown as Partial<EnhancedAsyncGenerator<T, TReturn, TNext>>;\n        const old = Object.getPrototypeOf(gen2);\n        const proto = Object.assign(Object.create(EnhancedAsyncGenerator.prototype), old);\n        proto.return = (v: any) => ((gen2 as any).returning = v, old.return.call(gen2, v));\n        proto[Symbol.asyncIterator] = () => gen2;\n        Object.setPrototypeOf(gen2, proto);\n        return gen2 as EnhancedAsyncGenerator<T, TReturn, TNext>;\n    }\n}\n\n/**\n * Factory for synchronous generator operators. See [[GeneratorOps]] for details.\n */\nconst Async: GeneratorOps<Async> = new Async_();\nexport {Async};\n\nexport abstract class EnhancedAsyncGenerator<T, TReturn, TNext>\n    extends Enhancements<T, TReturn, TNext, Async>\n    implements AsyncGenerator<T, TReturn, TNext>,\n        AsyncIterable<T>,\n        AsyncIterator<T, TReturn, TNext>\n{\n}\n\nconst makeProto = (base: any) => {\n    const newProto = Object.create(base);\n    const inherit = (proto: any) => {\n        for (const k of Reflect.ownKeys(proto)) {\n            if (k !== 'constructor') {\n                newProto[k] = proto[k];\n            }\n        }\n    };\n    inherit(Enhancements.prototype);\n    return newProto;\n}\n\n/**\n * @internal\n * @constructor\n */\nasync function* AsyncFoo() {\n}\n\n/**\n * @internal\n */\nexport const AsyncGenProto = Object.getPrototypeOf(AsyncFoo());\n\n// Make EnhancedGenerator inherit generator methods.\n\nObject.setPrototypeOf(EnhancedAsyncGenerator.prototype, makeProto(AsyncGenProto));\nObject.defineProperty(EnhancedAsyncGenerator.prototype, '_impl', {\n    value: Async,\n    writable: false,\n    enumerable: false,\n    configurable: false\n});\n"],"names":["isFunction","f","isAsyncGenable","g","isAsyncIterator","isAsyncIterable","isIterable","isAsyncGenerator","next","return","throw","Symbol","asyncIterator","toAsyncGenerator","i","it","async","r","done","value","wrap","iterator","Error","toIterator","isIterator","toAsyncIterator","asyncAdaptor","self","nr","Promise","resolve","e","returning","toAsyncIterable","iterable","toAsyncIterable_adaptor","Enhancements","toStringTag","asArray","this","_impl","limit","max","forEach","thisArg","map","filter","flat","depth","flatMap","slice","start","end","Number","POSITIVE_INFINITY","concat","gens","reduce","init","some","p","every","repeatLast","repeat","repetitions","tail","zip","join","sep","sort","cmp","Async","of","values","enhance","gen","result","push","limited","err","RangeError","thisArgOrGen","idx","call","undefined","iter","v","genThisArg","Set","add","x","delete","TypeError","depthOrGen","nv","re","length","initOrGen","acc","pred","thisOrGen","genOrThis","last","its","zip2","genOrSeparator","then","a","merge","sources","donePromise","active","activeCount","dead","k","ag","handle","val","race","gen2","old","Object","getPrototypeOf","proto","assign","create","EnhancedAsyncGenerator","prototype","setPrototypeOf","AsyncGenProto","AsyncFoo","base","newProto","Reflect","ownKeys","inherit","makeProto","defineProperty","writable","enumerable","configurable"],"mappings":"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"}