{"version":3,"file":"generators.js","sources":["../../src/functions.ts","../../src/enhancements.ts","../../src/sync.ts","../../src/async.ts","../../src/generators.ts"],"sourcesContent":["/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * Functions to test (as typeguards) and coerce generators, iterators, etc.\n *\n * @packageDocumentation\n * @module functions\n * @preferred\n */\n\n\nimport type {Async, Sync, Genable, FullIterable, FullIterableIterator} from \"./types\";\n\n/**\n * Predicate/Type Guard for any function.\n * @param f\n */\nexport const isFunction = <A extends Function>(f: (A | any)): f is A => {\n    return typeof f === 'function';\n}\n\n/**\n * Predicate/type guard to determine if an object is [[Genable]]. An object is [[Genable]] if it\n * supports the `Iterator` or `Iterable` protocols. (Generators support both).\n * @param g\n */\nexport const isGenable = <T, TReturn = T, TNext = T>(g: Iterator<T, TReturn, TNext>|Iterable<T>|Generator<T, TReturn, TNext>|any):\n    g is Genable<T, Sync, TReturn, TNext> =>\n        g && (isIterator(g) || isIterable(g));\n\n\nexport const isAsyncGenable = <T, TReturn, TNext>(g: AsyncIterator<T, TReturn, TNext>|AsyncIterable<T>|AsyncGenerator<T,TReturn,TNext>|any):\n    g is Genable<T, Async, TReturn, TNext> =>\n        g && (isAsyncIterator<T, TReturn, TNext>(g) || isAsyncIterable<T, TReturn, TNext>(g) || isIterable<T, TReturn, TNext>(g));\n\n/**\n * Predicate/type guard to determine if an object is (or looks like, structurally) a Generator.\n * @param g\n */\nexport const isGenerator = <T, TReturn, TNext>(g: Genable<T, Sync, TReturn, TNext>|any): g is Generator<T, TReturn, TNext> =>\n    g &&\n    isFunction(g.next)\n    && isFunction(g.return)\n    && isFunction(g.throw)\n    && isFunction(g[Symbol.iterator]);\n\n/**\n * Predicate/type guard to determine if an object is (or looks like, structurally) a AsyncGenerator.\n * @param g\n */\nexport const isAsyncGenerator = <T, TReturn, TNext>(g: Genable<T, Async, TReturn, TNext>|any): g is AsyncGenerator<T> =>\n    g &&\n    isFunction(g.next)\n    && isFunction(g.return)\n    && isFunction(g.throw)\n    && isFunction(g[Symbol.asyncIterator]);\n\n/**\n * Coerce an object to an object that can act as a generator (that is, satisfy both `Iterator`\n * and `Iterable`).\n *\n * If it is an `Iterator` but not `Iterable`, or `Iterable` but not `Iterator`, it is wrapped\n * in a generator. This generator is __not__ enhanced. Use [[Sync.enhance]] on the result if\n * you need an enhanced generator.\n * @param i\n */\nexport function toGenerator<T, TReturn = T, TNext = T>(i: Genable<T, Sync, TReturn, TNext>): Generator<T, TReturn, TNext> {\n    if (isGenerator(i)) return i;\n    if (isIterator(i)) {\n        const it = i;\n\n        function* wrap() {\n            while (true) {\n                const r = it.next();\n                if (r.done) return r.value;\n                yield r.value;\n            }\n        }\n\n        return wrap();\n    } else if (isIterable(i)) {\n        return toGenerator(i[Symbol.iterator]() as Iterator<T, TReturn, TNext>);\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\n\n/**\n * Coerce an object to an object that can act as a async generator (that is, satisfy both `Iterator`\n * and `Iterable`).\n *\n * If it is an `AsyncIterator` but not `AsyncIterable`, or `AsyncIterable` but not `AsyncIterator`,\n * it is wrapped in an async generator. This generator is __not__ enhanced. Use [[Async.enhance]] on the result if\n * you need an enhanced generator.\n * @param i\n */\nexport function toAsyncGenerator<T, TReturn, TNext>(i: Genable<T, Async, TReturn, TNext>|Genable<T, Sync, TReturn, TNext>):\n    AsyncGenerator<T, TReturn, TNext>\n{\n    if (isAsyncGenerator(i)) return i;\n    if (isAsyncIterator(i)) {\n        const it = i;\n        async function* wrap() {\n            while (true) {\n                const r = await it.next();\n                if (r.done) return r.value;\n                yield r.value;\n            }\n        }\n        return wrap();\n    } else if (isAsyncIterable(i)) {\n        return toAsyncGenerator(i[Symbol.asyncIterator]()) as AsyncGenerator<T, TReturn, TNext>;\n    } else if (isIterable(i)) {\n        return toAsyncGenerator(i[Symbol.iterator]() as Iterator<T, TReturn, TNext>);\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\n/**\n * Coerce a sync [[Genable]] object to an `Iterator`. If the object is a `Generator` or an `Iterator` it is returned,\n * while if it is an `Iterable`, `[Symbol.iterator]`() is invoked.\n * @param i\n */\nexport function toIterator<T, TReturn, TNext>(i: Genable<T, Sync, TReturn, TNext>): Iterator<T, TReturn, TNext> {\n    if (isGenerator(i)) return i;\n    if (isIterator(i)) return i;\n    if (isIterable(i)) {\n        return i[Symbol.iterator]() as Iterator<T, TReturn, TNext>;\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\n\n/**\n * Coerce an async [[Genable]] object to an `AsyncIterator`. If the object is a `Generator` or an `Iterator` it is returned,\n * while if it is an `Iterable`, `[Symbol.iterator]`() is invoked.\n * @param i\n */\nexport function toAsyncIterator<T, TReturn, TNext = T>(i: Genable<T, Async, TReturn, TNext>): AsyncIterator<T, TReturn, TNext> {\n    if (isAsyncGenerator(i)) return i;\n    if (isAsyncIterable(i)) {\n        return i[Symbol.asyncIterator]() as AsyncIterator<T, TReturn, TNext>;\n    } else if (isIterable(i)) {\n        return asyncAdaptor(toIterator(i));\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\nconst asyncAdaptor = <T, TReturn, TNext>(i: Iterator<T, TReturn, TNext>):\n    AsyncGenerator<T, TReturn, TNext> =>\n{\n    const it = i as unknown as AsyncIterator<T>;\n    let self: AsyncGenerator<T> & {returning?: any};\n    async function* asyncAdaptor(): AsyncGenerator<T> {\n        let nr: any;\n        let done = false;\n        try {\n            while (true) {\n                const r = await Promise.resolve(it.next());\n                if (r.done) {\n                    done = true;\n                    return r.value;\n                }\n                try {\n                    nr = yield r.value;\n                } catch (e) {\n                    await it.throw?.(e);\n                    throw(e);\n                }\n            }\n        } finally {\n            if (!done) {\n                await i.return?.(self.returning);\n            }\n        }\n    }\n    return self = asyncAdaptor();\n};\n\n/**\n * Coerce a [[Genable]] object to `Iterable`. If it is already an `Iterable`, it is returned\n * unchanged. If it is an `Iterator`, it is wrapped in an object with a `[Symbol.iterator]`\n * method that returns the supplied iterator.\n * @param i\n */\nexport function toIterable<T, TReturn = T, TNext = T>(i: Genable<T,Sync,TReturn,TNext>):\n    FullIterable<T, Sync, TReturn, TNext>\n{\n    if (isIterable(i)) return i as FullIterable<T, Sync, TReturn, TNext>;\n    return {\n        [Symbol.iterator]: () => i\n    } as FullIterable<T, Sync, TReturn, TNext>;\n}\n\n\n/**\n * Coerce a [[Genable]] object to `AsyncIterable`. If it is already an `AsyncIterable`, it is returned\n * unchanged. If it is an `AsyncIterator`, it is wrapped in an object with a `[Symbol.asyncIterator]`\n * method that returns the supplied iterator.\n * @param i\n */\nexport function toAsyncIterable<T, TReturn, TNext>(i: Genable<T, Async, TReturn, TNext>):\n    FullIterable<T, Async, TReturn, TNext>\n{\n    if (isAsyncIterable<T, TReturn, TNext>(i)) return i;\n    if (isIterable<T, TReturn, TNext>(i)) {\n        return toAsyncIterable_adaptor<T, TReturn, TNext>(i) as\n            FullIterable<T, Async, TReturn, TNext>;\n    }\n    return {\n        [Symbol.asyncIterator]: () => i\n    } as FullIterable<T, Async, TReturn, TNext>;\n}\nasync function* toAsyncIterable_adaptor<T, TReturn, TNext>(iterable: Iterable<T>):\n    AsyncGenerator<T, TReturn, TNext>\n{\n    const it = iterable[Symbol.iterator]();\n    let nr: any = undefined;\n    while (true) {\n        const r = await it.next(nr);\n        if (r.done) return r.value;\n        nr = yield r.value;\n    }\n}\n\n// noinspection JSUnusedGlobalSymbols\n/**\n * Similar to [[toGenerator]], but does not require the presence of `Generator.return` or `Generator.throw` methods.\n * @param i\n */\nexport function toIterableIterator<T, TReturn = T, TNext = T>(i: Genable<T, Sync, TReturn, TNext>): FullIterableIterator<T, Sync, TReturn, TNext> {\n    if (isIterable(i) && isIterator(i)) return i as FullIterableIterator<T, Sync, TReturn, TNext>;\n    if (isIterable(i)) {\n        // Invoke [Symbol.iterator]() just once, on first use.\n        let _it: Iterator<T>|undefined = undefined;\n        const it = () => _it ?? (_it = i[Symbol.iterator]());\n        const iit: FullIterableIterator<T, Sync, TReturn, TNext> = {\n            [Symbol.iterator]: () => iit,\n            next: (val?: TNext) => it().next(val as undefined),\n            return: it().return && ((val) => it().return!(val)),\n            throw: it().throw && ((val) => it().throw!(val))\n        };\n        return iit;\n    }\n    if (isIterator(i)) {\n        const iit: FullIterableIterator<T, Sync, TReturn, TNext> = {\n            [Symbol.iterator]: () => iit,\n            next: (val?: TNext) => i.next(val!),\n            return: i.return && ((val) => i.return!(val)),\n            throw: i.throw && ((val) => i.throw!(val))\n        }\n        return iit;\n    }\n    throw new Error(`Not iterator nor iterable: ${i}`);\n}\n\n\n/**\n * Similar to [[toAsyncGenerator]], but does not require the presence of `AsyncGenerator.return` or\n * `AsyncGenerator.throw` methods.\n * @param i\n */\nexport function toAsyncIterableIterator<T, TReturn, TNext>(i: Genable<T, Async, TReturn, TNext>):\n    FullIterableIterator<T, Async, TReturn, TNext>\n{\n    if (isAsyncIterable<T, TReturn, TNext>(i) && isAsyncIterator<T, TReturn, TNext>(i)) {\n        return i as unknown as FullIterableIterator<T, Async, TReturn, TNext>;\n    }\n    if (isAsyncIterable<T, TReturn, TNext>(i)) {\n        // Invoke [Symbol.iterator]() just once, on first use.\n        let _it: AsyncIterator<T, TReturn, TNext>|undefined = undefined;\n        const it = () => _it ?? (_it = i[Symbol.asyncIterator]() as AsyncIterator<T, TReturn, TNext>);\n        const iit: AsyncIterableIterator<T> = {\n            [Symbol.asyncIterator]: () => iit,\n            next: () => it().next(),\n            return: it().return && ((val) => it().return!(val)),\n            throw: it().throw && ((val) => it().throw!(val))\n        };\n        return iit;\n    }\n    if (isIterable<T, TReturn, TNext>(i)) {\n        return toAsyncIterable_adaptor(i);\n    }\n    if (isAsyncIterator(i)) {\n        const iit: AsyncIterableIterator<T> = {\n            [Symbol.asyncIterator]: () => iit,\n            next: (val: any) => i.next(val),\n            return: i.return && ((val) => i.return!(val)),\n            throw: i.throw && ((val) => i.throw!(val))\n        }\n        return iit;\n    }\n    throw new Error(`Not iterator nor iterable: ${i}`);\n}\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `Iterator` protocol (has a `next()` method).\n *\n * Note: There is no way to statically distinguish between an `Iterator` and an `AsyncIterator`. You will get\n * runtime errors if you don't anticipate the distinction.\n * @param i\n */\nexport const isIterator = <K, KReturn = K, KNext = K>(i: Iterable<K> | FullIterable<K, Sync, KReturn, KNext> | any):\n    i is Iterator<K, KReturn, KNext> =>\n        i && typeof i.next === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `AsyncIterator` protocol (has a `next()` method).\n *\n * Note: There is no way to statically distinguish between an `Iterator` and an `AsyncIterator`. You will get\n * runtime errors if you don't anticipate the distinction.\n * @param i\n */\nexport const isAsyncIterator = <K, KReturn = K, KNext = K>(i: AsyncIterable<K> | AsyncIterator<K, KReturn, KNext>| any):\n    i is AsyncIterator<K, KReturn, KNext> =>\n        i && typeof i.next === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `Iterable` protocol (has a `[Symbol.iterator]`\n * method).\n * @param i\n */\nexport const isIterable = <K, KReturn = K, KNext = K>(i: Iterable<K> | FullIterable<K, Sync, KReturn, KNext> | any): i is FullIterable<K, Sync, KReturn, KNext>  =>\n    i && typeof i[Symbol.iterator] === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `AsyncIterable` protocol (has a `[Symbol.asyncIterator]`\n * method).\n * @param i\n */\nexport const isAsyncIterable = <K, KReturn = K, KNext = K>(i: AsyncIterable<K> | FullIterable<K, Async, KReturn, KNext> | any):\n    i is FullIterable<K, Async, KReturn, KNext> =>\n        i && typeof i[Symbol.asyncIterator] === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `Iterable` protocol (has a `[Symbol.iterator]`\n * method) and the `Iterator` protocol (a next() method).\n * @param i\n */\nexport const isIterableIterator = <K, KReturn = K, KNext = K>(i: Iterable<K>|Iterator<K, KReturn, KNext>|any):\n    i is FullIterableIterator<K, Sync, KReturn, KNext> =>\n        isIterator(i) && isIterable(i);\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `AsyncIterable` protocol (has a `[Symbol.asyncIterator]`\n * method) and the `AsyncIterator` protocol (a next() method).\n * @param i\n */\nexport const isAsyncIterableIterator = <K, KReturn = K, KNext = K>(i: Iterable<K>|Iterator<K, KReturn, KNext>|any):\n    i is FullIterableIterator<K, Async, KReturn, KNext> =>\n        isAsyncIterator(i) && isAsyncIterable(i);\n\n/**\n * Wrap a function in a catch block.\n * @param f\n * @param onError Called when an error is thrown. The return value is returned. If not supplied, undefined is returned.\n */\nexport const doCatch = <A extends any[], R>(f: (...args: A) => R, onError?: (e: Error) => R):\n    ((...args: A) => (R | undefined)) => {\n    return (...args: A) => {\n        try {\n            return f(...args);\n        } catch (e) {\n            return onError?.(e);\n        }\n    };\n};\n","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * This provides the trampoline methods that are shared between synchronous and\n * asynchronous enhanced generators. Methods dispatch to {@link Sync} or {@link Async}\n * as appropriate.\n *\n * This becomes part of the prototype chain of enhanced generator instances. It does\n * __not__ modify any global prototypes.\n *\n * You should not need to reference this directly. In Typescript, if you need a\n * type that covers both sync and async enhanced generators, use {@link Enhanced} (for,\n * generators) or the {@link GeneratorOps} interface (for the functional interface).\n *\n * @packageDocumentation\n * @module enhancements\n * @preferred\n */\n\nimport {Async, Enhanced, FlatGen, Genable, GeneratorOps, IndexedFn, IndexedPredicate, Reducer, ReturnValue, SyncType, UnwrapArray} from \"./types\";\n\n/**\n * Enhancements for generators\n */\n\nexport type {Enhanced} from './types';\n\n/**\n * The trampoline methods that link enhanced generators to [[Sync]] or [[Async]]\n * methods.\n */\nexport abstract class Enhancements<\n        T, TReturn, TNext, S extends SyncType\n        >\n{\n    abstract _impl: GeneratorOps<S>;\n\n    // Set on a call to return().\n    returning?: any;\n\n    abstract next(...arg: [] | [arg: TNext]):\n        S extends Async\n            ? Promise<IteratorResult<T, TReturn>>\n            : IteratorResult<T, TReturn>;\n\n    abstract return(value: TReturn):\n        S extends Async\n            ? Promise<IteratorReturnResult<TReturn>>\n            : IteratorReturnResult<TReturn>;\n\n    abstract throw(e: any):\n        S extends Async\n            ? Promise<IteratorReturnResult<TReturn>>\n            : IteratorReturnResult<TReturn>;;\n\n    abstract [Symbol.iterator]:\n        S extends Async\n            ? undefined\n            : () => this & IterableIterator<T>;\n\n    abstract [Symbol.asyncIterator]:\n        S extends Async\n            ? () => this & AsyncIterableIterator<T>\n            : undefined;\n\n    [Symbol.toStringTag]:\n        S extends Async\n            ? 'EnhancedAsyncGenerator'\n            : 'EnhancedGenerator';\n\n    /**\n     * Return all of the values from this generator as an array. You do not want to call this on an\n     * infinite generator (for obvious reasons); consider using [[EnhancedGenerator.slice]] or\n     * [[EnhancedGenerator.limit]] to limit the size before calling this.\n     */\n    asArray(): ReturnValue<T[], S> {\n        return this._impl.asArray<T, TReturn, TNext>(this);\n    }\n\n    /**\n     * Limit the number of values that can be generated. A `RangeError` is thrown if this limit is\n     * exceeded. See [[EnhancedGenerator.slice]] if you want to truncate.\n     * @param max\n     */\n    limit(max: number): Enhanced<T, S, TReturn, TNext> {\n        return this._impl.limit(max, this);\n    }\n\n    /**\n     * Operate on each value produced by this generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @param thisArg Value to be supplied as context `this` for function _f_.\n     */\n    forEach(f: IndexedFn<T, void, S>, thisArg?: any): void {\n        this._impl.forEach<T, TReturn, TNext>(f, thisArg, this);\n    }\n\n    /**\n     * Apply the function to each value yielded by this generator. It is called with two arguments,\n     * the value yielded, and a sequential index. The return value is a generator that yields the\n     * values produced by the function.\n     * @param f\n     * @param thisArg Optional value to be supplied as context `this` for function _f_.\n     */\n    map<V>(f: IndexedFn<T, V, S>, thisArg?: any): Enhanced<V, S, TReturn, TNext> {\n        return this._impl.map(f, thisArg, this);\n    }\n\n\n    /**\n     * Return a new [[EnhancedGenerator]] that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     */\n    filter(f: IndexedPredicate<T, S>, thisArg?: any): Enhanced<T, S, TReturn, TNext> {\n        return this._impl.filter(f, thisArg, this);\n    }\n\n    /**\n     * Flatten the values yielded by this generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param depth (default = 1)\n     */\n    flat<D extends number>(depth: D = 1 as D): Enhanced<S, FlatGen<T, D>, TReturn, TNext> {\n        return this._impl.flat<D, T, TReturn, TNext>(depth, this);\n    }\n\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a generator that yields the individual values at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param depth\n     */\n    flatMap<D extends number = 1>(f: IndexedFn<T, FlatGen<T, D>, S>, depth: D = 1 as D):\n        Enhanced<S, FlatGen<T, D>, TReturn, TNext>\n    {\n        return this._impl.flatMap<D, T, FlatGen<T, D>, TReturn, TNext>(f, depth, this);\n    }\n\n    /**\n     * Return a new [[EnhancedGenerator]] that only yields the indicated values, skipping _start_ initial values\n     * and continuing until the _end_.\n     * @param start\n     * @param end\n     */\n    slice(start: number = 0, end: number = Number.POSITIVE_INFINITY): Enhanced<T, S, TReturn | undefined, TNext> {\n        return this._impl.slice(start, end, this);\n    }\n\n    /**\n     * Concatenates generators (or iterators or iterables).\n     *\n     * Ensures that any supplied generators are terminated when this is terminated.\n     * @param gens zero or more additional [[Genable]] to provide values.\n     */\n\n    concat<T, TReturn, TNext>(...gens: Array<Genable<T, S, TReturn, TNext>>):\n        Enhanced<T, S, TReturn | void, TNext>\n    {\n        const self = this as UnwrapArray<typeof gens>;\n        return this._impl.concat(self, ...gens);\n    }\n\n\n    /**\n     * Like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\") is omitted\n     * because there is no array.\n     * @param f\n     */\n    reduce<A, T, TReturn, TNext>(f: Reducer<A, T, T, S>): ReturnValue<A, S>;\n    /**\n     * Like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\") is omitted\n     * because there is no array.\n     * @param f\n     * @param init\n     */\n    reduce<A, T, TReturn = T, TNext = T>(f: Reducer<A, T, A, S>, init: A): ReturnValue<A, S>;\n    reduce<A>(f: Reducer<A, T, A, S>, init?: A): ReturnValue<A, S> {\n        return this._impl.reduce<A, T, TReturn, TNext>(f, init as A, this);\n    }\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    some<T>(p: IndexedPredicate<T, S>, thisArg?: any): ReturnValue<boolean, S> {\n        // Why is type typecast to Genable needed here?\n        // Yet the seemingly identical case of 'every' below does not?\n        return this._impl.some(p, thisArg, this as Genable<T, S, TReturn, TNext>);\n    }\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    every(p: IndexedPredicate<T, S>, thisArg?: any): ReturnValue<boolean, S> {\n        return this._impl.every(p, thisArg, this as Genable<T, S, TReturn, TNext>);\n    }\n\n\n    /**\n     * Returns a new generator that repeats the last value returned by this (or `undefined` if this\n     * did not return any values).\n     *\n     * @param max\n     */\n    repeatLast(max: number = Number.POSITIVE_INFINITY): Enhanced<T, S, TReturn | void, TNext> {\n        return this._impl.repeatLast(this, max);\n    }\n\n\n    /**\n     * Returns a new generator that repeats the supplied value after this generator\n     * completes.\n     *\n     * @param value the value to repeat\n     * @param repetitions The number repetitions; the default is infinite.\n     */\n\n    repeat<N>(value: N, repetitions: number = Number.POSITIVE_INFINITY): Enhanced<T | N, S, void, TNext> {\n        const tail = this._impl.repeat<T|N, void, TNext>(value, repetitions);\n        const result = this._impl.concat(\n            this as Genable<T|N, S, undefined, TNext>,\n            tail as Genable<T|N, S, undefined, TNext>\n        );\n        return result as Enhanced<T | N, S, undefined, TNext>;\n    }\n\n    /**\n     * Combines this generator with additional ones, returning a generator that produces a tuple with\n     * each of their results, with this generator's result first.\n     *\n     * Terminates when any generator terminates. To get other behaviors, use with [[EnhancedGenerator.repeat]] or\n     * [[EnhancedGenerator.repeatLast]].\n     * @param gens\n     */\n\n    zip<G extends (Genable<T, S, TReturn, TNext>)[], T, TReturn, TNext>(...gens: G):\n        Enhanced<Array<T>, S, TReturn, TNext>\n    {\n        return this._impl.zip(this as Genable<T, S, TReturn, TNext>, ...gens) as\n            Enhanced<Array<T>, S, TReturn, TNext>;\n    }\n\n    /**\n     * Trivial, but handy, same as **Array.prototype.join**.\n     * @param sep (default = ',').\n     *\n     * See also [[EnhancedGenerator.join]]\n     */\n    join(sep?: string): ReturnValue<string, S> {\n        return this._impl.join(this, sep);\n    }\n\n    /**\n     * Sorts the supplied values and returns a sorted array.\n     * @param cmp a comparison function\n     */\n    sort(cmp?: (a: T, b: T) => number): ReturnValue<T[], S> {\n        return this._impl.sort(cmp)(this as Genable<T, S, TReturn, TNext>);\n    }\n}\n","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * This entry point loads synchronous extended generators\n * @packageDocumentation\n * @module sync\n * @preferred\n */\n\nimport type {Enhanced, FlatGen, Genable, GeneratorOps, GenOp, GenOpValue, GenVoid, IndexedFn, IndexedPredicate, Reducer, ReturnValue, UnwrapArray} from \"./types\";\n// Should be 'import type' but that makes TS insist it can't be a value here even after defining it.\nimport {Sync} from './types';\nimport {doCatch, isGenable, isGenerator, isIterable, isIterator, toGenerator, toIterable, toIterator} from \"./functions\";\nimport {Enhancements} from \"./enhancements\";\n\n/**\n * An extension to generators, that provides for operations like:\n * * map<T, R>(gen: Generator<T>) => (fn: T => R) => Generator<R>\n * * EnhancedGenerator<T>.map<R>(fn: T => R) => Generator<R>\n * @packageDocumentation\n * @module Generators\n * @preferred\n */\n\nclass Sync_ implements GeneratorOps<Sync> {\n    /**\n     * Return a generator that yields the supplied values.\n     * @param values\n     */\n    of<T extends any[], TReturn, TNext>(...values: T):\n        Enhanced<UnwrapArray<T>, Sync, TReturn, TNext>\n    {\n        return this.enhance(values);\n    }\n    /**\n     * Return all of the values from this generator as an array. You do not want to call this on an\n     * infinite generator (for obvious reasons); consider using [[EnhancedGenerator.slice]] or\n     * [[EnhancedGenerator.limit]] to limit the size before calling this.\n     */\n    asArray<T, TReturn, TNext>(gen: Genable<T, Sync, TReturn, TNext>):\n        T[]\n    {\n        return [...toIterable<T, TReturn, TNext>(gen)];\n    };\n\n    limit<T, TReturn, TNext>(max: number, gen: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<T, Sync, TReturn, TNext>;\n    limit(max: number): GenOp<Sync>;\n\n    limit<T, TReturn, TNext>(max: number, gen?: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<T, Sync, TReturn, TNext>\n        | GenOp<Sync>\n    {\n        let self: EnhancedGenerator<T, TReturn, TNext>;\n        function *limit<X, XReturn, XNext>(gen: Iterator<X, XReturn, XNext>): Generator<X, XReturn, XNext> {\n            let nr: XNext;\n            let limited: boolean = false;\n            try {\n                for (let i = 0; i < max; i++) {\n                    const r = gen.next(nr!);\n                    if (r.done) {\n                        return r.value;\n                    }\n                    try {\n                        nr = yield r.value;\n                    } catch (e) {\n                        gen.throw?.(e);\n                    }\n                }\n                limited = true;\n                const err = new RangeError(`Generator produced excessive values > ${max}.`);\n                gen.throw?.(err);\n                throw err;\n            } finally {\n                if (!limited) {\n                    gen.return?.(self?.returning);\n                    // Even if the supplied generator refuses to terminate, we terminate.\n                }\n            }\n        }\n        if (gen) {\n            return self = this.enhance(limit(toIterator(gen)));\n        }\n        return <X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) =>\n            this.enhance(limit(toIterator(gen)));\n    }\n\n    forEach<T, TReturn, TNext>(f: IndexedFn<T, void, Sync>, thisArg: any, gen: Genable<T, Sync, TReturn, TNext>):\n        GenVoid<Sync>;\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @param gen the generator.\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T, TReturn, TNext>(f: IndexedFn<T, void, Sync>, gen: Genable<T, Sync, TReturn, TNext>):\n        GenVoid<Sync>;\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @param thisArg Optional value to be supplied as context `this` for function _f_.\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T>(f: IndexedFn<T, void, Sync>, thisArg?: any):\n        <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>) =>\n            GenVoid<Sync>;\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T>(f: IndexedFn<T, void, Sync>):\n        <TReturn, TNext>(gen: Genable<T, Sync, TReturn, TNext>, thisArg?: any) =>\n            GenVoid<Sync>;\n\n    forEach<T, TReturn, TNext>(\n            f: IndexedFn<T, void, Sync>,\n            thisArgOrGen?: Genable<T, Sync, TReturn, TNext>|any,\n            gen?: Genable<T, Sync, TReturn, TNext>\n        )\n    {\n        const forEach = <XReturn, XNext>(f: IndexedFn<T, void, Sync>, thisArg: any, gen: Genable<T, Sync, XReturn, XNext>):\n                GenVoid<Sync> =>\n            {\n                const it = toIterator(gen);\n                let idx = 0;\n                while (true) {\n                    const r = it.next();\n                    if (r.done) return;\n                    f.call(thisArg, r.value, idx++);\n                }\n            };\n        if (gen) return forEach(f, thisArgOrGen, gen);\n        if (isGenable<T>(thisArgOrGen)) return forEach(f, undefined, thisArgOrGen);\n        return <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, thisArg?: any) =>\n            forEach<XReturn, XNext>(f, thisArg ?? thisArgOrGen, gen);\n    }\n\n    map<T, V>(f: IndexedFn<T, V, Sync>):\n        GenOpValue<Sync, T, V>;\n    map<T, V>(f: IndexedFn<T, V, Sync>, thisArg?: any):\n        GenOpValue<Sync, T, V>;\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Sync>, gen: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<V, Sync, TReturn, TNext>;\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Sync>, thisArg: any, gen: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<V, Sync, TReturn, TNext>;\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Sync>, thisArg?: any | Genable<T, Sync, TReturn, TNext>, iter?: Genable<T, Sync, TReturn, TNext>):\n        EnhancedGenerator<V, TReturn, TNext>\n        | (<XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>) => EnhancedGenerator<V, XReturn, XNext>)\n        | (<XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, thisArg?: any) => EnhancedGenerator<V, XReturn, XNext>)\n    {\n        const map = <XReturn, XNext>(thisArg: any, iter: Genable<T, Sync, XReturn, XNext>) => {\n            const gen = toGenerator(iter);\n            let self: EnhancedGenerator<V, XReturn, XNext>;\n            function* map(): Generator<V, XReturn, XNext> {\n                let nr: XNext;\n                let idx = 0;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = gen.next(nr!);\n                                if (r.done) return r.value;\n                                const v: V = f.call(thisArg, r.value, idx++);\n                                try {\n                                    nr = yield v;\n                                } catch (e) {\n                                    gen.throw(e);\n                                }\n                            }\n                        } finally {\n                            const x = gen.return(self?.returning);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (!x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            return self = this.enhance(map());\n        };\n        if (iter) return map(thisArg, iter);\n        if (isGenable<T, TReturn, TNext>(thisArg)) return map(undefined, thisArg);\n        return <XReturn, XNext>(gen: Genable<T, Sync,XReturn, XNext>, genThisArg?: any) =>\n            map(genThisArg ?? thisArg, gen);\n    }\n\n    /**\n     * Return a function that filters a [[Genable]] and yields a new [[EnhancedGenerator]]\n     * that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @typeParam T the type of value.\n     */\n    filter<T>(f: IndexedPredicate<T, Sync>):\n        GenOpValue<Sync, T, T>;\n\n    /**\n     * Return a function that filters a [[Genable]] and yields a new [[EnhancedGenerator]]\n     * that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     * @typeParam T the type of value.\n     */\n    filter<T>(f: IndexedPredicate<T, Sync>, thisArg: any):\n        GenOpValue<Sync, T, T>;\n\n    /**\n     * Return a new [[EnhancedGenerator]] that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param iter a [[Genable|Genable<T>]]\n     * @typeParam T the type of value.\n     */\n    filter<T, TReturn, TNext>(f: IndexedPredicate<T, Sync>, iter: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<T, Sync, TReturn, TNext>;\n    /**\n     * Return a new [[EnhancedGenerator]] that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     * @param iter a [[Genable|Genable<T>]]\n     * @typeParam T the type of value.\n     */\n    filter<T, TReturn, TNext>(f: IndexedPredicate<T, Sync>, thisArg: any, iter: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<T, Sync, TReturn, TNext>;\n\n    /**\n     * Return a function that filters a [[Genable]] and yields a new [[EnhancedGenerator]]\n     * that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     * @param iter the [[Genable]] to filter.\n     * @typeParam T the type of value.\n     */\n    filter<T, TReturn, TNext>(\n        f: IndexedPredicate<T, Sync>,\n        thisArg?: any | Genable<T, Sync, TReturn, TNext>,\n        iter?: Genable<T, Sync, TReturn, TNext>\n    ):\n        Enhanced<T, Sync, TReturn, TNext>\n        | GenOpValue<Sync, T, T>\n    {\n        const filter = <XReturn, XNext>(thisArg: any, iter: Genable<T, Sync, XReturn, XNext>) => {\n            const gen = toGenerator(iter);\n            let self: EnhancedGenerator<T, TReturn, TNext>;\n            function* filter<V>(f: IndexedPredicate<T, Sync>): Generator<T> {\n                let nr: any = undefined;\n                let idx = 0;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = gen.next(nr);\n                                if (r.done) return r.value;\n                                if (f.call(thisArg, r.value, idx++)) {\n                                    try {\n                                        nr = yield r.value;\n                                    } catch (e) {\n                                        gen.throw(e);\n                                    }\n                                }\n                            }\n                        } finally {\n                            const x = gen.return?.(self?.returning);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (!x?.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            return self = this.enhance(filter(f));\n        };\n\n        if (iter) return filter(thisArg, iter);\n        if (isGenable<T>(thisArg)) return filter(undefined, thisArg);\n        return <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, genThisArg?: any) =>\n            filter(genThisArg ?? thisArg, gen);\n    }\n\n    /**\n     * Flatten the values yielded by the generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param depth\n     */\n    flat<D extends number>(depth: D):\n        <X, XReturn = X, XNext = X>(gen: Genable<X, Sync, XReturn, XNext>) =>\n            Enhanced<Sync, FlatGen<X, D>, XReturn, XNext>;\n    /**\n     * Flatten the values yielded by the generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param depth\n     * @param gen\n     */\n    flat<D extends number, T, TReturn, TNext>(depth: D, gen: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<Sync, FlatGen<T, D>, TReturn, TNext>;\n    /**\n     * Flatten the values yielded by the generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param gen\n     * @param depth default = 1\n     */\n    flat<D extends number, T, TReturn, TNext>(gen: Genable<T, Sync, TReturn, TNext>, depth?: D):\n        Enhanced<Sync, FlatGen<T, D>, TReturn, TNext>;\n\n    flat<D extends number, T, TReturn, TNext>(\n        depth: D|Genable<T, Sync, TReturn, TNext>,\n        gen?: Genable<T, Sync, TReturn, TNext> | D\n    ):\n        Enhanced<Sync, FlatGen<T, D>, TReturn, TNext>\n        | (<X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) => Enhanced<Sync, FlatGen<X, D>, XReturn, XNext>)\n    {\n        const flat = <X, XReturn, XNext>(depth: D, gen: Genable<X, Sync, XReturn, XNext>) => {\n            let self: EnhancedGenerator<FlatGen<X, D>, XReturn, XNext>;\n            const gens = new Set<Generator>();\n            if (isGenerator(gen)) gens.add(gen);\n\n            function* flat<D extends number>(it: Iterator<unknown, XReturn, XNext>, depth: D): Generator<FlatGen<X, D>, XReturn, XNext> {\n                let nr: any = undefined;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = it.next(nr);\n                                if (r.done) return r.value;\n                                const v = r.value;\n                                if (isGenerator(v)) {\n                                    gens.add(v);\n                                }\n                                try {\n                                    if (depth > 0 && isIterator<unknown, XReturn, XNext>(v)) {\n                                        yield* flat(v, depth - 1);\n                                    } else if (depth > 0 && isIterable(v)) {\n                                        yield* flat(toIterator<unknown, XReturn, XNext>(v), depth - 1)\n                                    } else {\n                                        nr = yield r.value as FlatGen<T, D>;\n                                    }\n                                } catch (e) {\n                                    it.throw?.(e);\n                                }\n                            }\n                        } finally {\n                            const x = it.return?.(self?.returning);\n                            if (isGenerator(it)) gens.delete(it);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (x && !x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                            for (const g of gens) {\n                                g.return(self?.returning);\n                            }\n                        }\n                    }\n                }\n            }\n\n            return self = this.enhance(flat(toIterator(gen), depth));\n        }\n        if (typeof depth === 'number') {\n            if (gen) {\n                if (isGenable(gen)) {\n                    return flat(depth, gen);\n                } else {\n                    throw new TypeError(`Invalid Genable: ${gen}`);\n                }\n            }\n            return <X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) =>\n                flat(depth, gen);\n        } else if (isGenable(depth)) {\n            return flat((gen ?? 1) as D, depth);\n        }\n        throw new TypeError(`Illegal arguments to flat()`);\n    }\n\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a function that accepts a generator, and returns another generator that yields the individual value\n     * at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param depth\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T>(f: IndexedFn<T, R, Sync>, depth: D):\n        <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>) =>\n            Enhanced<R, Sync, XReturn, XNext>;\n\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a function that accepts a generator, and returns another generator that yields the individual value\n     * at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T>(f: IndexedFn<T, R, Sync>):\n        <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, depth?: D) =>\n            Enhanced<R, Sync, XReturn, XNext>;\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a generator that yields the individual values at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param gen\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T, TReturn, TNext>(f: IndexedFn<T, R, Sync>, gen: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<R, Sync, TReturn, TNext>;\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a generator that yields the individual values at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param depth\n     * @param gen\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T, TReturn, TNext>(f: IndexedFn<T, R, Sync>, depth: D, gen: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<R, Sync, TReturn, TNext>;\n\n    flatMap<D extends number, R extends FlatGen<T, D>, T, TReturn, TNext>(\n            f: IndexedFn<T, R, Sync>,\n            depthOrGen?: D | Genable<T, Sync, TReturn, TNext>,\n            gen?: Genable<T, Sync, TReturn, TNext>\n        ):\n            Enhanced<R, Sync, TReturn, TNext>\n            | (\n                <X, Y extends FlatGen<T, D>, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) =>\n                Enhanced<Y, Sync, XReturn, XNext>\n            )\n            | (\n                <X, Y extends FlatGen<T, D>, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>, depth?: D) =>\n                    Enhanced<Y, Sync, XReturn, XNext>\n            )\n    {\n        const flatMap = <X, XReturn, XNext>(depth: D, gen: Genable<X, Sync, XReturn, XNext>) => {\n            let self: Enhanced<FlatGen<X, D>, Sync, XReturn, XNext>;\n            let idx = 0;\n\n            function* flatMap<D extends number, Y, YReturn, YNext>(it: Iterator<Y, YReturn, YNext>, depth: D):\n                Generator<FlatGen<X, D>, XReturn, XNext>\n            {\n                let nr: YNext;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = it.next(nr!);\n                                if (r.done) return r.value as unknown as XReturn;\n                                const v = f(r.value as unknown as T, idx++);\n                                try {\n                                    if (isIterator<unknown, XReturn, XNext>(v)) {\n                                        if (depth > 1) {\n                                            yield* flatMap(v, depth - 1);\n                                        } else if (depth === 1) {\n                                            yield* toGenerator(v);\n                                        } else {\n                                            yield v;\n                                        }\n                                    } else if (isIterable(v)) {\n                                        if (depth > 1) {\n                                            yield* flatMap(toIterator<unknown, XReturn, XNext>(v), depth - 1);\n                                        } else if (depth === 1) {\n                                            yield* toGenerator(v);\n                                        } else {\n                                            yield v;\n                                        }\n                                    } else {\n                                        nr = (yield v) as unknown as YNext;\n                                    }\n                                } catch (e) {\n                                    it.throw?.(e);\n                                }\n                            }\n                        } finally {\n                            const x = it.return?.(self?.returning);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (x && !x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            return self = this.enhance(flatMap(toIterator(gen), depth));\n        }\n\n        if (isGenable(gen)) {\n            return flatMap(depthOrGen as D ?? 1 as D, gen);\n        } else if (isGenable( depthOrGen)) {\n            return flatMap(1 as D, depthOrGen);\n        }\n        return <X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>, depth?: D) =>\n            flatMap(depthOrGen ?? depth ?? 1 as D, gen);\n    }\n\n    /**\n     * Return a new [[EnhancedGenerator]] that only yields the indicated values, skipping _start_ initial values\n     * and continuing until the _end_.\n     * @param start\n     * @param end\n     */\n    slice<T>(start: number, end: number):\n        <X, XReturn, XNext>(iter: Genable<X, Sync, XReturn, XNext>) =>\n            Enhanced<X, Sync, XReturn | undefined, XNext>;\n\n    /**\n     * Return a new [[EnhancedGenerator]] that only yields the indicated values, skipping _start_ initial values\n     * and continuing until the _end_.\n     * @param start\n     * @param end\n     * @param iter\n     */\n    slice<T, TReturn, TNext>(start: number, end: number, iter: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<T, Sync, TReturn | undefined, TNext>;\n\n    slice<T, TReturn, TNext>(start: number, end: number, iter?: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<T, Sync, TReturn | undefined, TNext>\n        | (\n            <X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) =>\n                Enhanced<X, Sync, XReturn | undefined, XNext>\n        )\n    {\n        const slice = <X, XReturn, XNext>(iter: Genable<X, Sync, XReturn, XNext>):\n                Enhanced<X, Sync, XReturn | undefined, XNext> =>\n            {\n                const it = toIterator(iter);\n                function* slice(start: number, end: number) {\n                    for (let i = 0; i < start; i++) {\n                        const r = it.next();\n                        if (r.done) return r.value;\n                    }\n                    if (end === Number.POSITIVE_INFINITY) {\n                        yield* toIterable(it);\n                    } else {\n                        let nv: XNext;\n                        while (true) {\n                            try {\n                                for (let i = start; i < end; i++) {\n                                    const r = it.next(nv!);\n                                    if (r.done) return r.value;\n                                    try {\n                                        nv = yield r.value;\n                                    } catch (e) {\n                                        const re = it.throw?.(e);\n                                        if (re) {\n                                            if (re.done) return re.value;\n                                            nv = yield re.value;\n                                        }\n                                    }\n                                }\n                            } finally {\n                                const x = it.return?.();\n                                // If the wrapped generator aborted the return, we will, too.\n                                if (x && !x.done) {\n                                    // noinspection ContinueOrBreakFromFinallyBlockJS\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    return;\n                }\n                return this.enhance(slice(start, end));\n        };\n        if (!iter) return slice;\n        return slice(iter);\n    }\n\n    /**\n     * Concatenates generators (or iterators or iterables).\n     *\n     * Ensures that any supplied generators are terminated when this is terminated.\n     * @param gens zero or more additional [[Genable]] to provide values.\n     */\n    concat<\n        T, TReturn, TNext,\n        A extends Array<Genable<T, Sync, TReturn, TNext>>\n    >(...gens: A):\n        Enhanced<T, Sync, TReturn | void, TNext>\n    {\n        let self: Enhanced<T, Sync, TReturn | void, TNext>;\n        function* concat(): Generator<T, TReturn | void, TNext> {\n            let i = 0;\n            try {\n                for (; i < gens.length; i++) {\n                    yield* toIterable<T,TReturn, TNext>(gens[i]);\n                }\n            } finally {\n                // Terminate any remaining generators.\n                for (; i < gens.length; i++) {\n                    const g = gens[i];\n                    if (isGenerator(g)) {\n                        g.return(self?.returning);\n                    }\n                }\n            }\n        }\n        return self = this.enhance(concat()) ;\n    }\n\n    /**\n     * Reduces **gen** like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     * @param f\n     * @param gen\n     */\n    reduce<A, T, TReturn, TNext>(f: Reducer<A, T, T, Sync>, gen: Genable<T, Sync, TReturn, TNext>):\n        A;\n    /**\n     *\n     * Returns a reducer function that, when applied to a `Generator` **gen**, reduces **gen** like\n     * **Array.prototype.reduce**. The 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     *\n     * @param f\n     */\n    reduce<A, T, TReturn, TNext>(f: Reducer<A, T, T, Sync>):\n        (gen: Genable<T, Sync, TReturn, TNext>) =>\n            A;\n    /**\n     *\n     * Returns a reducer function that, when applied to a `Generator` **gen**, reduces **gen** like\n     * `Array.prototype.reduce`. The 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     *\n     * @param f\n     */\n    reduce<A, T>(f: Reducer<A, T, A, Sync>):\n        <TReturn, TNext>(init: A, gen: Genable<T, Sync, TReturn, TNext>) =>\n            A;\n\n    /**\n     * Reduces **gen** like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     * @param f\n     * @param init\n     * @param gen\n     */\n    reduce<A, T, TReturn, TNext>(f: Reducer<A, T, A, Sync>, init: A, gen: Genable<T, Sync, TReturn, TNext>):\n        A;\n\n    /**\n     * Returns a reducer function that, when applied to a `Generator` **gen**, reduces **gen** like\n     * `Array.prototype.reduce`. The 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     *\n     * Alternatively, the init value can be supplied along with the generator as a second argument.\n     * @param f\n     * @param init\n     */\n    reduce<A, T>(f: Reducer<A, T, A, Sync>, init: A):\n        <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>) =>\n            A;\n\n    reduce<A, T, TReturn, TNext>(\n        f: Reducer<A, T, A | T, Sync>,\n        initOrGen?: A | Genable<T, Sync, TReturn, TNext>,\n        gen?: Genable<T, Sync, TReturn, TNext>\n    ): A\n        | (<XHome, XNext>(gen: Genable<T, Sync, XHome, XNext>) => A)\n        | ((f: (acc: A, v: T) => A, init: A) => A)\n        | ((f: (acc: A | T, v: T) => A) => A)\n    {\n\n        const reduce = (init: A | undefined, it: Iterator<T,unknown,unknown>): A => {\n            let acc: A | T | undefined = init;\n            if (acc === undefined) {\n                const r = it.next();\n                if (r.done) throw new TypeError(`No initial value in reduce`);\n                acc = r.value;\n            }\n            while (true) {\n                const r = it.next();\n                if (r.done) return acc as A;\n                acc = f(acc, r.value);\n            }\n        };\n        if (isGenable(gen)) {\n            return reduce(initOrGen as A, toIterator(gen));\n        } else if (isGenable(initOrGen)) {\n            return reduce(undefined, toIterator(initOrGen));\n        }\n        return <XHome, XNext>(gen: Genable<T, Sync, XHome, XNext>, init?: A) =>\n            reduce(init ?? initOrGen, toIterator(gen));\n    }\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    some<T>(p: IndexedPredicate<T, Sync>, thisArg?: any):\n        <XHome, XNext>(gen: Genable<T, Sync, XHome, XNext>) =>\n            ReturnValue<boolean, Sync>;\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     */\n    some<T>(p: IndexedPredicate<T, Sync>):\n        <XHome, XNext>(gen: Genable<T, Sync, XHome, XNext>, thisArg?: any) =>\n            ReturnValue<boolean, Sync>;\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param gen the generator\n     */\n    some<T, TReturn, TNext>(p: IndexedPredicate<T, Sync>, gen: Genable<T, Sync, TReturn, TNext>):\n        ReturnValue<boolean, Sync>;\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     * @param gen the generator\n     */\n    some<T, TReturn, TNext>(p: IndexedPredicate<T, Sync>, thisArg: any, gen: Genable<T, Sync, TReturn, TNext>):\n        ReturnValue<boolean, Sync>;\n\n    some<T, TReturn, TNext>(\n        pred: IndexedPredicate<T, Sync>,\n        thisOrGen?: any | Genable<T, Sync, TReturn, TNext>,\n        gen?: Genable<T, Sync, TReturn, TNext>\n    ):\n        ReturnValue<boolean, Sync>\n        | (<XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, thisArg?: any) =>\n            ReturnValue<boolean, Sync>)\n    {\n        const some = <XReturn, XNext>(thisArg: any, it: Iterator<T, XReturn, XNext>): boolean => {\n            let i = 0;\n            while (true) {\n                const r = it.next();\n                if (r.done) return false;\n                if (pred.call(thisArg, r.value, i++)) return true;\n            }\n        };\n        if (isGenable(gen)) {\n            return some(thisOrGen, toIterator(gen));\n        } else if (isGenable<T, TReturn, TNext>(thisOrGen)) {\n            return some(undefined, toIterator(thisOrGen));\n        } else {\n            return <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, thisArg?: any) =>\n                some<XReturn, XNext>(thisArg ?? thisOrGen, toIterator(gen));\n        }\n    }\n\n    /**\n     * Returns `false` and terminates the generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    every<T>(p: IndexedPredicate<T, Sync>, thisArg?: any):\n        <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>) =>\n            ReturnValue<boolean, Sync>;\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     */\n    every<T>(p: IndexedPredicate<T, Sync>):\n        <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext >, thisArg?: any) =>\n            ReturnValue<boolean, Sync>;\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param gen the generator\n     */\n    every<T, TReturn, TNext>(p: IndexedPredicate<T, Sync>, gen: Genable<T, Sync, TReturn, TNext>):\n        ReturnValue<boolean, Sync>;\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     * @param gen the generator\n     */\n    every<T, TReturn, TNext>(p: IndexedPredicate<T, Sync>, thisArg: any, gen: Genable<T, Sync, TReturn, TNext>):\n        ReturnValue<boolean, Sync>;\n\n    every<T, TReturn, TNext>(\n        pred: IndexedPredicate<T, Sync>,\n        genOrThis?: any | Genable<T, Sync, TReturn, TNext>,\n        gen?: Genable<T, Sync, TReturn, TNext>\n    ):\n        ReturnValue<boolean, Sync>\n        | (\n            <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>) =>\n                ReturnValue<boolean, Sync>\n        )\n    {\n        const every = <XReturn, XNext>(thisArg: any, it: Iterator<T, XReturn, XNext>): boolean => {\n            let i = 0;\n            while (true) {\n                const r = it.next();\n                if (r.done) return true;\n                if (!pred.call(thisArg, r.value, i++)) return false;\n            }\n        };\n        if (isGenable(gen)) {\n            return every(genOrThis, toIterator(gen));\n        } else if (isGenable(gen)) {\n            return <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, thisArg?: any) =>\n                every(thisArg ?? genOrThis, toIterator(gen));\n        }\n        throw new Error(`Invalid argument to every: ${gen ?? genOrThis}`);\n    }\n\n    /**\n     * Returns a new generator that repeats the last value returned by **gen** (or `undefined` if **gen**\n     * did not return any values).\n     *\n     * @param gen\n     * @param max\n     */\n    repeatLast<T, TReturn, TNext>(\n        gen: Genable<T, Sync, TReturn, TNext>,\n        max: number = Number.POSITIVE_INFINITY\n    ):\n        Enhanced<T, Sync, TReturn | void, TNext>\n    {\n        const it = toIterator(gen);\n        let nr: any;\n        let self: EnhancedGenerator<T, TReturn | void, TNext>;\n\n        function* repeatLast(): Generator<T, TReturn | void, TNext> {\n            try {\n                let last: T;\n                while (true) {\n                    const r = it.next(nr)\n                    if (r.done) break;\n                    try {\n                        nr = yield (last = r.value);\n                    } catch (e) {\n                        const re = it.throw?.(e);\n                        if (re) {\n                            if (re.done) break;\n                            yield last = re.value;\n                        }\n                    }\n                }\n                for (let i = 0; i < max; i++) {\n                    yield last!;\n                }\n            } finally {\n                it.return?.(self?.returning);\n            }\n        }\n\n        return self = this.enhance(repeatLast());\n    }\n\n    /**\n     * Returns a new generator that repeats the supplied value.\n     *\n     * @param value the value to repeat\n     * @param repetitions The number repetitions; the default is infinite.\n     */\n    repeat<T, TReturn, TNext>(value: T, repetitions: number = Number.POSITIVE_INFINITY):\n        Enhanced<T, Sync, TReturn | void, TNext>\n    {\n        function* repeat(): Generator<T, TReturn | void, TNext> {\n            for (let i = 0; i < repetitions; i++) {\n                yield value;\n            }\n        }\n\n        return this.enhance(repeat());\n    }\n\n    /**\n     * Combines generators, returning a generator that produces a tuple with each of their results.\n     *\n     * Terminates when the first generator terminates. To get other behaviors, use with [[EnhancedGenerator.repeat]] or\n     * [[EnhancedGenerator.repeatLast]].\n     * @param gens\n     */\n\n    zip<T, TReturn, TNext>(...gens: Array<Genable<T, Sync, TReturn, TNext>>):\n        Enhanced<Array<T>, Sync, TReturn, TNext>\n    {\n        if (gens.length === 0) return this.enhance([]);\n        const its = gens.map(toIterator);\n        let done = false;\n        let self: Enhanced<Array<T>, Sync, TReturn, TNext>;\n\n        function* zip2(): Generator<Array<T>, TReturn, TNext> {\n            try {\n                while (true) {\n                    let result: Array<T> = [];\n                    for (const g of its) {\n                        const r = g.next();\n                        if (r.done) {\n                            done = true;\n                            return r.value as TReturn;\n                        }\n                        (result as any[]).push(r.value);\n                    }\n                    try {\n                        yield result;\n                    } catch (e) {\n                        for (const g of gens) {\n                            try {\n                                // Weird need for a typecast here.\n                                (g as any).throw?.(e);\n                            } catch {\n                                // Ignore\n                            }\n                        }\n                        throw e;\n                    }\n                }\n            } finally {\n                if (!done) {\n                    for (const g of gens) {\n                        try {\n                            // Weird need for a typecast here.\n                            (g as any).return?.(self?.returning);\n                        } catch {\n                            // Ignore\n                        }\n                    }\n                }\n            }\n        }\n\n        return self = this.enhance(zip2());\n    }\n\n    /**\n     * Returns a function that joins the elements produced by a [[Genable]], analogous to `Array.prototype.join`.\n     * @param sep (default = ',')\n     */\n    join(sep: string):\n        <X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) =>\n            ReturnValue<string, Sync>;\n\n    /**\n     * Joins the elements produced by a [[Genable]], analogous to `Array.prototype.join`.\n     * @param gen\n     * @param sep\n     */\n    join<T, TReturn, TNext>(gen: Genable<T, Sync, TReturn, TNext>, sep?: string):\n        ReturnValue<string, Sync>;\n\n    join<T, TReturn, TNext>(\n        genOrSeparator: Genable<T, Sync, TReturn, TNext>|string,\n        sep?: string\n    ):\n        string\n        | (<X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) => string)\n    {\n        if (typeof genOrSeparator === 'string') {\n            sep = genOrSeparator;\n            return <X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) =>\n                this.join(gen, sep);\n        }\n        return [...toIterable(genOrSeparator)].join(sep);\n    }\n\n    /**\n     * Returns a new generator that returns values from each of the supplied sources as they are available.\n     * These will be taken in round-robin fashion from each non-terminated generator, until all have\n     * terminated. The yielded values will not be distinguished by which which source they are taken; for\n     * that, another method will be supplied.\n     *\n     * Any calls to `Generator.throw()` or `Generator.return()` will be passed to all non-terminated\n     * sources.\n     * @param sources\n     */\n\n    merge<T, TReturn, TNext>(...sources: Array<Genable<T, Sync, TReturn, TNext>>):\n        Enhanced<T, Sync, TReturn, TNext>\n    {\n        let self: Enhanced<T, Sync, TReturn, TNext>;\n        let gens: Array<Iterator<T, TReturn, TNext> | null> = sources.map(toIterator);\n        function* merge<X, XReturn, XNext>(gens: Array<Iterator<X, XReturn, XNext> | null>):\n            Generator<X, XReturn, XNext>\n        {\n            let done = false;\n            let running = true;\n            let nv: XNext;\n            try {\n                while (running) {\n                    running = false;\n                    for (let i = 0; i < gens.length; i++) {\n                        const g = gens[i];\n                        if (g) {\n                            const r = g.next(nv!);\n                            if (r.done) {\n                                gens[i] = null;\n                            } else {\n                                running = true;\n                                try {\n                                    nv = yield r.value;\n                                } catch (e) {\n                                    gens.forEach(doCatch(g => g?.throw?.(e)));\n                                }\n                            }\n                        }\n                    }\n                }\n                done = true;\n            } finally {\n                if (!done) {\n                    gens.forEach(doCatch(g => g?.return?.(self?.returning)));\n                }\n            }\n            return self?.returning;\n        }\n        return self = this.enhance(merge(gens));\n    }\n\n    /**\n     * Returns a function that sorts the supplied sources and returns a sorted array.\n     * @param cmp a comparison function\n     */\n    sort<T>(cmp?: ((a: T, b: T) => number)) {\n        return <TReturn, TNext>(...sources: Array<Genable<T, Sync, TReturn, TNext>>) => {\n            const result: T[] = this.merge(...sources).asArray();\n            return result.sort(cmp);\n        }\n    }\n\n    /**\n     * Enhance an existing generator (or iterator or iterable) to be a EnhancedGenerator.\n     * @param gen\n     */\n    enhance<T, TReturn, TNext>(gen: Genable<T, Sync, TReturn, TNext>):\n        EnhancedGenerator<T, TReturn, TNext>\n    {\n        const gen2 = toGenerator(gen) as Partial<EnhancedGenerator<T, TReturn, TNext>>;\n        const old = Object.getPrototypeOf(gen2);\n        const proto = Object.create(EnhancedGenerator.prototype);\n        proto.return = (v: TReturn) => (gen2.returning = v, old.return.call(gen2, v));\n        proto[Symbol.iterator] = () => gen2;\n        Object.setPrototypeOf(gen2, EnhancedGenerator.prototype);\n        return gen2 as EnhancedGenerator<T, TReturn, TNext>;\n    }\n}\n\n/**\n * Utilities to create and use generators which can be manipulated in various ways.\n *\n * Most methods come both as instance (prototype) methods and as static methods. They\n * provide equivalent functionality, but the static methods allow use on `Iterator` and\n * `Iterable` objects without first converting to a generator.\n *\n * The [[EnhancedGenerator.enhance]] method will add additional instance methods to\n * an ordinary generator's prototype (a new prototype, **not** modifying any global prototype!).\n * It can also be used to convert `Iterator` and `Iterable` objects to [[EnhancedGenerator]].\n *\n * For methods which return a EnhancedGenerator, care is take to propagate any `Generator.throw`\n * and `Generator.return` calls to any supplied generators, so they can properly terminate.\n *\n * The exception is [[EnhancedGenerator.flat]] (and by extension, [[EnhancedGenerator.flatMap]]), which cannot know what nested generators\n * they might encounter in the future. Any generators encountered so far will be terminated, however.\n *\n * @typeParam T the type of values returned in the iteration result.\n * @typeParam TReturn the type of values returned in the iteration result when the generator terminates\n * @typeParam TNext the type of value which can be passed to `.next(val)`.\n */\nexport abstract class EnhancedGenerator<T, TReturn, TNext>\n    extends Enhancements<T, TReturn, TNext, Sync>\n    implements Generator<T, TReturn, TNext>, Iterable<T>,\n        Iterator<T, TReturn, TNext>\n{\n    [Symbol.toStringTag]: 'EnhancedGenerator';\n}\n\n/**\n * Factory for synchronous generator operators. See [[GeneratorOps]] for details.\n */\nconst Sync: GeneratorOps<Sync> = new Sync_();\nexport {Sync};\n\nconst makeProto = (base: any) => {\n    const newProto = Object.create(base);\n    const inherit = (proto: any) => {\n        for (const k of Reflect.ownKeys(proto)) {\n            if (k !== 'constructor') {\n                newProto[k] = proto[k];\n            }\n        }\n    };\n    inherit(Enhancements.prototype);\n    return newProto;\n}\n\n/**\n * @internal\n * @constructor\n */\nfunction* Foo() {\n}\n\n/**\n * @internal\n */\nexport const GenProto = Object.getPrototypeOf(Foo());\n\n// Make EnhancedGenerator inherit generator methods.\nObject.setPrototypeOf(EnhancedGenerator.prototype, makeProto(GenProto));\nObject.defineProperty(EnhancedGenerator.prototype, '_impl', {\n    value: Sync,\n    writable: false,\n    enumerable: false,\n    configurable: false\n});\n","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * This entry point loads asynchronous extended generators\n * @packageDocumentation\n * @module async\n * @preferred\n */\n\nimport type {\n    Enhanced, FlatGen, Genable, GeneratorOps, GenOp, GenOpValue, IndexedFn, IndexedPredicate, Reducer, ReturnValue, UnwrapArray\n    } from \"./types\";\n// Should be 'import type' but that makes TS insist it can't be a value here even after defining it.\nimport {Async} from './types';\nimport {\n    isAsyncGenable, isAsyncGenerator, isAsyncIterable, isAsyncIterator, isGenable, isIterable,\n    toAsyncGenerator, toAsyncIterable, toAsyncIterator\n} from \"./functions\";\nimport {Enhancements} from \"./enhancements\";\n\n/**\n * Asynchronous implementation of enhanced generators\n */\n\n\nclass Async_ implements GeneratorOps<Async> {\n    /**\n     * Return a generator that yields the supplied values.\n     * @param values\n     */\n    of<T extends any[], TReturn, TNext>(...values: T):\n        Enhanced<UnwrapArray<T>, Async, TReturn, TNext>\n    {\n        return this.enhance(values);\n    }\n\n    async asArray<T, TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>):\n        Promise<T[]>\n    {\n        const it = toAsyncIterator(gen);\n        const result: T[] = []\n        while (true) {\n            const r = await it.next();\n            if (r.done) {\n                return result;\n            }\n            result.push(r.value);\n        }\n    }\n\n    limit<T, TReturn, TNext>(max: number, gen: Genable<T, Async, TReturn, TNext>):\n        Enhanced<T, Async, TReturn, TNext>;\n\n    limit(max: number):\n        GenOp<Async>;\n\n    limit<T, TReturn, TNext>(\n        max: number,\n        gen?: Genable<T, Async, TReturn, TNext>\n    ):\n         Enhanced<T, Async, TReturn, TNext>\n         | GenOp<Async>\n    {\n        let self: EnhancedAsyncGenerator<T, TReturn, TNext>;\n        async function *limit<X, XReturn = X, XNext = X>(gen: AsyncIterator<X, XReturn, XNext>) {\n            let nr: XNext;\n            let limited: boolean = false;\n            try {\n                for (let i = 0; i < max; i++) {\n                    const r: any = await gen.next(nr!);\n                    if (r.done) {\n                        return r.value;\n                    }\n                    try {\n                        nr = yield r.value;\n                    } catch (e) {\n                        await gen.throw?.(e);\n                    }\n                }\n                limited = true;\n                const err = new RangeError(`Generator produced excessive values > ${max}.`);\n                await gen.throw?.(err);\n                throw err;\n            } finally {\n                if (!limited) {\n                    await gen.return?.(self?.returning);\n                    // Even if the supplied generator refuses to terminate, we terminate.\n                }\n            }\n        }\n        if (gen) {\n            return self = this.enhance(limit(toAsyncIterator(gen)));\n        }\n        return <X, XReturn = X, XNext = X>(gen: Genable<X, Async, XReturn, XNext>) =>\n            this.enhance<X, XReturn, XNext>(limit(toAsyncIterator(gen)));\n    }\n\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @param thisArg Optional value to be supplied as context `this` for function _f_.\n     * @param gen the generator.\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T, TReturn, TNext>(f: IndexedFn<T, undefined, Async>, thisArg: any, gen: Genable<T, Async, TReturn, TNext>):\n        Promise<undefined>;\n\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @param gen the generator.\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T, TReturn, TNext>(f: IndexedFn<T, undefined, Async>, gen: Genable<T, Async, TReturn, TNext>):\n        Promise<undefined>;\n\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @param thisArg Optional value to be supplied as context `this` for function _f_.\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T>(f: IndexedFn<T, undefined, Async>, thisArg?: any):\n        <TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>) =>\n            Promise<undefined>;\n\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T>(f: IndexedFn<T, undefined, Async>):\n        <TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>, thisArg?: any) =>\n            Promise<undefined>;\n\n    forEach<T, TReturn = T, TNext = T>(\n        f: IndexedFn<T, undefined, Async>,\n        thisArgOrGen?: Genable<T, Async, TReturn, TNext>|any,\n        gen?: Genable<T, Async, TReturn, TNext>\n        ): Promise<undefined>\n            | (<XReturn = TReturn, XNext = TNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n                                                Promise<undefined>)\n    {\n        const forEach = async <XReturn, XNext>(\n                                f: IndexedFn<T, XReturn, Async>,\n                                thisArg: any,\n                                gen: Genable<T, Async, XReturn, XNext>\n                            ): Promise<undefined> =>\n            {\n                const it = toAsyncIterator(gen);\n                let idx = 0;\n                while (true) {\n                    const r = await it.next();\n                    if (r.done) return;\n                    await f.call(thisArg, r.value, idx++);\n                }\n            };\n        if (gen) return forEach(f, thisArgOrGen, gen!);\n        if (isAsyncGenable<T, TReturn, TNext>(thisArgOrGen)) return forEach(f, undefined, thisArgOrGen);\n        return <XReturn = T, XNext = T>(gen: Genable<T, Async, XReturn, XNext>, thisArg?: any) =>\n            forEach(f, thisArg ?? thisArgOrGen, gen);\n    }\n\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Async>):\n            GenOpValue<Async, T, V>;\n\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Async>, thisArg?: any):\n            GenOpValue<Async, T, V>;\n\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Async>, gen: Genable<T, Async, TReturn, TNext>):\n            Enhanced<V, Async, TReturn, TNext>;\n\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Async>, thisArg: any, gen: Genable<T, Async, TReturn, TNext>):\n            Enhanced<V, Async, TReturn, TNext>;\n\n    map<T, V,TReturn, TNext>(\n        f: IndexedFn<T, V, Async>,\n        thisArg?: any | Genable<T, Async, TReturn, TNext>,\n        iter?: Genable<T, Async, TReturn, TNext>\n    ):\n        EnhancedAsyncGenerator<V, TReturn, TNext>\n        | (<XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n                EnhancedAsyncGenerator<V, XReturn, XNext>)\n        | (<XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, thisArg?: any) =>\n                EnhancedAsyncGenerator<V, XReturn, XNext>)\n    {\n        const map = <XReturn = T, XNext = T>(thisArg: any, iter: Genable<T, Async, XReturn, XNext>) => {\n            const gen = toAsyncGenerator(iter);\n            let self: EnhancedAsyncGenerator<V, XReturn, XNext>;\n            async function* map(): AsyncGenerator<V, XReturn, XNext> {\n                let nr: any = undefined;\n                let idx = 0;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = await gen.next(nr);\n                                if (r.done) return r.value;\n                                const v = await f.call(thisArg, await r.value, idx++);\n                                try {\n                                    nr = yield v;\n                                } catch (e) {\n                                    await gen.throw(e);\n                                }\n                            }\n                        } finally {\n                            const x = await gen.return(self?.returning);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (!x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            return self = this.enhance(map());\n        };\n        if (iter) return map(thisArg, iter);\n        if (isAsyncGenable<T, TReturn, TNext>(thisArg)) return map(undefined, thisArg);\n        return <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, genThisArg?: any) =>\n                    map(genThisArg ?? thisArg, gen);\n    }\n\n    /**\n     * Return a function that filters a [[Genable]] and yields a new [[EnhancedGenerator]]\n     * that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @typeParam T the type of value.\n     */\n    filter<T>(f: IndexedPredicate<T, Async>):\n        GenOpValue<Async, T, T>;\n\n    /**\n     * Return a function that filters a [[Genable]] and yields a new [[EnhancedGenerator]]\n     * that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     * @typeParam T the type of value.\n     */\n    filter<T>(f: IndexedPredicate<T, Async>, thisArg: any):\n        GenOpValue<Async, T, T>;\n\n    /**\n     * Return a new [[EnhancedGenerator]] that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param iter a [[Genable|Genable<T>]]\n     * @typeParam T the type of value.\n     */\n    filter<T, TReturn, TNext>(f: IndexedPredicate<T, Async>, iter: Genable<T, Async, TReturn, TNext>):\n        Enhanced<T, Async, TReturn, TNext>;\n\n    /**\n     * Return a new [[EnhancedGenerator]] that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     * @param iter a [[Genable|Genable<T>]]\n     * @typeParam T the type of value.\n     */\n    filter<T, TReturn, TNext>(f: IndexedPredicate<T, Async>, thisArg: any, iter: Genable<T, Async, TReturn, TNext>):\n        Enhanced<T, Async, TReturn, TNext>;\n\n    /**\n     * Return a function that filters a [[Genable]] and yields a new [[EnhancedGenerator]]\n     * that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     * @param iter the [[Genable]] to filter.\n     * @typeParam T the type of value.\n     */\n    filter<T, TReturn, TNext>(\n        f: IndexedPredicate<T, Async>,\n        thisArg?: any | Genable<T, Async, TReturn, TNext>,\n        iter?: Genable<T, Async, TReturn, TNext>\n    ):\n        Enhanced<T, Async, TReturn, TNext>\n        | GenOpValue<Async, T, T>\n    {\n        const filter = <XReturn, XNext>(thisArg: any, iter: Genable<T, Async, XReturn, XNext>) => {\n            const gen = toAsyncGenerator<T, XReturn, XNext>(iter);\n            let self: EnhancedAsyncGenerator<T, XReturn, XNext>;\n            async function* filter<V>(f: IndexedPredicate<T, Async>): AsyncGenerator<T, XReturn, XNext> {\n                let nr: any = undefined;\n                let idx = 0;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = await gen.next(nr);\n                                if (r.done) return r.value;\n                                if (await f.call(thisArg, r.value, idx++)) {\n                                    try {\n                                        nr = yield r.value;\n                                    } catch (e) {\n                                        await gen.throw(e);\n                                    }\n                                }\n                            }\n                        } finally {\n                            const x = await gen.return?.(self?.returning);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (!x?.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            return self = this.enhance(filter(f));\n        };\n\n        if (iter) return filter(thisArg, iter);\n        if (isAsyncGenable<T, TReturn, TNext>(thisArg)) return filter(undefined, thisArg);\n        return <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, genThisArg?: any) =>\n            filter<XReturn, XNext>(genThisArg ?? thisArg, gen);\n    }\n\n\n    /**\n     * Flatten the values yielded by the generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param depth\n     */\n    flat<D extends number>(depth: D):\n        <T, TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>) =>\n            Enhanced<FlatGen<T, D>, Async, TReturn, TNext>;\n\n    /**\n     * Flatten the values yielded by the generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param depth\n     * @param gen\n     */\n\n    flat<D extends number, T, TReturn, TNext>(depth: D, gen: Genable<T, Async, TReturn, TNext>):\n        Enhanced<FlatGen<T, D>, Async, TReturn, TNext>;\n\n    /**\n     * Flatten the values yielded by the generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param gen\n     * @param depth default = 1\n     */\n    flat<D extends number, T, TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>, depth?: D):\n        Enhanced<FlatGen<T, D>, Async, TReturn, TNext>;\n\n    flat<D extends number, T, TReturn, TNext>(depth: D|Genable<T, Async, TReturn, TNext>, gen?: Genable<T, Async, TReturn, TNext> | D):\n        Enhanced<FlatGen<T, D>, Async, TReturn, TNext>\n        | (<X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>) =>\n                Enhanced<FlatGen<X, D>, Async, XReturn, XNext>)\n    {\n        const flat = <X, XReturn, XNext>(depth: D, gen: Genable<X, Async, XReturn, XNext>) => {\n            let self: Enhanced<FlatGen<X, D>, Async, XReturn, XNext>;\n            const gens = new Set<AsyncGenerator>();\n            if (isAsyncGenerator(gen)) gens.add(gen);\n\n            async function* flat<D extends number, Y, YReturn, YNext>(it: AsyncIterator<Y, YReturn, YNext>, depth: D): AsyncGenerator<FlatGen<Y, D>, YReturn, YNext> {\n                let nr: any = undefined;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = await it.next(nr);\n                                if (r.done) return r.value;\n                                const v: any = r.value;\n                                if (isAsyncGenerator(v)) {\n                                    gens.add(v);\n                                }\n                                try {\n                                    if (depth > 0 && isAsyncIterator(v)) {\n                                        yield* flat(v, depth - 1);\n                                    } else if (depth > 0 && (isAsyncIterable(v) || isIterable(v))) {\n                                        yield* flat(toAsyncIterator(v), depth - 1)\n                                    } else {\n                                        nr = yield r.value as FlatGen<T, D>;\n                                    }\n                                } catch (e) {\n                                    await it.throw?.(e);\n                                }\n                            }\n                        } finally {\n                            const x = await it.return?.(self?.returning);\n                            if (isAsyncGenerator(it)) gens.delete(it);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (x && !x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                            for (const g of gens) {\n                                await g.return(self?.returning);\n                            }\n                        }\n                    }\n                }\n            }\n\n            return self = this.enhance(flat(toAsyncIterator(gen), depth));\n        }\n        if (typeof depth === 'number') {\n            if (gen) {\n                if (isAsyncGenable(gen)) {\n                    return flat(depth, gen);\n                } else {\n                    throw new TypeError(`Invalid Genable: ${gen}`);\n                }\n            }\n            return <X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>) =>\n                flat(depth, gen);\n        } else if (isAsyncGenable(depth)) {\n            return flat((gen ?? 1) as D, depth);\n        }\n        throw new TypeError(`Illegal arguments to flat()`);\n    }\n\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a function that accepts a generator, and returns another generator that yields the individual value\n     * at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param depth\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T>(f: IndexedFn<T, R, Async>, depth: D):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n            Enhanced<R, Async, XReturn, XNext>;\n\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a function that accepts a generator, and returns another generator that yields the individual value\n     * at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T>(f: IndexedFn<T, R, Async>):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, depth?: D) =>\n            Enhanced<R, Async, XReturn, XNext>;\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a generator that yields the individual values at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param gen\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T, TReturn, TNext>(\n            f: IndexedFn<T, R, Async>,\n            gen: Genable<T, Async, TReturn, TNext>\n    ):\n        Enhanced<R, Async, TReturn, TNext>;\n\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a generator that yields the individual values at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param depth\n     * @param gen\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T, TReturn, TNext>(\n        f: IndexedFn<T, R, Async>,\n        depth: D,\n        gen: Genable<T, Async, TReturn, TNext>\n    ):\n        Enhanced<R, Async, TReturn, TNext>;\n\n    flatMap<D extends number, R extends FlatGen<T, D>, T, TReturn, TNext>(\n        f: IndexedFn<T, R, Async>,\n        depthOrGen?: D | Genable<T, Async, TReturn, TNext>,\n        gen?: Genable<T, Async, TReturn, TNext>\n    ):\n        Enhanced<R, Async, TReturn, TNext>\n        | (\n            <Y extends FlatGen<T, D>, X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>) =>\n                Enhanced<Y, Async, XReturn, XNext>\n        )\n        | (\n            <Y extends FlatGen<T, D>, X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>, depth?: D) =>\n                Enhanced<Y, Async, XReturn, XNext>\n        )\n    {\n        const flatMap = <X, XReturn, XNext>(depth: D, gen: Genable<X, Async, XReturn, XNext>) => {\n            let self: Enhanced<FlatGen<X, D>, Async, XReturn, XNext>;\n            let idx = 0;\n\n            async function* flatMap<D extends number, Y, YReturn, YNext>(\n                    it: AsyncIterator<Y, YReturn, YNext>, depth: D\n                ):\n                    AsyncGenerator<FlatGen<T, D>, YReturn, YNext>\n                {\n                let nr: any = undefined;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = await it.next(nr);\n                                if (r.done) return r.value;\n                                const v = await f(r.value as FlatGen<T, D>, idx++);\n                                try {\n                                    if (isAsyncIterator<unknown, YReturn, YNext>(v)) {\n                                        if (depth > 1) {\n                                            yield* flatMap(v, depth - 1);\n                                        } else if (depth === 1) {\n                                            const it = toAsyncIterator(v);\n                                            yield* toAsyncGenerator(it);\n                                        } else {\n                                            yield v;\n                                        }\n                                    } else if (isAsyncIterable<unknown, YReturn, YNext>(v) || isIterable<unknown, YReturn, YNext>(v)) {\n                                        if (depth > 1) {\n                                            yield* flatMap(toAsyncIterator(v), depth - 1);\n                                        } else if (depth === 1) {\n                                            yield* toAsyncGenerator(v);\n                                        } else {\n                                            yield v;\n                                        }\n                                    } else {\n                                        nr = yield v;\n                                    }\n                                } catch (e) {\n                                    await it.throw?.(e);\n                                }\n                            }\n                        } finally {\n                            const x = await it.return?.(self?.returning);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (x && !x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            return self = this.enhance(flatMap(toAsyncIterator(gen), depth));\n        }\n\n        if (isAsyncGenable(gen)) {\n            return flatMap(depthOrGen as D ?? 1 as D, gen);\n        } else if (isAsyncGenable( depthOrGen)) {\n            return flatMap(1 as D, depthOrGen);\n        }\n        return <X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>, depth?: D) =>\n            flatMap(depthOrGen ?? depth ?? 1 as D, gen);\n    }\n\n    /**\n     * Return a new [[EnhancedGenerator]] that only yields the indicated values, skipping _start_ initial values\n     * and continuing until the _end_.\n     * @param start\n     * @param end\n     */\n    slice<T>(start: number, end: number):\n        <X, XReturn, XNext>(iter: Genable<X, Async, XReturn, XNext>) =>\n            Enhanced<X, Async, XReturn, XNext>;\n    /**\n     * Return a new [[EnhancedGenerator]] that only yields the indicated values, skipping _start_ initial values\n     * and continuing until the _end_.\n     * @param start\n     * @param end\n     * @param iter\n     */\n    slice<T, TReturn, TNext>(start: number, end: number, iter: Genable<T, Async, TReturn, TNext>):\n        Enhanced<T, Async, TReturn, TNext>;\n\n    slice<T, TReturn, TNext>(\n        start: number,\n        end: number,\n        iter?: Genable<T, Async, TReturn, TNext>\n    ):\n        Enhanced<T, Async, TReturn | undefined, TNext>\n        | (\n            <X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>) =>\n                Enhanced<X, Async, XReturn | undefined, XNext>\n        )\n    {\n        const slice = <X, XReturn, XNext>(iter: Genable<X, Async, XReturn, XNext>):\n            Enhanced<X, Async, XReturn | undefined, XNext> =>\n        {\n            const it = toAsyncIterator(iter);\n            async function* slice(start: number, end: number) {\n                for (let i = 0; i < start; i++) {\n                    const r = await it.next();\n                    if (r.done) return r.value;\n                }\n                if (end === Number.POSITIVE_INFINITY) {\n                    yield* toAsyncIterable(it);\n                } else {\n                    let nv: XNext;\n                    while (true) {\n                        try {\n                            for (let i = start; i < end; i++) {\n                                const r = await it.next(nv!);\n                                if (r.done) return r.value;\n                                try {\n                                    nv = yield r.value;\n                                } catch (e) {\n                                    const re = await it.throw?.(e);\n                                    if (re) {\n                                        if (re.done) return re.value;\n                                        nv = yield re.value;\n                                    }\n                                }\n                            }\n                        } finally {\n                            const x = await it.return?.();\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (x && !x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n                return;\n            }\n            return this.enhance(slice(start, end));\n        };\n        if (!iter) return slice;\n        return slice(iter);\n    }\n\n    /**\n     * Concatenates generators (or iterators or iterables).\n     *\n     * Ensures that any supplied generators are terminated when this is terminated.\n     * @param gens zero or more additional [[Genable]] to provide values.\n     */\n    concat<T, TReturn, TNext>(...gens: Array<Genable<T, Async, TReturn, TNext>>):\n        Enhanced<T, Async, TReturn | void, TNext>\n    {\n        let self: Enhanced<T, Async, TReturn | void, TNext>;\n        async function* concat(): AsyncGenerator<T, TReturn | void, TNext> {\n            let i = 0;\n            try {\n                for (; i < gens.length; i++) {\n                    const it = toAsyncIterable(gens[i]);\n                    yield* it;\n                }\n            } finally {\n                // Terminate any remaining generators.\n                for (; i < gens.length; i++) {\n                    const g = gens[i];\n                    if (isAsyncGenerator(g)) {\n                        await g.return(self?.returning);\n                    }\n                }\n            }\n        }\n\n        return self = this.enhance(concat());\n    }\n\n    /**\n     * Reduces **gen** like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     * @param f\n     * @param gen\n     */\n    reduce<A, T, TReturn, TNext>(f: Reducer<A, T, T, Async>, gen: Genable<T, Async, TReturn, TNext>):\n        A;\n\n    /**\n     *\n     * Returns a reducer function that, when applied to a `Generator` **gen**, reduces **gen** like\n     * **Array.prototype.reduce**. The 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     *\n     * @param f\n     */\n    reduce<A, T>(f: Reducer<A, T, T, Async>):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n            A;\n\n    /**\n     *\n     * Returns a reducer function that, when applied to a `Generator` **gen**, reduces **gen** like\n     * `Array.prototype.reduce`. The 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     *\n     * @param f\n     */\n    reduce<A, T>(f: Reducer<A, T, A, Async>):\n        <XReturn, XNext>(init: A, gen: Genable<T, Async, XReturn, XNext>) =>\n            A;\n\n    /**\n     * Reduces **gen** like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     * @param f\n     * @param init\n     * @param gen\n     */\n    reduce<A, T, TReturn, TNext>(f: Reducer<A, T, A, Async>, init: A, gen: Genable<T, Async, TReturn, TNext>):\n        A;\n\n    /**\n     * Returns a reducer function that, when applied to a `Generator` **gen**, reduces **gen** like\n     * `Array.prototype.reduce`. The 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     *\n     * Alternatively, the init value can be supplied along with the generator as a second argument.\n     * @param f\n     * @param init\n     */\n    reduce<A, T>(f: Reducer<A, T, A, Async>, init: A):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n            A;\n\n    reduce<A, T, TReturn, TNext>(\n        f: Reducer<A, T, A | T, Async>,\n        initOrGen?: A | Genable<T, Async, TReturn, TNext>,\n        gen?: Genable<T, Async, TReturn, TNext>\n    ): A\n        | Promise<A>\n        | (\n            (gen: Genable<T, Async, TReturn, TNext>) =>\n                A | Promise<A>\n        )\n        | (\n            (f: (acc: A, v: T) => A, init: A) =>\n                A | Promise<A>\n        )\n        | (\n            (f: (acc: A | T, v: T) => A) =>\n                A | Promise<A>\n        )\n    {\n\n        const reduce = async <XReturn, XNext>(init: A | PromiseLike<A> | undefined, it: AsyncIterator<T, XReturn, XNext>):\n            Promise<A> =>\n        {\n            let acc: A | T | undefined = await init;\n            if (acc === undefined) {\n                const r = await it.next();\n                if (r.done) throw new TypeError(`No initial value in reduce`);\n                acc = r.value;\n            }\n            while (true) {\n                const r = await it.next();\n                if (r.done) return acc as A;\n                acc = await f(acc, r.value);\n            }\n        };\n        if (isAsyncGenable(gen)) {\n            return reduce(initOrGen as A, toAsyncIterator(gen));\n        } else if (isAsyncGenable(initOrGen)) {\n            return reduce(undefined, toAsyncIterator(initOrGen));\n        }\n        return (gen: Genable<T, Async, TReturn, TNext>, init?: A) =>\n            reduce(init ?? initOrGen, toAsyncIterator(gen));\n    }\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    some<T, TReturn, TNext>(p: IndexedPredicate<T, Async>, thisArg?: any):\n        (gen: Genable<T, Async, TReturn, TNext>) =>\n            ReturnValue<boolean, Async>;\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     */\n    some<T>(p: IndexedPredicate<T, Async>):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, thisArg?: any) =>\n            ReturnValue<boolean, Async>;\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param gen the generator\n     */\n    some<T, TReturn, TNext>(p: IndexedPredicate<T, Async>, gen: Genable<T, Async, TReturn, TNext>):\n        ReturnValue<boolean, Async>;\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     * @param gen the generator\n     */\n    some<T, TReturn, TNext>(p: IndexedPredicate<T, Async>, thisArg: any, gen: Genable<T, Async, TReturn, TNext>):\n        ReturnValue<boolean, Async>;\n\n    some<T, TReturn, TNext>(\n        pred: IndexedPredicate<T, Async>,\n        thisOrGen?: any | Genable<T, Async, TReturn, TNext>,\n        gen?: Genable<T, Async, TReturn, TNext>\n    ):\n        ReturnValue<boolean, Async>\n        | (\n            (gen: Genable<T, Async, TReturn, TNext>) =>\n                ReturnValue<boolean, Async>\n        )\n    {\n        const some = async <XReturn, XNext>(thisArg: any, it: AsyncIterator<T, XReturn, XNext>): Promise<boolean> => {\n            let i = 0;\n            while (true) {\n                const r = await it.next();\n                if (r.done) return false;\n                if (pred.call(thisArg, r.value, i++)) return true;\n            }\n        };\n        if (isAsyncGenable(gen)) {\n            return some(thisOrGen, toAsyncIterator(gen));\n        } else if (isAsyncGenable(gen)) {\n            return (gen: Genable<T, Async, TReturn, TNext>, thisArg?: any) =>\n                some(thisArg ?? thisOrGen, toAsyncIterator(gen));\n        }\n        throw new Error(`Invalid argument to some: ${gen ?? thisOrGen}`);\n    }\n\n\n    /**\n     * Returns `false` and terminates the generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    every<T>(p: IndexedPredicate<T, Async>, thisArg?: any):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n            ReturnValue<boolean, Async>;\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     */\n    every<T>(p: IndexedPredicate<T, Async>):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, thisArg?: any) =>\n            ReturnValue<boolean, Async>;\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param gen the generator\n     */\n    every<T, TReturn, TNext>(p: IndexedPredicate<T, Async>, gen: Genable<T, Async,TReturn, TNext>):\n        ReturnValue<boolean, Async>;\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     * @param gen the generator\n     */\n    every<T, TReturn, TNext>(p: IndexedPredicate<T, Async>, thisArg: any, gen: Genable<T, Async, TReturn, TNext>):\n        ReturnValue<boolean, Async>;\n\n    every<T, TReturn, TNext>(\n        pred: IndexedPredicate<T, Async>,\n        genOrThis?: any | Genable<T, Async, TReturn, TNext>,\n        gen?: Genable<T, Async, TReturn, TNext>\n    ):\n        ReturnValue<boolean, Async>\n        | (\n            <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n                ReturnValue<boolean, Async>\n        )\n    {\n        const every = async <XReturn, XNext>(thisArg: any, it: AsyncIterator<T, XReturn, XNext>):\n            Promise<boolean> =>\n        {\n            let i = 0;\n            while (true) {\n                const r = await it.next();\n                if (r.done) return true;\n                if (!pred.call(thisArg, r.value, i++)) return false;\n            }\n        };\n        if (isAsyncGenable(gen)) {\n            return every(genOrThis, toAsyncIterator(gen));\n        } else if (isGenable(gen)) {\n            return <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, thisArg?: any) =>\n                every(thisArg ?? genOrThis, toAsyncIterator(gen));\n        }\n        throw new Error(`Invalid argument to every: ${gen ?? genOrThis}`);\n    }\n\n    /**\n     * Returns a new generator that repeats the last value returned by **gen** (or `undefined` if **gen**\n     * did not return any values).\n     *\n     * @param gen\n     * @param max\n     */\n    repeatLast<T, TReturn, TNext>(\n        gen: Genable<T, Async, TReturn, TNext>,\n        max: number = Number.POSITIVE_INFINITY\n    ):\n        Enhanced<T, Async, TReturn | undefined, TNext>\n    {\n        const it = toAsyncIterator(gen);\n        let nr: TNext;\n        let self: Enhanced<T, Async, TReturn | undefined, TNext>;\n\n        async function* repeatLast(): AsyncGenerator<T, TReturn | undefined, TNext> {\n            try {\n                let last: T;\n                while (true) {\n                    const r = await it.next(nr as unknown as TNext)\n                    if (r.done) break;\n                    try {\n                        nr = yield (last = r.value);\n                    } catch (e) {\n                        const re = await it.throw?.(e);\n                        if (re) {\n                            if (re.done) break;\n                            yield last = re.value;\n                        }\n                    }\n                }\n                for (let i = 0; i < max; i++) {\n                    // Important to await at the expected point for consistent behavior.\n                    yield await last!;\n                }\n            } finally {\n                await it.return?.(self?.returning);\n            }\n            return;\n        }\n\n        return self = this.enhance(repeatLast());\n    }\n\n\n    /**\n     * Returns a new generator that repeats the supplied value.\n     *\n     * @param value the value to repeat\n     * @param repetitions The number repetitions; the default is infinite.\n     */\n    repeat<T, TNext>(value: T, repetitions: number = Number.POSITIVE_INFINITY):\n        Enhanced<T, Async, void, TNext>\n    {\n        async function* repeat(): AsyncGenerator<T, void, TNext> {\n            for (let i = 0; i < repetitions; i++) {\n                // Important to await at the expected point for consistent behavior.\n                yield await value;\n            }\n        }\n\n        return this.enhance(repeat());\n    }\n\n    /**\n     * Combines generators, returning a generator that produces a tuple with each of their results.\n     *\n     * Terminates when the first generator terminates. To get other behaviors, use with [[EnhancedGenerator.repeat]] or\n     * [[EnhancedGenerator.repeatLast]].\n     * @param gens\n     */\n    zip<T, TReturn, TNext>(...gens: Array<Genable<T, Async, TReturn, TNext>>):\n        Enhanced<Array<T>, Async, TReturn, TNext>\n    {\n        if (gens.length === 0) return this.enhance([]);\n        const its = gens.map(toAsyncIterator);\n        let done = false;\n        let self: Enhanced<Array<T>, Async, TReturn, TNext>;\n\n        async function* zip2(): AsyncGenerator<Array<T>, TReturn, TNext> {\n            try {\n                while (true) {\n                    let result: Array<T> = [];\n                    for (const g of its) {\n                        const r = await g.next();\n                        if (r.done) {\n                            done = true;\n                            return r.value;\n                        }\n                        (result as any[]).push(r.value);\n                    }\n                    try {\n                        yield result;\n                    } catch (e) {\n                        for (const g of gens) {\n                            try {\n                                // Weird need for a typecast here.\n                                await (g as any).throw?.(e);\n                            } catch {\n                                // Ignore\n                            }\n                        }\n                        throw e;\n                    }\n                }\n            } finally {\n                if (!done) {\n                    for (const g of gens) {\n                        try {\n                            // Weird need for a typecast here.\n                            await (g as any).return?.(self?.returning);\n                        } catch {\n                            // Ignore\n                        }\n                    }\n                }\n            }\n        }\n\n        return self = this.enhance(zip2());\n    }\n\n\n    /**\n     * Returns a function that joins the elements produced by a [[Genable]], analogous to `Array.prototype.join`.\n     * @param sep (default = ',')\n     */\n    join(sep: string):\n        <T, TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>) =>\n            ReturnValue<string, Async>;\n\n    /**\n     * Joins the elements produced by a [[Genable]], analogous to `Array.prototype.join`.\n     * @param gen\n     * @param sep\n     */\n    join<T, TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>, sep?: string):\n        ReturnValue<string, Async>;\n\n    join<T, TReturn, TNext>(\n        genOrSeparator: Genable<T, Async, TReturn, TNext>|string,\n        sep?: string\n    ):\n        ReturnValue<string, Async>\n        | (\n            <X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>) =>\n                ReturnValue<string, Async>\n        )\n    {\n        if (typeof genOrSeparator === 'string') {\n            sep = genOrSeparator;\n            return <X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>) =>\n                this.join(gen, sep);\n        }\n        return Promise.resolve(this.enhance(genOrSeparator).asArray())\n            .then(a => a.join(sep));\n    }\n\n    /**\n     * Returns a new generator that returns values from each of the supplied sources as they are available.\n     * Values will be taken as they become available from any source.\n     * The yielded values will not be distinguished by which which source they are taken; for\n     * that, another method will be supplied.\n     *\n     * Any calls to `Generator.throw()` or `Generator.return()` will be passed to all non-terminated\n     * sources.\n     * @param sources\n     */\n    merge<T, TReturn, TNext>(...sources: Array<Genable<T, Async, TReturn, TNext>>):\n        Enhanced<T, Async, TReturn | void, TNext>\n    {\n        let self: Enhanced<T, Async, void | TReturn, TNext>;\n        let done: (r: IteratorReturnResult<TReturn>) => void;\n        const donePromise = new Promise<IteratorReturnResult<TReturn>>(r => (done = r));\n        let activeCount = sources.length;\n        let active: Array<Promise<() => (IteratorResult<T, TReturn> | null)> | Promise<IteratorReturnResult<TReturn>>>;\n        const dead = new Promise<() => (IteratorResult<T, TReturn> | null)>(() => null); // Never completes\n        let gens: Array<AsyncIterator<T, TReturn, TNext>> = [];\n        const wrap = async (g: Genable<T, Async, TReturn, TNext>, k: number) => {\n            const ag = toAsyncIterator(g);\n            gens[k] = ag;\n            const handle = async (val: IteratorResult<T, TReturn>): Promise<() => (IteratorResult<T, TReturn> | null)> =>\n                () => {\n                    if (val.done) {\n                        active[k] = dead;\n                        // Unless this is the last active generator, we return null to indicate\n                        // to the loop to go on to the next one.\n                        return --activeCount > 0\n                            ? null\n                            : (done(val), val);\n                    } else {\n                        const v = ag.next().then(handle);\n                        active[k] = v;\n                        return val;\n                    }\n                };\n            return (await ag.next().then(handle));\n        };\n        active = [...sources.map(wrap), donePromise];\n        async function* merge(): AsyncGenerator<T, TReturn | void, TNext> {\n            try {\n                let nv: TNext;\n                while (activeCount) {\n                    const race: Array<Promise<() => (IteratorResult<T, TReturn> | null)> | Promise<IteratorReturnResult<TReturn>>> = [];\n                    active.forEach(a => race.push(a))\n                    const result = await (await Promise.race(race));\n                    if (typeof result === 'function') {\n                        let r = result();\n                        if (r) {\n                            if (r.done) {\n                                return r.value;\n                            }\n                            nv = (yield r.value);\n                        }\n                    } else if (result && result.done) {\n                        return result.value;\n                    }\n                }\n            } finally {\n                if (activeCount) {\n                    for (let i = 0; i < sources.length; i++) {\n                        (active[i] === null ? null : gens[i])?.return?.(self?.returning);\n                    }\n                }\n            }\n        }\n        return self = Async.enhance(merge());\n    }\n\n    /**\n     * Returns a function that sorts the supplied sources and returns a sorted array.\n     * @param cmp a comparison function\n     */\n    sort<T>(cmp?: ((a: T, b: T) => number)) {\n        return async <TReturn, TNext>(...sources: Array<Genable<T, Async, TReturn, TNext>>) => {\n            const array: T[] = await this.merge(...sources).asArray();\n            return array.sort(cmp);\n        };\n    }\n\n    /**\n     * Enhance an existing generator (or iterator or iterable) to be a EnhancedGenerator.\n     * @param gen\n     */\n    enhance<T, TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>):\n        EnhancedAsyncGenerator<T, TReturn, TNext>\n    {\n        const gen2 = toAsyncGenerator(gen)as\n            unknown as Partial<EnhancedAsyncGenerator<T, TReturn, TNext>>;\n        const old = Object.getPrototypeOf(gen2);\n        const proto = Object.assign(Object.create(EnhancedAsyncGenerator.prototype), old);\n        proto.return = (v: any) => ((gen2 as any).returning = v, old.return.call(gen2, v));\n        proto[Symbol.asyncIterator] = () => gen2;\n        Object.setPrototypeOf(gen2, proto);\n        return gen2 as EnhancedAsyncGenerator<T, TReturn, TNext>;\n    }\n}\n\n/**\n * Factory for synchronous generator operators. See [[GeneratorOps]] for details.\n */\nconst Async: GeneratorOps<Async> = new Async_();\nexport {Async};\n\nexport abstract class EnhancedAsyncGenerator<T, TReturn, TNext>\n    extends Enhancements<T, TReturn, TNext, Async>\n    implements AsyncGenerator<T, TReturn, TNext>,\n        AsyncIterable<T>,\n        AsyncIterator<T, TReturn, TNext>\n{\n}\n\nconst makeProto = (base: any) => {\n    const newProto = Object.create(base);\n    const inherit = (proto: any) => {\n        for (const k of Reflect.ownKeys(proto)) {\n            if (k !== 'constructor') {\n                newProto[k] = proto[k];\n            }\n        }\n    };\n    inherit(Enhancements.prototype);\n    return newProto;\n}\n\n/**\n * @internal\n * @constructor\n */\nasync function* AsyncFoo() {\n}\n\n/**\n * @internal\n */\nexport const AsyncGenProto = Object.getPrototypeOf(AsyncFoo());\n\n// Make EnhancedGenerator inherit generator methods.\n\nObject.setPrototypeOf(EnhancedAsyncGenerator.prototype, makeProto(AsyncGenProto));\nObject.defineProperty(EnhancedAsyncGenerator.prototype, '_impl', {\n    value: Async,\n    writable: false,\n    enumerable: false,\n    configurable: false\n});\n","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n\n/**\n * This entry point loads synchronous and asynchronous extended generators\n * @packageDocumentation\n * @module generators\n * @preferred\n */\n\nexport type {SyncType} from './types';\nimport {Sync as SyncFoo} from './sync';\nimport {Async as AsyncFoo} from './async';\n\n/**\n * Factory for synchronous generator operators. See [[GeneratorOps]] for details.\n */\nconst Sync = SyncFoo;\n/**\n * Selector type to select the types for synchronous generators.\n */\ntype Sync = 'sync';\n\n/**\n * Factory for asynchronous generator operators. See [[GeneratorOps]] for details.\n */\nconst Async = AsyncFoo;\n/**\n * Selector type to select the types for ssynchronous generators.\n */\ntype Async = 'async';\nexport {Sync, Async};\n"],"names":["isFunction","f","isGenable","g","isIterator","isIterable","isAsyncGenable","isAsyncIterator","isAsyncIterable","isGenerator","next","return","throw","Symbol","iterator","isAsyncGenerator","asyncIterator","toGenerator","i","it","r","done","value","wrap","Error","toAsyncGenerator","async","toIterator","toAsyncIterator","asyncAdaptor","self","nr","Promise","resolve","e","returning","toIterable","toAsyncIterable","iterable","toAsyncIterable_adaptor","doCatch","onError","args","Enhancements","toStringTag","asArray","this","_impl","limit","max","forEach","thisArg","map","filter","flat","depth","flatMap","slice","start","end","Number","POSITIVE_INFINITY","concat","gens","reduce","init","some","p","every","repeatLast","repeat","repetitions","tail","zip","join","sep","sort","cmp","EnhancedGenerator","Sync","of","values","enhance","gen","limited","err","RangeError","thisArgOrGen","idx","call","undefined","iter","v","genThisArg","x","Set","add","delete","TypeError","depthOrGen","nv","re","length","initOrGen","acc","pred","thisOrGen","genOrThis","last","its","result","push","zip2","genOrSeparator","merge","sources","running","gen2","old","Object","getPrototypeOf","proto","create","prototype","setPrototypeOf","GenProto","Foo","base","newProto","k","Reflect","ownKeys","inherit","makeProto","defineProperty","writable","enumerable","configurable","Async","then","a","donePromise","active","activeCount","dead","ag","handle","val","race","assign","EnhancedAsyncGenerator","AsyncGenProto","AsyncFoo","SyncFoo"],"mappings":"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"}