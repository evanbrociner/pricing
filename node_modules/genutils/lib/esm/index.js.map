{"version":3,"file":"index.js","sources":["../../src/functions.ts","../../src/enhancements.ts","../../src/sync.ts","../../src/range.ts","../../src/async.ts","../../src/generators.ts","../../node_modules/denque/index.js","../../src/events.ts","../../src/future.ts","../../src/util.ts","../../src/sync-mixin.ts","../../src/async-mixin.ts"],"sourcesContent":["/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * Functions to test (as typeguards) and coerce generators, iterators, etc.\n *\n * @packageDocumentation\n * @module functions\n * @preferred\n */\n\n\nimport type {Async, Sync, Genable, FullIterable, FullIterableIterator} from \"./types\";\n\n/**\n * Predicate/Type Guard for any function.\n * @param f\n */\nexport const isFunction = <A extends Function>(f: (A | any)): f is A => {\n    return typeof f === 'function';\n}\n\n/**\n * Predicate/type guard to determine if an object is [[Genable]]. An object is [[Genable]] if it\n * supports the `Iterator` or `Iterable` protocols. (Generators support both).\n * @param g\n */\nexport const isGenable = <T, TReturn = T, TNext = T>(g: Iterator<T, TReturn, TNext>|Iterable<T>|Generator<T, TReturn, TNext>|any):\n    g is Genable<T, Sync, TReturn, TNext> =>\n        g && (isIterator(g) || isIterable(g));\n\n\nexport const isAsyncGenable = <T, TReturn, TNext>(g: AsyncIterator<T, TReturn, TNext>|AsyncIterable<T>|AsyncGenerator<T,TReturn,TNext>|any):\n    g is Genable<T, Async, TReturn, TNext> =>\n        g && (isAsyncIterator<T, TReturn, TNext>(g) || isAsyncIterable<T, TReturn, TNext>(g) || isIterable<T, TReturn, TNext>(g));\n\n/**\n * Predicate/type guard to determine if an object is (or looks like, structurally) a Generator.\n * @param g\n */\nexport const isGenerator = <T, TReturn, TNext>(g: Genable<T, Sync, TReturn, TNext>|any): g is Generator<T, TReturn, TNext> =>\n    g &&\n    isFunction(g.next)\n    && isFunction(g.return)\n    && isFunction(g.throw)\n    && isFunction(g[Symbol.iterator]);\n\n/**\n * Predicate/type guard to determine if an object is (or looks like, structurally) a AsyncGenerator.\n * @param g\n */\nexport const isAsyncGenerator = <T, TReturn, TNext>(g: Genable<T, Async, TReturn, TNext>|any): g is AsyncGenerator<T> =>\n    g &&\n    isFunction(g.next)\n    && isFunction(g.return)\n    && isFunction(g.throw)\n    && isFunction(g[Symbol.asyncIterator]);\n\n/**\n * Coerce an object to an object that can act as a generator (that is, satisfy both `Iterator`\n * and `Iterable`).\n *\n * If it is an `Iterator` but not `Iterable`, or `Iterable` but not `Iterator`, it is wrapped\n * in a generator. This generator is __not__ enhanced. Use [[Sync.enhance]] on the result if\n * you need an enhanced generator.\n * @param i\n */\nexport function toGenerator<T, TReturn = T, TNext = T>(i: Genable<T, Sync, TReturn, TNext>): Generator<T, TReturn, TNext> {\n    if (isGenerator(i)) return i;\n    if (isIterator(i)) {\n        const it = i;\n\n        function* wrap() {\n            while (true) {\n                const r = it.next();\n                if (r.done) return r.value;\n                yield r.value;\n            }\n        }\n\n        return wrap();\n    } else if (isIterable(i)) {\n        return toGenerator(i[Symbol.iterator]() as Iterator<T, TReturn, TNext>);\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\n\n/**\n * Coerce an object to an object that can act as a async generator (that is, satisfy both `Iterator`\n * and `Iterable`).\n *\n * If it is an `AsyncIterator` but not `AsyncIterable`, or `AsyncIterable` but not `AsyncIterator`,\n * it is wrapped in an async generator. This generator is __not__ enhanced. Use [[Async.enhance]] on the result if\n * you need an enhanced generator.\n * @param i\n */\nexport function toAsyncGenerator<T, TReturn, TNext>(i: Genable<T, Async, TReturn, TNext>|Genable<T, Sync, TReturn, TNext>):\n    AsyncGenerator<T, TReturn, TNext>\n{\n    if (isAsyncGenerator(i)) return i;\n    if (isAsyncIterator(i)) {\n        const it = i;\n        async function* wrap() {\n            while (true) {\n                const r = await it.next();\n                if (r.done) return r.value;\n                yield r.value;\n            }\n        }\n        return wrap();\n    } else if (isAsyncIterable(i)) {\n        return toAsyncGenerator(i[Symbol.asyncIterator]()) as AsyncGenerator<T, TReturn, TNext>;\n    } else if (isIterable(i)) {\n        return toAsyncGenerator(i[Symbol.iterator]() as Iterator<T, TReturn, TNext>);\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\n/**\n * Coerce a sync [[Genable]] object to an `Iterator`. If the object is a `Generator` or an `Iterator` it is returned,\n * while if it is an `Iterable`, `[Symbol.iterator]`() is invoked.\n * @param i\n */\nexport function toIterator<T, TReturn, TNext>(i: Genable<T, Sync, TReturn, TNext>): Iterator<T, TReturn, TNext> {\n    if (isGenerator(i)) return i;\n    if (isIterator(i)) return i;\n    if (isIterable(i)) {\n        return i[Symbol.iterator]() as Iterator<T, TReturn, TNext>;\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\n\n/**\n * Coerce an async [[Genable]] object to an `AsyncIterator`. If the object is a `Generator` or an `Iterator` it is returned,\n * while if it is an `Iterable`, `[Symbol.iterator]`() is invoked.\n * @param i\n */\nexport function toAsyncIterator<T, TReturn, TNext = T>(i: Genable<T, Async, TReturn, TNext>): AsyncIterator<T, TReturn, TNext> {\n    if (isAsyncGenerator(i)) return i;\n    if (isAsyncIterable(i)) {\n        return i[Symbol.asyncIterator]() as AsyncIterator<T, TReturn, TNext>;\n    } else if (isIterable(i)) {\n        return asyncAdaptor(toIterator(i));\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\nconst asyncAdaptor = <T, TReturn, TNext>(i: Iterator<T, TReturn, TNext>):\n    AsyncGenerator<T, TReturn, TNext> =>\n{\n    const it = i as unknown as AsyncIterator<T>;\n    let self: AsyncGenerator<T> & {returning?: any};\n    async function* asyncAdaptor(): AsyncGenerator<T> {\n        let nr: any;\n        let done = false;\n        try {\n            while (true) {\n                const r = await Promise.resolve(it.next());\n                if (r.done) {\n                    done = true;\n                    return r.value;\n                }\n                try {\n                    nr = yield r.value;\n                } catch (e) {\n                    await it.throw?.(e);\n                    throw(e);\n                }\n            }\n        } finally {\n            if (!done) {\n                await i.return?.(self.returning);\n            }\n        }\n    }\n    return self = asyncAdaptor();\n};\n\n/**\n * Coerce a [[Genable]] object to `Iterable`. If it is already an `Iterable`, it is returned\n * unchanged. If it is an `Iterator`, it is wrapped in an object with a `[Symbol.iterator]`\n * method that returns the supplied iterator.\n * @param i\n */\nexport function toIterable<T, TReturn = T, TNext = T>(i: Genable<T,Sync,TReturn,TNext>):\n    FullIterable<T, Sync, TReturn, TNext>\n{\n    if (isIterable(i)) return i as FullIterable<T, Sync, TReturn, TNext>;\n    return {\n        [Symbol.iterator]: () => i\n    } as FullIterable<T, Sync, TReturn, TNext>;\n}\n\n\n/**\n * Coerce a [[Genable]] object to `AsyncIterable`. If it is already an `AsyncIterable`, it is returned\n * unchanged. If it is an `AsyncIterator`, it is wrapped in an object with a `[Symbol.asyncIterator]`\n * method that returns the supplied iterator.\n * @param i\n */\nexport function toAsyncIterable<T, TReturn, TNext>(i: Genable<T, Async, TReturn, TNext>):\n    FullIterable<T, Async, TReturn, TNext>\n{\n    if (isAsyncIterable<T, TReturn, TNext>(i)) return i;\n    if (isIterable<T, TReturn, TNext>(i)) {\n        return toAsyncIterable_adaptor<T, TReturn, TNext>(i) as\n            FullIterable<T, Async, TReturn, TNext>;\n    }\n    return {\n        [Symbol.asyncIterator]: () => i\n    } as FullIterable<T, Async, TReturn, TNext>;\n}\nasync function* toAsyncIterable_adaptor<T, TReturn, TNext>(iterable: Iterable<T>):\n    AsyncGenerator<T, TReturn, TNext>\n{\n    const it = iterable[Symbol.iterator]();\n    let nr: any = undefined;\n    while (true) {\n        const r = await it.next(nr);\n        if (r.done) return r.value;\n        nr = yield r.value;\n    }\n}\n\n// noinspection JSUnusedGlobalSymbols\n/**\n * Similar to [[toGenerator]], but does not require the presence of `Generator.return` or `Generator.throw` methods.\n * @param i\n */\nexport function toIterableIterator<T, TReturn = T, TNext = T>(i: Genable<T, Sync, TReturn, TNext>): FullIterableIterator<T, Sync, TReturn, TNext> {\n    if (isIterable(i) && isIterator(i)) return i as FullIterableIterator<T, Sync, TReturn, TNext>;\n    if (isIterable(i)) {\n        // Invoke [Symbol.iterator]() just once, on first use.\n        let _it: Iterator<T>|undefined = undefined;\n        const it = () => _it ?? (_it = i[Symbol.iterator]());\n        const iit: FullIterableIterator<T, Sync, TReturn, TNext> = {\n            [Symbol.iterator]: () => iit,\n            next: (val?: TNext) => it().next(val as undefined),\n            return: it().return && ((val) => it().return!(val)),\n            throw: it().throw && ((val) => it().throw!(val))\n        };\n        return iit;\n    }\n    if (isIterator(i)) {\n        const iit: FullIterableIterator<T, Sync, TReturn, TNext> = {\n            [Symbol.iterator]: () => iit,\n            next: (val?: TNext) => i.next(val!),\n            return: i.return && ((val) => i.return!(val)),\n            throw: i.throw && ((val) => i.throw!(val))\n        }\n        return iit;\n    }\n    throw new Error(`Not iterator nor iterable: ${i}`);\n}\n\n\n/**\n * Similar to [[toAsyncGenerator]], but does not require the presence of `AsyncGenerator.return` or\n * `AsyncGenerator.throw` methods.\n * @param i\n */\nexport function toAsyncIterableIterator<T, TReturn, TNext>(i: Genable<T, Async, TReturn, TNext>):\n    FullIterableIterator<T, Async, TReturn, TNext>\n{\n    if (isAsyncIterable<T, TReturn, TNext>(i) && isAsyncIterator<T, TReturn, TNext>(i)) {\n        return i as unknown as FullIterableIterator<T, Async, TReturn, TNext>;\n    }\n    if (isAsyncIterable<T, TReturn, TNext>(i)) {\n        // Invoke [Symbol.iterator]() just once, on first use.\n        let _it: AsyncIterator<T, TReturn, TNext>|undefined = undefined;\n        const it = () => _it ?? (_it = i[Symbol.asyncIterator]() as AsyncIterator<T, TReturn, TNext>);\n        const iit: AsyncIterableIterator<T> = {\n            [Symbol.asyncIterator]: () => iit,\n            next: () => it().next(),\n            return: it().return && ((val) => it().return!(val)),\n            throw: it().throw && ((val) => it().throw!(val))\n        };\n        return iit;\n    }\n    if (isIterable<T, TReturn, TNext>(i)) {\n        return toAsyncIterable_adaptor(i);\n    }\n    if (isAsyncIterator(i)) {\n        const iit: AsyncIterableIterator<T> = {\n            [Symbol.asyncIterator]: () => iit,\n            next: (val: any) => i.next(val),\n            return: i.return && ((val) => i.return!(val)),\n            throw: i.throw && ((val) => i.throw!(val))\n        }\n        return iit;\n    }\n    throw new Error(`Not iterator nor iterable: ${i}`);\n}\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `Iterator` protocol (has a `next()` method).\n *\n * Note: There is no way to statically distinguish between an `Iterator` and an `AsyncIterator`. You will get\n * runtime errors if you don't anticipate the distinction.\n * @param i\n */\nexport const isIterator = <K, KReturn = K, KNext = K>(i: Iterable<K> | FullIterable<K, Sync, KReturn, KNext> | any):\n    i is Iterator<K, KReturn, KNext> =>\n        i && typeof i.next === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `AsyncIterator` protocol (has a `next()` method).\n *\n * Note: There is no way to statically distinguish between an `Iterator` and an `AsyncIterator`. You will get\n * runtime errors if you don't anticipate the distinction.\n * @param i\n */\nexport const isAsyncIterator = <K, KReturn = K, KNext = K>(i: AsyncIterable<K> | AsyncIterator<K, KReturn, KNext>| any):\n    i is AsyncIterator<K, KReturn, KNext> =>\n        i && typeof i.next === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `Iterable` protocol (has a `[Symbol.iterator]`\n * method).\n * @param i\n */\nexport const isIterable = <K, KReturn = K, KNext = K>(i: Iterable<K> | FullIterable<K, Sync, KReturn, KNext> | any): i is FullIterable<K, Sync, KReturn, KNext>  =>\n    i && typeof i[Symbol.iterator] === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `AsyncIterable` protocol (has a `[Symbol.asyncIterator]`\n * method).\n * @param i\n */\nexport const isAsyncIterable = <K, KReturn = K, KNext = K>(i: AsyncIterable<K> | FullIterable<K, Async, KReturn, KNext> | any):\n    i is FullIterable<K, Async, KReturn, KNext> =>\n        i && typeof i[Symbol.asyncIterator] === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `Iterable` protocol (has a `[Symbol.iterator]`\n * method) and the `Iterator` protocol (a next() method).\n * @param i\n */\nexport const isIterableIterator = <K, KReturn = K, KNext = K>(i: Iterable<K>|Iterator<K, KReturn, KNext>|any):\n    i is FullIterableIterator<K, Sync, KReturn, KNext> =>\n        isIterator(i) && isIterable(i);\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `AsyncIterable` protocol (has a `[Symbol.asyncIterator]`\n * method) and the `AsyncIterator` protocol (a next() method).\n * @param i\n */\nexport const isAsyncIterableIterator = <K, KReturn = K, KNext = K>(i: Iterable<K>|Iterator<K, KReturn, KNext>|any):\n    i is FullIterableIterator<K, Async, KReturn, KNext> =>\n        isAsyncIterator(i) && isAsyncIterable(i);\n\n/**\n * Wrap a function in a catch block.\n * @param f\n * @param onError Called when an error is thrown. The return value is returned. If not supplied, undefined is returned.\n */\nexport const doCatch = <A extends any[], R>(f: (...args: A) => R, onError?: (e: Error) => R):\n    ((...args: A) => (R | undefined)) => {\n    return (...args: A) => {\n        try {\n            return f(...args);\n        } catch (e) {\n            return onError?.(e);\n        }\n    };\n};\n","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * This provides the trampoline methods that are shared between synchronous and\n * asynchronous enhanced generators. Methods dispatch to {@link Sync} or {@link Async}\n * as appropriate.\n *\n * This becomes part of the prototype chain of enhanced generator instances. It does\n * __not__ modify any global prototypes.\n *\n * You should not need to reference this directly. In Typescript, if you need a\n * type that covers both sync and async enhanced generators, use {@link Enhanced} (for,\n * generators) or the {@link GeneratorOps} interface (for the functional interface).\n *\n * @packageDocumentation\n * @module enhancements\n * @preferred\n */\n\nimport {Async, Enhanced, FlatGen, Genable, GeneratorOps, IndexedFn, IndexedPredicate, Reducer, ReturnValue, SyncType, UnwrapArray} from \"./types\";\n\n/**\n * Enhancements for generators\n */\n\nexport type {Enhanced} from './types';\n\n/**\n * The trampoline methods that link enhanced generators to [[Sync]] or [[Async]]\n * methods.\n */\nexport abstract class Enhancements<\n        T, TReturn, TNext, S extends SyncType\n        >\n{\n    abstract _impl: GeneratorOps<S>;\n\n    // Set on a call to return().\n    returning?: any;\n\n    abstract next(...arg: [] | [arg: TNext]):\n        S extends Async\n            ? Promise<IteratorResult<T, TReturn>>\n            : IteratorResult<T, TReturn>;\n\n    abstract return(value: TReturn):\n        S extends Async\n            ? Promise<IteratorReturnResult<TReturn>>\n            : IteratorReturnResult<TReturn>;\n\n    abstract throw(e: any):\n        S extends Async\n            ? Promise<IteratorReturnResult<TReturn>>\n            : IteratorReturnResult<TReturn>;;\n\n    abstract [Symbol.iterator]:\n        S extends Async\n            ? undefined\n            : () => this & IterableIterator<T>;\n\n    abstract [Symbol.asyncIterator]:\n        S extends Async\n            ? () => this & AsyncIterableIterator<T>\n            : undefined;\n\n    [Symbol.toStringTag]:\n        S extends Async\n            ? 'EnhancedAsyncGenerator'\n            : 'EnhancedGenerator';\n\n    /**\n     * Return all of the values from this generator as an array. You do not want to call this on an\n     * infinite generator (for obvious reasons); consider using [[EnhancedGenerator.slice]] or\n     * [[EnhancedGenerator.limit]] to limit the size before calling this.\n     */\n    asArray(): ReturnValue<T[], S> {\n        return this._impl.asArray<T, TReturn, TNext>(this);\n    }\n\n    /**\n     * Limit the number of values that can be generated. A `RangeError` is thrown if this limit is\n     * exceeded. See [[EnhancedGenerator.slice]] if you want to truncate.\n     * @param max\n     */\n    limit(max: number): Enhanced<T, S, TReturn, TNext> {\n        return this._impl.limit(max, this);\n    }\n\n    /**\n     * Operate on each value produced by this generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @param thisArg Value to be supplied as context `this` for function _f_.\n     */\n    forEach(f: IndexedFn<T, void, S>, thisArg?: any): void {\n        this._impl.forEach<T, TReturn, TNext>(f, thisArg, this);\n    }\n\n    /**\n     * Apply the function to each value yielded by this generator. It is called with two arguments,\n     * the value yielded, and a sequential index. The return value is a generator that yields the\n     * values produced by the function.\n     * @param f\n     * @param thisArg Optional value to be supplied as context `this` for function _f_.\n     */\n    map<V>(f: IndexedFn<T, V, S>, thisArg?: any): Enhanced<V, S, TReturn, TNext> {\n        return this._impl.map(f, thisArg, this);\n    }\n\n\n    /**\n     * Return a new [[EnhancedGenerator]] that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     */\n    filter(f: IndexedPredicate<T, S>, thisArg?: any): Enhanced<T, S, TReturn, TNext> {\n        return this._impl.filter(f, thisArg, this);\n    }\n\n    /**\n     * Flatten the values yielded by this generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param depth (default = 1)\n     */\n    flat<D extends number>(depth: D = 1 as D): Enhanced<S, FlatGen<T, D>, TReturn, TNext> {\n        return this._impl.flat<D, T, TReturn, TNext>(depth, this);\n    }\n\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a generator that yields the individual values at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param depth\n     */\n    flatMap<D extends number = 1>(f: IndexedFn<T, FlatGen<T, D>, S>, depth: D = 1 as D):\n        Enhanced<S, FlatGen<T, D>, TReturn, TNext>\n    {\n        return this._impl.flatMap<D, T, FlatGen<T, D>, TReturn, TNext>(f, depth, this);\n    }\n\n    /**\n     * Return a new [[EnhancedGenerator]] that only yields the indicated values, skipping _start_ initial values\n     * and continuing until the _end_.\n     * @param start\n     * @param end\n     */\n    slice(start: number = 0, end: number = Number.POSITIVE_INFINITY): Enhanced<T, S, TReturn | undefined, TNext> {\n        return this._impl.slice(start, end, this);\n    }\n\n    /**\n     * Concatenates generators (or iterators or iterables).\n     *\n     * Ensures that any supplied generators are terminated when this is terminated.\n     * @param gens zero or more additional [[Genable]] to provide values.\n     */\n\n    concat<T, TReturn, TNext>(...gens: Array<Genable<T, S, TReturn, TNext>>):\n        Enhanced<T, S, TReturn | void, TNext>\n    {\n        const self = this as UnwrapArray<typeof gens>;\n        return this._impl.concat(self, ...gens);\n    }\n\n\n    /**\n     * Like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\") is omitted\n     * because there is no array.\n     * @param f\n     */\n    reduce<A, T, TReturn, TNext>(f: Reducer<A, T, T, S>): ReturnValue<A, S>;\n    /**\n     * Like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\") is omitted\n     * because there is no array.\n     * @param f\n     * @param init\n     */\n    reduce<A, T, TReturn = T, TNext = T>(f: Reducer<A, T, A, S>, init: A): ReturnValue<A, S>;\n    reduce<A>(f: Reducer<A, T, A, S>, init?: A): ReturnValue<A, S> {\n        return this._impl.reduce<A, T, TReturn, TNext>(f, init as A, this);\n    }\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    some<T>(p: IndexedPredicate<T, S>, thisArg?: any): ReturnValue<boolean, S> {\n        // Why is type typecast to Genable needed here?\n        // Yet the seemingly identical case of 'every' below does not?\n        return this._impl.some(p, thisArg, this as Genable<T, S, TReturn, TNext>);\n    }\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    every(p: IndexedPredicate<T, S>, thisArg?: any): ReturnValue<boolean, S> {\n        return this._impl.every(p, thisArg, this as Genable<T, S, TReturn, TNext>);\n    }\n\n\n    /**\n     * Returns a new generator that repeats the last value returned by this (or `undefined` if this\n     * did not return any values).\n     *\n     * @param max\n     */\n    repeatLast(max: number = Number.POSITIVE_INFINITY): Enhanced<T, S, TReturn | void, TNext> {\n        return this._impl.repeatLast(this, max);\n    }\n\n\n    /**\n     * Returns a new generator that repeats the supplied value after this generator\n     * completes.\n     *\n     * @param value the value to repeat\n     * @param repetitions The number repetitions; the default is infinite.\n     */\n\n    repeat<N>(value: N, repetitions: number = Number.POSITIVE_INFINITY): Enhanced<T | N, S, void, TNext> {\n        const tail = this._impl.repeat<T|N, void, TNext>(value, repetitions);\n        const result = this._impl.concat(\n            this as Genable<T|N, S, undefined, TNext>,\n            tail as Genable<T|N, S, undefined, TNext>\n        );\n        return result as Enhanced<T | N, S, undefined, TNext>;\n    }\n\n    /**\n     * Combines this generator with additional ones, returning a generator that produces a tuple with\n     * each of their results, with this generator's result first.\n     *\n     * Terminates when any generator terminates. To get other behaviors, use with [[EnhancedGenerator.repeat]] or\n     * [[EnhancedGenerator.repeatLast]].\n     * @param gens\n     */\n\n    zip<G extends (Genable<T, S, TReturn, TNext>)[], T, TReturn, TNext>(...gens: G):\n        Enhanced<Array<T>, S, TReturn, TNext>\n    {\n        return this._impl.zip(this as Genable<T, S, TReturn, TNext>, ...gens) as\n            Enhanced<Array<T>, S, TReturn, TNext>;\n    }\n\n    /**\n     * Trivial, but handy, same as **Array.prototype.join**.\n     * @param sep (default = ',').\n     *\n     * See also [[EnhancedGenerator.join]]\n     */\n    join(sep?: string): ReturnValue<string, S> {\n        return this._impl.join(this, sep);\n    }\n\n    /**\n     * Sorts the supplied values and returns a sorted array.\n     * @param cmp a comparison function\n     */\n    sort(cmp?: (a: T, b: T) => number): ReturnValue<T[], S> {\n        return this._impl.sort(cmp)(this as Genable<T, S, TReturn, TNext>);\n    }\n}\n","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * This entry point loads synchronous extended generators\n * @packageDocumentation\n * @module sync\n * @preferred\n */\n\nimport type {Enhanced, FlatGen, Genable, GeneratorOps, GenOp, GenOpValue, GenVoid, IndexedFn, IndexedPredicate, Reducer, ReturnValue, UnwrapArray} from \"./types\";\n// Should be 'import type' but that makes TS insist it can't be a value here even after defining it.\nimport {Sync} from './types';\nimport {doCatch, isGenable, isGenerator, isIterable, isIterator, toGenerator, toIterable, toIterator} from \"./functions\";\nimport {Enhancements} from \"./enhancements\";\n\n/**\n * An extension to generators, that provides for operations like:\n * * map<T, R>(gen: Generator<T>) => (fn: T => R) => Generator<R>\n * * EnhancedGenerator<T>.map<R>(fn: T => R) => Generator<R>\n * @packageDocumentation\n * @module Generators\n * @preferred\n */\n\nclass Sync_ implements GeneratorOps<Sync> {\n    /**\n     * Return a generator that yields the supplied values.\n     * @param values\n     */\n    of<T extends any[], TReturn, TNext>(...values: T):\n        Enhanced<UnwrapArray<T>, Sync, TReturn, TNext>\n    {\n        return this.enhance(values);\n    }\n    /**\n     * Return all of the values from this generator as an array. You do not want to call this on an\n     * infinite generator (for obvious reasons); consider using [[EnhancedGenerator.slice]] or\n     * [[EnhancedGenerator.limit]] to limit the size before calling this.\n     */\n    asArray<T, TReturn, TNext>(gen: Genable<T, Sync, TReturn, TNext>):\n        T[]\n    {\n        return [...toIterable<T, TReturn, TNext>(gen)];\n    };\n\n    limit<T, TReturn, TNext>(max: number, gen: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<T, Sync, TReturn, TNext>;\n    limit(max: number): GenOp<Sync>;\n\n    limit<T, TReturn, TNext>(max: number, gen?: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<T, Sync, TReturn, TNext>\n        | GenOp<Sync>\n    {\n        let self: EnhancedGenerator<T, TReturn, TNext>;\n        function *limit<X, XReturn, XNext>(gen: Iterator<X, XReturn, XNext>): Generator<X, XReturn, XNext> {\n            let nr: XNext;\n            let limited: boolean = false;\n            try {\n                for (let i = 0; i < max; i++) {\n                    const r = gen.next(nr!);\n                    if (r.done) {\n                        return r.value;\n                    }\n                    try {\n                        nr = yield r.value;\n                    } catch (e) {\n                        gen.throw?.(e);\n                    }\n                }\n                limited = true;\n                const err = new RangeError(`Generator produced excessive values > ${max}.`);\n                gen.throw?.(err);\n                throw err;\n            } finally {\n                if (!limited) {\n                    gen.return?.(self?.returning);\n                    // Even if the supplied generator refuses to terminate, we terminate.\n                }\n            }\n        }\n        if (gen) {\n            return self = this.enhance(limit(toIterator(gen)));\n        }\n        return <X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) =>\n            this.enhance(limit(toIterator(gen)));\n    }\n\n    forEach<T, TReturn, TNext>(f: IndexedFn<T, void, Sync>, thisArg: any, gen: Genable<T, Sync, TReturn, TNext>):\n        GenVoid<Sync>;\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @param gen the generator.\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T, TReturn, TNext>(f: IndexedFn<T, void, Sync>, gen: Genable<T, Sync, TReturn, TNext>):\n        GenVoid<Sync>;\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @param thisArg Optional value to be supplied as context `this` for function _f_.\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T>(f: IndexedFn<T, void, Sync>, thisArg?: any):\n        <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>) =>\n            GenVoid<Sync>;\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T>(f: IndexedFn<T, void, Sync>):\n        <TReturn, TNext>(gen: Genable<T, Sync, TReturn, TNext>, thisArg?: any) =>\n            GenVoid<Sync>;\n\n    forEach<T, TReturn, TNext>(\n            f: IndexedFn<T, void, Sync>,\n            thisArgOrGen?: Genable<T, Sync, TReturn, TNext>|any,\n            gen?: Genable<T, Sync, TReturn, TNext>\n        )\n    {\n        const forEach = <XReturn, XNext>(f: IndexedFn<T, void, Sync>, thisArg: any, gen: Genable<T, Sync, XReturn, XNext>):\n                GenVoid<Sync> =>\n            {\n                const it = toIterator(gen);\n                let idx = 0;\n                while (true) {\n                    const r = it.next();\n                    if (r.done) return;\n                    f.call(thisArg, r.value, idx++);\n                }\n            };\n        if (gen) return forEach(f, thisArgOrGen, gen);\n        if (isGenable<T>(thisArgOrGen)) return forEach(f, undefined, thisArgOrGen);\n        return <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, thisArg?: any) =>\n            forEach<XReturn, XNext>(f, thisArg ?? thisArgOrGen, gen);\n    }\n\n    map<T, V>(f: IndexedFn<T, V, Sync>):\n        GenOpValue<Sync, T, V>;\n    map<T, V>(f: IndexedFn<T, V, Sync>, thisArg?: any):\n        GenOpValue<Sync, T, V>;\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Sync>, gen: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<V, Sync, TReturn, TNext>;\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Sync>, thisArg: any, gen: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<V, Sync, TReturn, TNext>;\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Sync>, thisArg?: any | Genable<T, Sync, TReturn, TNext>, iter?: Genable<T, Sync, TReturn, TNext>):\n        EnhancedGenerator<V, TReturn, TNext>\n        | (<XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>) => EnhancedGenerator<V, XReturn, XNext>)\n        | (<XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, thisArg?: any) => EnhancedGenerator<V, XReturn, XNext>)\n    {\n        const map = <XReturn, XNext>(thisArg: any, iter: Genable<T, Sync, XReturn, XNext>) => {\n            const gen = toGenerator(iter);\n            let self: EnhancedGenerator<V, XReturn, XNext>;\n            function* map(): Generator<V, XReturn, XNext> {\n                let nr: XNext;\n                let idx = 0;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = gen.next(nr!);\n                                if (r.done) return r.value;\n                                const v: V = f.call(thisArg, r.value, idx++);\n                                try {\n                                    nr = yield v;\n                                } catch (e) {\n                                    gen.throw(e);\n                                }\n                            }\n                        } finally {\n                            const x = gen.return(self?.returning);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (!x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            return self = this.enhance(map());\n        };\n        if (iter) return map(thisArg, iter);\n        if (isGenable<T, TReturn, TNext>(thisArg)) return map(undefined, thisArg);\n        return <XReturn, XNext>(gen: Genable<T, Sync,XReturn, XNext>, genThisArg?: any) =>\n            map(genThisArg ?? thisArg, gen);\n    }\n\n    /**\n     * Return a function that filters a [[Genable]] and yields a new [[EnhancedGenerator]]\n     * that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @typeParam T the type of value.\n     */\n    filter<T>(f: IndexedPredicate<T, Sync>):\n        GenOpValue<Sync, T, T>;\n\n    /**\n     * Return a function that filters a [[Genable]] and yields a new [[EnhancedGenerator]]\n     * that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     * @typeParam T the type of value.\n     */\n    filter<T>(f: IndexedPredicate<T, Sync>, thisArg: any):\n        GenOpValue<Sync, T, T>;\n\n    /**\n     * Return a new [[EnhancedGenerator]] that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param iter a [[Genable|Genable<T>]]\n     * @typeParam T the type of value.\n     */\n    filter<T, TReturn, TNext>(f: IndexedPredicate<T, Sync>, iter: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<T, Sync, TReturn, TNext>;\n    /**\n     * Return a new [[EnhancedGenerator]] that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     * @param iter a [[Genable|Genable<T>]]\n     * @typeParam T the type of value.\n     */\n    filter<T, TReturn, TNext>(f: IndexedPredicate<T, Sync>, thisArg: any, iter: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<T, Sync, TReturn, TNext>;\n\n    /**\n     * Return a function that filters a [[Genable]] and yields a new [[EnhancedGenerator]]\n     * that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     * @param iter the [[Genable]] to filter.\n     * @typeParam T the type of value.\n     */\n    filter<T, TReturn, TNext>(\n        f: IndexedPredicate<T, Sync>,\n        thisArg?: any | Genable<T, Sync, TReturn, TNext>,\n        iter?: Genable<T, Sync, TReturn, TNext>\n    ):\n        Enhanced<T, Sync, TReturn, TNext>\n        | GenOpValue<Sync, T, T>\n    {\n        const filter = <XReturn, XNext>(thisArg: any, iter: Genable<T, Sync, XReturn, XNext>) => {\n            const gen = toGenerator(iter);\n            let self: EnhancedGenerator<T, TReturn, TNext>;\n            function* filter<V>(f: IndexedPredicate<T, Sync>): Generator<T> {\n                let nr: any = undefined;\n                let idx = 0;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = gen.next(nr);\n                                if (r.done) return r.value;\n                                if (f.call(thisArg, r.value, idx++)) {\n                                    try {\n                                        nr = yield r.value;\n                                    } catch (e) {\n                                        gen.throw(e);\n                                    }\n                                }\n                            }\n                        } finally {\n                            const x = gen.return?.(self?.returning);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (!x?.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            return self = this.enhance(filter(f));\n        };\n\n        if (iter) return filter(thisArg, iter);\n        if (isGenable<T>(thisArg)) return filter(undefined, thisArg);\n        return <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, genThisArg?: any) =>\n            filter(genThisArg ?? thisArg, gen);\n    }\n\n    /**\n     * Flatten the values yielded by the generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param depth\n     */\n    flat<D extends number>(depth: D):\n        <X, XReturn = X, XNext = X>(gen: Genable<X, Sync, XReturn, XNext>) =>\n            Enhanced<Sync, FlatGen<X, D>, XReturn, XNext>;\n    /**\n     * Flatten the values yielded by the generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param depth\n     * @param gen\n     */\n    flat<D extends number, T, TReturn, TNext>(depth: D, gen: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<Sync, FlatGen<T, D>, TReturn, TNext>;\n    /**\n     * Flatten the values yielded by the generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param gen\n     * @param depth default = 1\n     */\n    flat<D extends number, T, TReturn, TNext>(gen: Genable<T, Sync, TReturn, TNext>, depth?: D):\n        Enhanced<Sync, FlatGen<T, D>, TReturn, TNext>;\n\n    flat<D extends number, T, TReturn, TNext>(\n        depth: D|Genable<T, Sync, TReturn, TNext>,\n        gen?: Genable<T, Sync, TReturn, TNext> | D\n    ):\n        Enhanced<Sync, FlatGen<T, D>, TReturn, TNext>\n        | (<X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) => Enhanced<Sync, FlatGen<X, D>, XReturn, XNext>)\n    {\n        const flat = <X, XReturn, XNext>(depth: D, gen: Genable<X, Sync, XReturn, XNext>) => {\n            let self: EnhancedGenerator<FlatGen<X, D>, XReturn, XNext>;\n            const gens = new Set<Generator>();\n            if (isGenerator(gen)) gens.add(gen);\n\n            function* flat<D extends number>(it: Iterator<unknown, XReturn, XNext>, depth: D): Generator<FlatGen<X, D>, XReturn, XNext> {\n                let nr: any = undefined;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = it.next(nr);\n                                if (r.done) return r.value;\n                                const v = r.value;\n                                if (isGenerator(v)) {\n                                    gens.add(v);\n                                }\n                                try {\n                                    if (depth > 0 && isIterator<unknown, XReturn, XNext>(v)) {\n                                        yield* flat(v, depth - 1);\n                                    } else if (depth > 0 && isIterable(v)) {\n                                        yield* flat(toIterator<unknown, XReturn, XNext>(v), depth - 1)\n                                    } else {\n                                        nr = yield r.value as FlatGen<T, D>;\n                                    }\n                                } catch (e) {\n                                    it.throw?.(e);\n                                }\n                            }\n                        } finally {\n                            const x = it.return?.(self?.returning);\n                            if (isGenerator(it)) gens.delete(it);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (x && !x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                            for (const g of gens) {\n                                g.return(self?.returning);\n                            }\n                        }\n                    }\n                }\n            }\n\n            return self = this.enhance(flat(toIterator(gen), depth));\n        }\n        if (typeof depth === 'number') {\n            if (gen) {\n                if (isGenable(gen)) {\n                    return flat(depth, gen);\n                } else {\n                    throw new TypeError(`Invalid Genable: ${gen}`);\n                }\n            }\n            return <X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) =>\n                flat(depth, gen);\n        } else if (isGenable(depth)) {\n            return flat((gen ?? 1) as D, depth);\n        }\n        throw new TypeError(`Illegal arguments to flat()`);\n    }\n\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a function that accepts a generator, and returns another generator that yields the individual value\n     * at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param depth\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T>(f: IndexedFn<T, R, Sync>, depth: D):\n        <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>) =>\n            Enhanced<R, Sync, XReturn, XNext>;\n\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a function that accepts a generator, and returns another generator that yields the individual value\n     * at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T>(f: IndexedFn<T, R, Sync>):\n        <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, depth?: D) =>\n            Enhanced<R, Sync, XReturn, XNext>;\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a generator that yields the individual values at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param gen\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T, TReturn, TNext>(f: IndexedFn<T, R, Sync>, gen: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<R, Sync, TReturn, TNext>;\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a generator that yields the individual values at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param depth\n     * @param gen\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T, TReturn, TNext>(f: IndexedFn<T, R, Sync>, depth: D, gen: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<R, Sync, TReturn, TNext>;\n\n    flatMap<D extends number, R extends FlatGen<T, D>, T, TReturn, TNext>(\n            f: IndexedFn<T, R, Sync>,\n            depthOrGen?: D | Genable<T, Sync, TReturn, TNext>,\n            gen?: Genable<T, Sync, TReturn, TNext>\n        ):\n            Enhanced<R, Sync, TReturn, TNext>\n            | (\n                <X, Y extends FlatGen<T, D>, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) =>\n                Enhanced<Y, Sync, XReturn, XNext>\n            )\n            | (\n                <X, Y extends FlatGen<T, D>, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>, depth?: D) =>\n                    Enhanced<Y, Sync, XReturn, XNext>\n            )\n    {\n        const flatMap = <X, XReturn, XNext>(depth: D, gen: Genable<X, Sync, XReturn, XNext>) => {\n            let self: Enhanced<FlatGen<X, D>, Sync, XReturn, XNext>;\n            let idx = 0;\n\n            function* flatMap<D extends number, Y, YReturn, YNext>(it: Iterator<Y, YReturn, YNext>, depth: D):\n                Generator<FlatGen<X, D>, XReturn, XNext>\n            {\n                let nr: YNext;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = it.next(nr!);\n                                if (r.done) return r.value as unknown as XReturn;\n                                const v = f(r.value as unknown as T, idx++);\n                                try {\n                                    if (isIterator<unknown, XReturn, XNext>(v)) {\n                                        if (depth > 1) {\n                                            yield* flatMap(v, depth - 1);\n                                        } else if (depth === 1) {\n                                            yield* toGenerator(v);\n                                        } else {\n                                            yield v;\n                                        }\n                                    } else if (isIterable(v)) {\n                                        if (depth > 1) {\n                                            yield* flatMap(toIterator<unknown, XReturn, XNext>(v), depth - 1);\n                                        } else if (depth === 1) {\n                                            yield* toGenerator(v);\n                                        } else {\n                                            yield v;\n                                        }\n                                    } else {\n                                        nr = (yield v) as unknown as YNext;\n                                    }\n                                } catch (e) {\n                                    it.throw?.(e);\n                                }\n                            }\n                        } finally {\n                            const x = it.return?.(self?.returning);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (x && !x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            return self = this.enhance(flatMap(toIterator(gen), depth));\n        }\n\n        if (isGenable(gen)) {\n            return flatMap(depthOrGen as D ?? 1 as D, gen);\n        } else if (isGenable( depthOrGen)) {\n            return flatMap(1 as D, depthOrGen);\n        }\n        return <X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>, depth?: D) =>\n            flatMap(depthOrGen ?? depth ?? 1 as D, gen);\n    }\n\n    /**\n     * Return a new [[EnhancedGenerator]] that only yields the indicated values, skipping _start_ initial values\n     * and continuing until the _end_.\n     * @param start\n     * @param end\n     */\n    slice<T>(start: number, end: number):\n        <X, XReturn, XNext>(iter: Genable<X, Sync, XReturn, XNext>) =>\n            Enhanced<X, Sync, XReturn | undefined, XNext>;\n\n    /**\n     * Return a new [[EnhancedGenerator]] that only yields the indicated values, skipping _start_ initial values\n     * and continuing until the _end_.\n     * @param start\n     * @param end\n     * @param iter\n     */\n    slice<T, TReturn, TNext>(start: number, end: number, iter: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<T, Sync, TReturn | undefined, TNext>;\n\n    slice<T, TReturn, TNext>(start: number, end: number, iter?: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<T, Sync, TReturn | undefined, TNext>\n        | (\n            <X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) =>\n                Enhanced<X, Sync, XReturn | undefined, XNext>\n        )\n    {\n        const slice = <X, XReturn, XNext>(iter: Genable<X, Sync, XReturn, XNext>):\n                Enhanced<X, Sync, XReturn | undefined, XNext> =>\n            {\n                const it = toIterator(iter);\n                function* slice(start: number, end: number) {\n                    for (let i = 0; i < start; i++) {\n                        const r = it.next();\n                        if (r.done) return r.value;\n                    }\n                    if (end === Number.POSITIVE_INFINITY) {\n                        yield* toIterable(it);\n                    } else {\n                        let nv: XNext;\n                        while (true) {\n                            try {\n                                for (let i = start; i < end; i++) {\n                                    const r = it.next(nv!);\n                                    if (r.done) return r.value;\n                                    try {\n                                        nv = yield r.value;\n                                    } catch (e) {\n                                        const re = it.throw?.(e);\n                                        if (re) {\n                                            if (re.done) return re.value;\n                                            nv = yield re.value;\n                                        }\n                                    }\n                                }\n                            } finally {\n                                const x = it.return?.();\n                                // If the wrapped generator aborted the return, we will, too.\n                                if (x && !x.done) {\n                                    // noinspection ContinueOrBreakFromFinallyBlockJS\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    return;\n                }\n                return this.enhance(slice(start, end));\n        };\n        if (!iter) return slice;\n        return slice(iter);\n    }\n\n    /**\n     * Concatenates generators (or iterators or iterables).\n     *\n     * Ensures that any supplied generators are terminated when this is terminated.\n     * @param gens zero or more additional [[Genable]] to provide values.\n     */\n    concat<\n        T, TReturn, TNext,\n        A extends Array<Genable<T, Sync, TReturn, TNext>>\n    >(...gens: A):\n        Enhanced<T, Sync, TReturn | void, TNext>\n    {\n        let self: Enhanced<T, Sync, TReturn | void, TNext>;\n        function* concat(): Generator<T, TReturn | void, TNext> {\n            let i = 0;\n            try {\n                for (; i < gens.length; i++) {\n                    yield* toIterable<T,TReturn, TNext>(gens[i]);\n                }\n            } finally {\n                // Terminate any remaining generators.\n                for (; i < gens.length; i++) {\n                    const g = gens[i];\n                    if (isGenerator(g)) {\n                        g.return(self?.returning);\n                    }\n                }\n            }\n        }\n        return self = this.enhance(concat()) ;\n    }\n\n    /**\n     * Reduces **gen** like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     * @param f\n     * @param gen\n     */\n    reduce<A, T, TReturn, TNext>(f: Reducer<A, T, T, Sync>, gen: Genable<T, Sync, TReturn, TNext>):\n        A;\n    /**\n     *\n     * Returns a reducer function that, when applied to a `Generator` **gen**, reduces **gen** like\n     * **Array.prototype.reduce**. The 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     *\n     * @param f\n     */\n    reduce<A, T, TReturn, TNext>(f: Reducer<A, T, T, Sync>):\n        (gen: Genable<T, Sync, TReturn, TNext>) =>\n            A;\n    /**\n     *\n     * Returns a reducer function that, when applied to a `Generator` **gen**, reduces **gen** like\n     * `Array.prototype.reduce`. The 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     *\n     * @param f\n     */\n    reduce<A, T>(f: Reducer<A, T, A, Sync>):\n        <TReturn, TNext>(init: A, gen: Genable<T, Sync, TReturn, TNext>) =>\n            A;\n\n    /**\n     * Reduces **gen** like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     * @param f\n     * @param init\n     * @param gen\n     */\n    reduce<A, T, TReturn, TNext>(f: Reducer<A, T, A, Sync>, init: A, gen: Genable<T, Sync, TReturn, TNext>):\n        A;\n\n    /**\n     * Returns a reducer function that, when applied to a `Generator` **gen**, reduces **gen** like\n     * `Array.prototype.reduce`. The 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     *\n     * Alternatively, the init value can be supplied along with the generator as a second argument.\n     * @param f\n     * @param init\n     */\n    reduce<A, T>(f: Reducer<A, T, A, Sync>, init: A):\n        <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>) =>\n            A;\n\n    reduce<A, T, TReturn, TNext>(\n        f: Reducer<A, T, A | T, Sync>,\n        initOrGen?: A | Genable<T, Sync, TReturn, TNext>,\n        gen?: Genable<T, Sync, TReturn, TNext>\n    ): A\n        | (<XHome, XNext>(gen: Genable<T, Sync, XHome, XNext>) => A)\n        | ((f: (acc: A, v: T) => A, init: A) => A)\n        | ((f: (acc: A | T, v: T) => A) => A)\n    {\n\n        const reduce = (init: A | undefined, it: Iterator<T,unknown,unknown>): A => {\n            let acc: A | T | undefined = init;\n            if (acc === undefined) {\n                const r = it.next();\n                if (r.done) throw new TypeError(`No initial value in reduce`);\n                acc = r.value;\n            }\n            while (true) {\n                const r = it.next();\n                if (r.done) return acc as A;\n                acc = f(acc, r.value);\n            }\n        };\n        if (isGenable(gen)) {\n            return reduce(initOrGen as A, toIterator(gen));\n        } else if (isGenable(initOrGen)) {\n            return reduce(undefined, toIterator(initOrGen));\n        }\n        return <XHome, XNext>(gen: Genable<T, Sync, XHome, XNext>, init?: A) =>\n            reduce(init ?? initOrGen, toIterator(gen));\n    }\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    some<T>(p: IndexedPredicate<T, Sync>, thisArg?: any):\n        <XHome, XNext>(gen: Genable<T, Sync, XHome, XNext>) =>\n            ReturnValue<boolean, Sync>;\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     */\n    some<T>(p: IndexedPredicate<T, Sync>):\n        <XHome, XNext>(gen: Genable<T, Sync, XHome, XNext>, thisArg?: any) =>\n            ReturnValue<boolean, Sync>;\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param gen the generator\n     */\n    some<T, TReturn, TNext>(p: IndexedPredicate<T, Sync>, gen: Genable<T, Sync, TReturn, TNext>):\n        ReturnValue<boolean, Sync>;\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     * @param gen the generator\n     */\n    some<T, TReturn, TNext>(p: IndexedPredicate<T, Sync>, thisArg: any, gen: Genable<T, Sync, TReturn, TNext>):\n        ReturnValue<boolean, Sync>;\n\n    some<T, TReturn, TNext>(\n        pred: IndexedPredicate<T, Sync>,\n        thisOrGen?: any | Genable<T, Sync, TReturn, TNext>,\n        gen?: Genable<T, Sync, TReturn, TNext>\n    ):\n        ReturnValue<boolean, Sync>\n        | (<XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, thisArg?: any) =>\n            ReturnValue<boolean, Sync>)\n    {\n        const some = <XReturn, XNext>(thisArg: any, it: Iterator<T, XReturn, XNext>): boolean => {\n            let i = 0;\n            while (true) {\n                const r = it.next();\n                if (r.done) return false;\n                if (pred.call(thisArg, r.value, i++)) return true;\n            }\n        };\n        if (isGenable(gen)) {\n            return some(thisOrGen, toIterator(gen));\n        } else if (isGenable<T, TReturn, TNext>(thisOrGen)) {\n            return some(undefined, toIterator(thisOrGen));\n        } else {\n            return <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, thisArg?: any) =>\n                some<XReturn, XNext>(thisArg ?? thisOrGen, toIterator(gen));\n        }\n    }\n\n    /**\n     * Returns `false` and terminates the generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    every<T>(p: IndexedPredicate<T, Sync>, thisArg?: any):\n        <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>) =>\n            ReturnValue<boolean, Sync>;\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     */\n    every<T>(p: IndexedPredicate<T, Sync>):\n        <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext >, thisArg?: any) =>\n            ReturnValue<boolean, Sync>;\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param gen the generator\n     */\n    every<T, TReturn, TNext>(p: IndexedPredicate<T, Sync>, gen: Genable<T, Sync, TReturn, TNext>):\n        ReturnValue<boolean, Sync>;\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     * @param gen the generator\n     */\n    every<T, TReturn, TNext>(p: IndexedPredicate<T, Sync>, thisArg: any, gen: Genable<T, Sync, TReturn, TNext>):\n        ReturnValue<boolean, Sync>;\n\n    every<T, TReturn, TNext>(\n        pred: IndexedPredicate<T, Sync>,\n        genOrThis?: any | Genable<T, Sync, TReturn, TNext>,\n        gen?: Genable<T, Sync, TReturn, TNext>\n    ):\n        ReturnValue<boolean, Sync>\n        | (\n            <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>) =>\n                ReturnValue<boolean, Sync>\n        )\n    {\n        const every = <XReturn, XNext>(thisArg: any, it: Iterator<T, XReturn, XNext>): boolean => {\n            let i = 0;\n            while (true) {\n                const r = it.next();\n                if (r.done) return true;\n                if (!pred.call(thisArg, r.value, i++)) return false;\n            }\n        };\n        if (isGenable(gen)) {\n            return every(genOrThis, toIterator(gen));\n        } else if (isGenable(gen)) {\n            return <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, thisArg?: any) =>\n                every(thisArg ?? genOrThis, toIterator(gen));\n        }\n        throw new Error(`Invalid argument to every: ${gen ?? genOrThis}`);\n    }\n\n    /**\n     * Returns a new generator that repeats the last value returned by **gen** (or `undefined` if **gen**\n     * did not return any values).\n     *\n     * @param gen\n     * @param max\n     */\n    repeatLast<T, TReturn, TNext>(\n        gen: Genable<T, Sync, TReturn, TNext>,\n        max: number = Number.POSITIVE_INFINITY\n    ):\n        Enhanced<T, Sync, TReturn | void, TNext>\n    {\n        const it = toIterator(gen);\n        let nr: any;\n        let self: EnhancedGenerator<T, TReturn | void, TNext>;\n\n        function* repeatLast(): Generator<T, TReturn | void, TNext> {\n            try {\n                let last: T;\n                while (true) {\n                    const r = it.next(nr)\n                    if (r.done) break;\n                    try {\n                        nr = yield (last = r.value);\n                    } catch (e) {\n                        const re = it.throw?.(e);\n                        if (re) {\n                            if (re.done) break;\n                            yield last = re.value;\n                        }\n                    }\n                }\n                for (let i = 0; i < max; i++) {\n                    yield last!;\n                }\n            } finally {\n                it.return?.(self?.returning);\n            }\n        }\n\n        return self = this.enhance(repeatLast());\n    }\n\n    /**\n     * Returns a new generator that repeats the supplied value.\n     *\n     * @param value the value to repeat\n     * @param repetitions The number repetitions; the default is infinite.\n     */\n    repeat<T, TReturn, TNext>(value: T, repetitions: number = Number.POSITIVE_INFINITY):\n        Enhanced<T, Sync, TReturn | void, TNext>\n    {\n        function* repeat(): Generator<T, TReturn | void, TNext> {\n            for (let i = 0; i < repetitions; i++) {\n                yield value;\n            }\n        }\n\n        return this.enhance(repeat());\n    }\n\n    /**\n     * Combines generators, returning a generator that produces a tuple with each of their results.\n     *\n     * Terminates when the first generator terminates. To get other behaviors, use with [[EnhancedGenerator.repeat]] or\n     * [[EnhancedGenerator.repeatLast]].\n     * @param gens\n     */\n\n    zip<T, TReturn, TNext>(...gens: Array<Genable<T, Sync, TReturn, TNext>>):\n        Enhanced<Array<T>, Sync, TReturn, TNext>\n    {\n        if (gens.length === 0) return this.enhance([]);\n        const its = gens.map(toIterator);\n        let done = false;\n        let self: Enhanced<Array<T>, Sync, TReturn, TNext>;\n\n        function* zip2(): Generator<Array<T>, TReturn, TNext> {\n            try {\n                while (true) {\n                    let result: Array<T> = [];\n                    for (const g of its) {\n                        const r = g.next();\n                        if (r.done) {\n                            done = true;\n                            return r.value as TReturn;\n                        }\n                        (result as any[]).push(r.value);\n                    }\n                    try {\n                        yield result;\n                    } catch (e) {\n                        for (const g of gens) {\n                            try {\n                                // Weird need for a typecast here.\n                                (g as any).throw?.(e);\n                            } catch {\n                                // Ignore\n                            }\n                        }\n                        throw e;\n                    }\n                }\n            } finally {\n                if (!done) {\n                    for (const g of gens) {\n                        try {\n                            // Weird need for a typecast here.\n                            (g as any).return?.(self?.returning);\n                        } catch {\n                            // Ignore\n                        }\n                    }\n                }\n            }\n        }\n\n        return self = this.enhance(zip2());\n    }\n\n    /**\n     * Returns a function that joins the elements produced by a [[Genable]], analogous to `Array.prototype.join`.\n     * @param sep (default = ',')\n     */\n    join(sep: string):\n        <X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) =>\n            ReturnValue<string, Sync>;\n\n    /**\n     * Joins the elements produced by a [[Genable]], analogous to `Array.prototype.join`.\n     * @param gen\n     * @param sep\n     */\n    join<T, TReturn, TNext>(gen: Genable<T, Sync, TReturn, TNext>, sep?: string):\n        ReturnValue<string, Sync>;\n\n    join<T, TReturn, TNext>(\n        genOrSeparator: Genable<T, Sync, TReturn, TNext>|string,\n        sep?: string\n    ):\n        string\n        | (<X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) => string)\n    {\n        if (typeof genOrSeparator === 'string') {\n            sep = genOrSeparator;\n            return <X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) =>\n                this.join(gen, sep);\n        }\n        return [...toIterable(genOrSeparator)].join(sep);\n    }\n\n    /**\n     * Returns a new generator that returns values from each of the supplied sources as they are available.\n     * These will be taken in round-robin fashion from each non-terminated generator, until all have\n     * terminated. The yielded values will not be distinguished by which which source they are taken; for\n     * that, another method will be supplied.\n     *\n     * Any calls to `Generator.throw()` or `Generator.return()` will be passed to all non-terminated\n     * sources.\n     * @param sources\n     */\n\n    merge<T, TReturn, TNext>(...sources: Array<Genable<T, Sync, TReturn, TNext>>):\n        Enhanced<T, Sync, TReturn, TNext>\n    {\n        let self: Enhanced<T, Sync, TReturn, TNext>;\n        let gens: Array<Iterator<T, TReturn, TNext> | null> = sources.map(toIterator);\n        function* merge<X, XReturn, XNext>(gens: Array<Iterator<X, XReturn, XNext> | null>):\n            Generator<X, XReturn, XNext>\n        {\n            let done = false;\n            let running = true;\n            let nv: XNext;\n            try {\n                while (running) {\n                    running = false;\n                    for (let i = 0; i < gens.length; i++) {\n                        const g = gens[i];\n                        if (g) {\n                            const r = g.next(nv!);\n                            if (r.done) {\n                                gens[i] = null;\n                            } else {\n                                running = true;\n                                try {\n                                    nv = yield r.value;\n                                } catch (e) {\n                                    gens.forEach(doCatch(g => g?.throw?.(e)));\n                                }\n                            }\n                        }\n                    }\n                }\n                done = true;\n            } finally {\n                if (!done) {\n                    gens.forEach(doCatch(g => g?.return?.(self?.returning)));\n                }\n            }\n            return self?.returning;\n        }\n        return self = this.enhance(merge(gens));\n    }\n\n    /**\n     * Returns a function that sorts the supplied sources and returns a sorted array.\n     * @param cmp a comparison function\n     */\n    sort<T>(cmp?: ((a: T, b: T) => number)) {\n        return <TReturn, TNext>(...sources: Array<Genable<T, Sync, TReturn, TNext>>) => {\n            const result: T[] = this.merge(...sources).asArray();\n            return result.sort(cmp);\n        }\n    }\n\n    /**\n     * Enhance an existing generator (or iterator or iterable) to be a EnhancedGenerator.\n     * @param gen\n     */\n    enhance<T, TReturn, TNext>(gen: Genable<T, Sync, TReturn, TNext>):\n        EnhancedGenerator<T, TReturn, TNext>\n    {\n        const gen2 = toGenerator(gen) as Partial<EnhancedGenerator<T, TReturn, TNext>>;\n        const old = Object.getPrototypeOf(gen2);\n        const proto = Object.create(EnhancedGenerator.prototype);\n        proto.return = (v: TReturn) => (gen2.returning = v, old.return.call(gen2, v));\n        proto[Symbol.iterator] = () => gen2;\n        Object.setPrototypeOf(gen2, EnhancedGenerator.prototype);\n        return gen2 as EnhancedGenerator<T, TReturn, TNext>;\n    }\n}\n\n/**\n * Utilities to create and use generators which can be manipulated in various ways.\n *\n * Most methods come both as instance (prototype) methods and as static methods. They\n * provide equivalent functionality, but the static methods allow use on `Iterator` and\n * `Iterable` objects without first converting to a generator.\n *\n * The [[EnhancedGenerator.enhance]] method will add additional instance methods to\n * an ordinary generator's prototype (a new prototype, **not** modifying any global prototype!).\n * It can also be used to convert `Iterator` and `Iterable` objects to [[EnhancedGenerator]].\n *\n * For methods which return a EnhancedGenerator, care is take to propagate any `Generator.throw`\n * and `Generator.return` calls to any supplied generators, so they can properly terminate.\n *\n * The exception is [[EnhancedGenerator.flat]] (and by extension, [[EnhancedGenerator.flatMap]]), which cannot know what nested generators\n * they might encounter in the future. Any generators encountered so far will be terminated, however.\n *\n * @typeParam T the type of values returned in the iteration result.\n * @typeParam TReturn the type of values returned in the iteration result when the generator terminates\n * @typeParam TNext the type of value which can be passed to `.next(val)`.\n */\nexport abstract class EnhancedGenerator<T, TReturn, TNext>\n    extends Enhancements<T, TReturn, TNext, Sync>\n    implements Generator<T, TReturn, TNext>, Iterable<T>,\n        Iterator<T, TReturn, TNext>\n{\n    [Symbol.toStringTag]: 'EnhancedGenerator';\n}\n\n/**\n * Factory for synchronous generator operators. See [[GeneratorOps]] for details.\n */\nconst Sync: GeneratorOps<Sync> = new Sync_();\nexport {Sync};\n\nconst makeProto = (base: any) => {\n    const newProto = Object.create(base);\n    const inherit = (proto: any) => {\n        for (const k of Reflect.ownKeys(proto)) {\n            if (k !== 'constructor') {\n                newProto[k] = proto[k];\n            }\n        }\n    };\n    inherit(Enhancements.prototype);\n    return newProto;\n}\n\n/**\n * @internal\n * @constructor\n */\nfunction* Foo() {\n}\n\n/**\n * @internal\n */\nexport const GenProto = Object.getPrototypeOf(Foo());\n\n// Make EnhancedGenerator inherit generator methods.\nObject.setPrototypeOf(EnhancedGenerator.prototype, makeProto(GenProto));\nObject.defineProperty(EnhancedGenerator.prototype, '_impl', {\n    value: Sync,\n    writable: false,\n    enumerable: false,\n    configurable: false\n});\n","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * Enhanced range implementation.\n *\n * @packageDocumentation\n * @module range\n * @preferred\n */\n\nimport {EnhancedGenerator, Sync} from \"./sync\";\n\n/**\n * Produce numbers from __start__ to __end__ incremented by __step__.\n * Step may be positive or negative, but not zero.\n *\n * Produces an [[EnhancedGenerator]].\n * @param start (default = 0)\n * @param end   (default = `Number.MAX_SAFE_INTEGER`)\n * @param step  (default = 1)\n */\nexport const range = (start = 0, end = Number.MAX_SAFE_INTEGER, step = 1): EnhancedGenerator<number, void, void> => {\n    function* range2(start = 0, end = Number.MAX_SAFE_INTEGER, step = 1) {\n        let x = start;\n        if (step > 0) {\n            while (x < end) {\n                yield x;\n                x += step;\n            }\n        } else if (step < 0) {\n            while (x > end) {\n                yield x;\n                x += step;\n            }\n        } else {\n            throw new Error(\"Step must not be zero.\");\n        }\n    }\n    return Sync.enhance(range2(start, end, step));\n}\n","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * This entry point loads asynchronous extended generators\n * @packageDocumentation\n * @module async\n * @preferred\n */\n\nimport type {\n    Enhanced, FlatGen, Genable, GeneratorOps, GenOp, GenOpValue, IndexedFn, IndexedPredicate, Reducer, ReturnValue, UnwrapArray\n    } from \"./types\";\n// Should be 'import type' but that makes TS insist it can't be a value here even after defining it.\nimport {Async} from './types';\nimport {\n    isAsyncGenable, isAsyncGenerator, isAsyncIterable, isAsyncIterator, isGenable, isIterable,\n    toAsyncGenerator, toAsyncIterable, toAsyncIterator\n} from \"./functions\";\nimport {Enhancements} from \"./enhancements\";\n\n/**\n * Asynchronous implementation of enhanced generators\n */\n\n\nclass Async_ implements GeneratorOps<Async> {\n    /**\n     * Return a generator that yields the supplied values.\n     * @param values\n     */\n    of<T extends any[], TReturn, TNext>(...values: T):\n        Enhanced<UnwrapArray<T>, Async, TReturn, TNext>\n    {\n        return this.enhance(values);\n    }\n\n    async asArray<T, TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>):\n        Promise<T[]>\n    {\n        const it = toAsyncIterator(gen);\n        const result: T[] = []\n        while (true) {\n            const r = await it.next();\n            if (r.done) {\n                return result;\n            }\n            result.push(r.value);\n        }\n    }\n\n    limit<T, TReturn, TNext>(max: number, gen: Genable<T, Async, TReturn, TNext>):\n        Enhanced<T, Async, TReturn, TNext>;\n\n    limit(max: number):\n        GenOp<Async>;\n\n    limit<T, TReturn, TNext>(\n        max: number,\n        gen?: Genable<T, Async, TReturn, TNext>\n    ):\n         Enhanced<T, Async, TReturn, TNext>\n         | GenOp<Async>\n    {\n        let self: EnhancedAsyncGenerator<T, TReturn, TNext>;\n        async function *limit<X, XReturn = X, XNext = X>(gen: AsyncIterator<X, XReturn, XNext>) {\n            let nr: XNext;\n            let limited: boolean = false;\n            try {\n                for (let i = 0; i < max; i++) {\n                    const r: any = await gen.next(nr!);\n                    if (r.done) {\n                        return r.value;\n                    }\n                    try {\n                        nr = yield r.value;\n                    } catch (e) {\n                        await gen.throw?.(e);\n                    }\n                }\n                limited = true;\n                const err = new RangeError(`Generator produced excessive values > ${max}.`);\n                await gen.throw?.(err);\n                throw err;\n            } finally {\n                if (!limited) {\n                    await gen.return?.(self?.returning);\n                    // Even if the supplied generator refuses to terminate, we terminate.\n                }\n            }\n        }\n        if (gen) {\n            return self = this.enhance(limit(toAsyncIterator(gen)));\n        }\n        return <X, XReturn = X, XNext = X>(gen: Genable<X, Async, XReturn, XNext>) =>\n            this.enhance<X, XReturn, XNext>(limit(toAsyncIterator(gen)));\n    }\n\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @param thisArg Optional value to be supplied as context `this` for function _f_.\n     * @param gen the generator.\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T, TReturn, TNext>(f: IndexedFn<T, undefined, Async>, thisArg: any, gen: Genable<T, Async, TReturn, TNext>):\n        Promise<undefined>;\n\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @param gen the generator.\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T, TReturn, TNext>(f: IndexedFn<T, undefined, Async>, gen: Genable<T, Async, TReturn, TNext>):\n        Promise<undefined>;\n\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @param thisArg Optional value to be supplied as context `this` for function _f_.\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T>(f: IndexedFn<T, undefined, Async>, thisArg?: any):\n        <TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>) =>\n            Promise<undefined>;\n\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T>(f: IndexedFn<T, undefined, Async>):\n        <TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>, thisArg?: any) =>\n            Promise<undefined>;\n\n    forEach<T, TReturn = T, TNext = T>(\n        f: IndexedFn<T, undefined, Async>,\n        thisArgOrGen?: Genable<T, Async, TReturn, TNext>|any,\n        gen?: Genable<T, Async, TReturn, TNext>\n        ): Promise<undefined>\n            | (<XReturn = TReturn, XNext = TNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n                                                Promise<undefined>)\n    {\n        const forEach = async <XReturn, XNext>(\n                                f: IndexedFn<T, XReturn, Async>,\n                                thisArg: any,\n                                gen: Genable<T, Async, XReturn, XNext>\n                            ): Promise<undefined> =>\n            {\n                const it = toAsyncIterator(gen);\n                let idx = 0;\n                while (true) {\n                    const r = await it.next();\n                    if (r.done) return;\n                    await f.call(thisArg, r.value, idx++);\n                }\n            };\n        if (gen) return forEach(f, thisArgOrGen, gen!);\n        if (isAsyncGenable<T, TReturn, TNext>(thisArgOrGen)) return forEach(f, undefined, thisArgOrGen);\n        return <XReturn = T, XNext = T>(gen: Genable<T, Async, XReturn, XNext>, thisArg?: any) =>\n            forEach(f, thisArg ?? thisArgOrGen, gen);\n    }\n\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Async>):\n            GenOpValue<Async, T, V>;\n\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Async>, thisArg?: any):\n            GenOpValue<Async, T, V>;\n\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Async>, gen: Genable<T, Async, TReturn, TNext>):\n            Enhanced<V, Async, TReturn, TNext>;\n\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Async>, thisArg: any, gen: Genable<T, Async, TReturn, TNext>):\n            Enhanced<V, Async, TReturn, TNext>;\n\n    map<T, V,TReturn, TNext>(\n        f: IndexedFn<T, V, Async>,\n        thisArg?: any | Genable<T, Async, TReturn, TNext>,\n        iter?: Genable<T, Async, TReturn, TNext>\n    ):\n        EnhancedAsyncGenerator<V, TReturn, TNext>\n        | (<XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n                EnhancedAsyncGenerator<V, XReturn, XNext>)\n        | (<XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, thisArg?: any) =>\n                EnhancedAsyncGenerator<V, XReturn, XNext>)\n    {\n        const map = <XReturn = T, XNext = T>(thisArg: any, iter: Genable<T, Async, XReturn, XNext>) => {\n            const gen = toAsyncGenerator(iter);\n            let self: EnhancedAsyncGenerator<V, XReturn, XNext>;\n            async function* map(): AsyncGenerator<V, XReturn, XNext> {\n                let nr: any = undefined;\n                let idx = 0;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = await gen.next(nr);\n                                if (r.done) return r.value;\n                                const v = await f.call(thisArg, await r.value, idx++);\n                                try {\n                                    nr = yield v;\n                                } catch (e) {\n                                    await gen.throw(e);\n                                }\n                            }\n                        } finally {\n                            const x = await gen.return(self?.returning);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (!x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            return self = this.enhance(map());\n        };\n        if (iter) return map(thisArg, iter);\n        if (isAsyncGenable<T, TReturn, TNext>(thisArg)) return map(undefined, thisArg);\n        return <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, genThisArg?: any) =>\n                    map(genThisArg ?? thisArg, gen);\n    }\n\n    /**\n     * Return a function that filters a [[Genable]] and yields a new [[EnhancedGenerator]]\n     * that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @typeParam T the type of value.\n     */\n    filter<T>(f: IndexedPredicate<T, Async>):\n        GenOpValue<Async, T, T>;\n\n    /**\n     * Return a function that filters a [[Genable]] and yields a new [[EnhancedGenerator]]\n     * that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     * @typeParam T the type of value.\n     */\n    filter<T>(f: IndexedPredicate<T, Async>, thisArg: any):\n        GenOpValue<Async, T, T>;\n\n    /**\n     * Return a new [[EnhancedGenerator]] that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param iter a [[Genable|Genable<T>]]\n     * @typeParam T the type of value.\n     */\n    filter<T, TReturn, TNext>(f: IndexedPredicate<T, Async>, iter: Genable<T, Async, TReturn, TNext>):\n        Enhanced<T, Async, TReturn, TNext>;\n\n    /**\n     * Return a new [[EnhancedGenerator]] that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     * @param iter a [[Genable|Genable<T>]]\n     * @typeParam T the type of value.\n     */\n    filter<T, TReturn, TNext>(f: IndexedPredicate<T, Async>, thisArg: any, iter: Genable<T, Async, TReturn, TNext>):\n        Enhanced<T, Async, TReturn, TNext>;\n\n    /**\n     * Return a function that filters a [[Genable]] and yields a new [[EnhancedGenerator]]\n     * that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     * @param iter the [[Genable]] to filter.\n     * @typeParam T the type of value.\n     */\n    filter<T, TReturn, TNext>(\n        f: IndexedPredicate<T, Async>,\n        thisArg?: any | Genable<T, Async, TReturn, TNext>,\n        iter?: Genable<T, Async, TReturn, TNext>\n    ):\n        Enhanced<T, Async, TReturn, TNext>\n        | GenOpValue<Async, T, T>\n    {\n        const filter = <XReturn, XNext>(thisArg: any, iter: Genable<T, Async, XReturn, XNext>) => {\n            const gen = toAsyncGenerator<T, XReturn, XNext>(iter);\n            let self: EnhancedAsyncGenerator<T, XReturn, XNext>;\n            async function* filter<V>(f: IndexedPredicate<T, Async>): AsyncGenerator<T, XReturn, XNext> {\n                let nr: any = undefined;\n                let idx = 0;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = await gen.next(nr);\n                                if (r.done) return r.value;\n                                if (await f.call(thisArg, r.value, idx++)) {\n                                    try {\n                                        nr = yield r.value;\n                                    } catch (e) {\n                                        await gen.throw(e);\n                                    }\n                                }\n                            }\n                        } finally {\n                            const x = await gen.return?.(self?.returning);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (!x?.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            return self = this.enhance(filter(f));\n        };\n\n        if (iter) return filter(thisArg, iter);\n        if (isAsyncGenable<T, TReturn, TNext>(thisArg)) return filter(undefined, thisArg);\n        return <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, genThisArg?: any) =>\n            filter<XReturn, XNext>(genThisArg ?? thisArg, gen);\n    }\n\n\n    /**\n     * Flatten the values yielded by the generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param depth\n     */\n    flat<D extends number>(depth: D):\n        <T, TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>) =>\n            Enhanced<FlatGen<T, D>, Async, TReturn, TNext>;\n\n    /**\n     * Flatten the values yielded by the generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param depth\n     * @param gen\n     */\n\n    flat<D extends number, T, TReturn, TNext>(depth: D, gen: Genable<T, Async, TReturn, TNext>):\n        Enhanced<FlatGen<T, D>, Async, TReturn, TNext>;\n\n    /**\n     * Flatten the values yielded by the generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param gen\n     * @param depth default = 1\n     */\n    flat<D extends number, T, TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>, depth?: D):\n        Enhanced<FlatGen<T, D>, Async, TReturn, TNext>;\n\n    flat<D extends number, T, TReturn, TNext>(depth: D|Genable<T, Async, TReturn, TNext>, gen?: Genable<T, Async, TReturn, TNext> | D):\n        Enhanced<FlatGen<T, D>, Async, TReturn, TNext>\n        | (<X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>) =>\n                Enhanced<FlatGen<X, D>, Async, XReturn, XNext>)\n    {\n        const flat = <X, XReturn, XNext>(depth: D, gen: Genable<X, Async, XReturn, XNext>) => {\n            let self: Enhanced<FlatGen<X, D>, Async, XReturn, XNext>;\n            const gens = new Set<AsyncGenerator>();\n            if (isAsyncGenerator(gen)) gens.add(gen);\n\n            async function* flat<D extends number, Y, YReturn, YNext>(it: AsyncIterator<Y, YReturn, YNext>, depth: D): AsyncGenerator<FlatGen<Y, D>, YReturn, YNext> {\n                let nr: any = undefined;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = await it.next(nr);\n                                if (r.done) return r.value;\n                                const v: any = r.value;\n                                if (isAsyncGenerator(v)) {\n                                    gens.add(v);\n                                }\n                                try {\n                                    if (depth > 0 && isAsyncIterator(v)) {\n                                        yield* flat(v, depth - 1);\n                                    } else if (depth > 0 && (isAsyncIterable(v) || isIterable(v))) {\n                                        yield* flat(toAsyncIterator(v), depth - 1)\n                                    } else {\n                                        nr = yield r.value as FlatGen<T, D>;\n                                    }\n                                } catch (e) {\n                                    await it.throw?.(e);\n                                }\n                            }\n                        } finally {\n                            const x = await it.return?.(self?.returning);\n                            if (isAsyncGenerator(it)) gens.delete(it);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (x && !x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                            for (const g of gens) {\n                                await g.return(self?.returning);\n                            }\n                        }\n                    }\n                }\n            }\n\n            return self = this.enhance(flat(toAsyncIterator(gen), depth));\n        }\n        if (typeof depth === 'number') {\n            if (gen) {\n                if (isAsyncGenable(gen)) {\n                    return flat(depth, gen);\n                } else {\n                    throw new TypeError(`Invalid Genable: ${gen}`);\n                }\n            }\n            return <X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>) =>\n                flat(depth, gen);\n        } else if (isAsyncGenable(depth)) {\n            return flat((gen ?? 1) as D, depth);\n        }\n        throw new TypeError(`Illegal arguments to flat()`);\n    }\n\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a function that accepts a generator, and returns another generator that yields the individual value\n     * at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param depth\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T>(f: IndexedFn<T, R, Async>, depth: D):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n            Enhanced<R, Async, XReturn, XNext>;\n\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a function that accepts a generator, and returns another generator that yields the individual value\n     * at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T>(f: IndexedFn<T, R, Async>):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, depth?: D) =>\n            Enhanced<R, Async, XReturn, XNext>;\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a generator that yields the individual values at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param gen\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T, TReturn, TNext>(\n            f: IndexedFn<T, R, Async>,\n            gen: Genable<T, Async, TReturn, TNext>\n    ):\n        Enhanced<R, Async, TReturn, TNext>;\n\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a generator that yields the individual values at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param depth\n     * @param gen\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T, TReturn, TNext>(\n        f: IndexedFn<T, R, Async>,\n        depth: D,\n        gen: Genable<T, Async, TReturn, TNext>\n    ):\n        Enhanced<R, Async, TReturn, TNext>;\n\n    flatMap<D extends number, R extends FlatGen<T, D>, T, TReturn, TNext>(\n        f: IndexedFn<T, R, Async>,\n        depthOrGen?: D | Genable<T, Async, TReturn, TNext>,\n        gen?: Genable<T, Async, TReturn, TNext>\n    ):\n        Enhanced<R, Async, TReturn, TNext>\n        | (\n            <Y extends FlatGen<T, D>, X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>) =>\n                Enhanced<Y, Async, XReturn, XNext>\n        )\n        | (\n            <Y extends FlatGen<T, D>, X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>, depth?: D) =>\n                Enhanced<Y, Async, XReturn, XNext>\n        )\n    {\n        const flatMap = <X, XReturn, XNext>(depth: D, gen: Genable<X, Async, XReturn, XNext>) => {\n            let self: Enhanced<FlatGen<X, D>, Async, XReturn, XNext>;\n            let idx = 0;\n\n            async function* flatMap<D extends number, Y, YReturn, YNext>(\n                    it: AsyncIterator<Y, YReturn, YNext>, depth: D\n                ):\n                    AsyncGenerator<FlatGen<T, D>, YReturn, YNext>\n                {\n                let nr: any = undefined;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = await it.next(nr);\n                                if (r.done) return r.value;\n                                const v = await f(r.value as FlatGen<T, D>, idx++);\n                                try {\n                                    if (isAsyncIterator<unknown, YReturn, YNext>(v)) {\n                                        if (depth > 1) {\n                                            yield* flatMap(v, depth - 1);\n                                        } else if (depth === 1) {\n                                            const it = toAsyncIterator(v);\n                                            yield* toAsyncGenerator(it);\n                                        } else {\n                                            yield v;\n                                        }\n                                    } else if (isAsyncIterable<unknown, YReturn, YNext>(v) || isIterable<unknown, YReturn, YNext>(v)) {\n                                        if (depth > 1) {\n                                            yield* flatMap(toAsyncIterator(v), depth - 1);\n                                        } else if (depth === 1) {\n                                            yield* toAsyncGenerator(v);\n                                        } else {\n                                            yield v;\n                                        }\n                                    } else {\n                                        nr = yield v;\n                                    }\n                                } catch (e) {\n                                    await it.throw?.(e);\n                                }\n                            }\n                        } finally {\n                            const x = await it.return?.(self?.returning);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (x && !x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            return self = this.enhance(flatMap(toAsyncIterator(gen), depth));\n        }\n\n        if (isAsyncGenable(gen)) {\n            return flatMap(depthOrGen as D ?? 1 as D, gen);\n        } else if (isAsyncGenable( depthOrGen)) {\n            return flatMap(1 as D, depthOrGen);\n        }\n        return <X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>, depth?: D) =>\n            flatMap(depthOrGen ?? depth ?? 1 as D, gen);\n    }\n\n    /**\n     * Return a new [[EnhancedGenerator]] that only yields the indicated values, skipping _start_ initial values\n     * and continuing until the _end_.\n     * @param start\n     * @param end\n     */\n    slice<T>(start: number, end: number):\n        <X, XReturn, XNext>(iter: Genable<X, Async, XReturn, XNext>) =>\n            Enhanced<X, Async, XReturn, XNext>;\n    /**\n     * Return a new [[EnhancedGenerator]] that only yields the indicated values, skipping _start_ initial values\n     * and continuing until the _end_.\n     * @param start\n     * @param end\n     * @param iter\n     */\n    slice<T, TReturn, TNext>(start: number, end: number, iter: Genable<T, Async, TReturn, TNext>):\n        Enhanced<T, Async, TReturn, TNext>;\n\n    slice<T, TReturn, TNext>(\n        start: number,\n        end: number,\n        iter?: Genable<T, Async, TReturn, TNext>\n    ):\n        Enhanced<T, Async, TReturn | undefined, TNext>\n        | (\n            <X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>) =>\n                Enhanced<X, Async, XReturn | undefined, XNext>\n        )\n    {\n        const slice = <X, XReturn, XNext>(iter: Genable<X, Async, XReturn, XNext>):\n            Enhanced<X, Async, XReturn | undefined, XNext> =>\n        {\n            const it = toAsyncIterator(iter);\n            async function* slice(start: number, end: number) {\n                for (let i = 0; i < start; i++) {\n                    const r = await it.next();\n                    if (r.done) return r.value;\n                }\n                if (end === Number.POSITIVE_INFINITY) {\n                    yield* toAsyncIterable(it);\n                } else {\n                    let nv: XNext;\n                    while (true) {\n                        try {\n                            for (let i = start; i < end; i++) {\n                                const r = await it.next(nv!);\n                                if (r.done) return r.value;\n                                try {\n                                    nv = yield r.value;\n                                } catch (e) {\n                                    const re = await it.throw?.(e);\n                                    if (re) {\n                                        if (re.done) return re.value;\n                                        nv = yield re.value;\n                                    }\n                                }\n                            }\n                        } finally {\n                            const x = await it.return?.();\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (x && !x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n                return;\n            }\n            return this.enhance(slice(start, end));\n        };\n        if (!iter) return slice;\n        return slice(iter);\n    }\n\n    /**\n     * Concatenates generators (or iterators or iterables).\n     *\n     * Ensures that any supplied generators are terminated when this is terminated.\n     * @param gens zero or more additional [[Genable]] to provide values.\n     */\n    concat<T, TReturn, TNext>(...gens: Array<Genable<T, Async, TReturn, TNext>>):\n        Enhanced<T, Async, TReturn | void, TNext>\n    {\n        let self: Enhanced<T, Async, TReturn | void, TNext>;\n        async function* concat(): AsyncGenerator<T, TReturn | void, TNext> {\n            let i = 0;\n            try {\n                for (; i < gens.length; i++) {\n                    const it = toAsyncIterable(gens[i]);\n                    yield* it;\n                }\n            } finally {\n                // Terminate any remaining generators.\n                for (; i < gens.length; i++) {\n                    const g = gens[i];\n                    if (isAsyncGenerator(g)) {\n                        await g.return(self?.returning);\n                    }\n                }\n            }\n        }\n\n        return self = this.enhance(concat());\n    }\n\n    /**\n     * Reduces **gen** like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     * @param f\n     * @param gen\n     */\n    reduce<A, T, TReturn, TNext>(f: Reducer<A, T, T, Async>, gen: Genable<T, Async, TReturn, TNext>):\n        A;\n\n    /**\n     *\n     * Returns a reducer function that, when applied to a `Generator` **gen**, reduces **gen** like\n     * **Array.prototype.reduce**. The 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     *\n     * @param f\n     */\n    reduce<A, T>(f: Reducer<A, T, T, Async>):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n            A;\n\n    /**\n     *\n     * Returns a reducer function that, when applied to a `Generator` **gen**, reduces **gen** like\n     * `Array.prototype.reduce`. The 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     *\n     * @param f\n     */\n    reduce<A, T>(f: Reducer<A, T, A, Async>):\n        <XReturn, XNext>(init: A, gen: Genable<T, Async, XReturn, XNext>) =>\n            A;\n\n    /**\n     * Reduces **gen** like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     * @param f\n     * @param init\n     * @param gen\n     */\n    reduce<A, T, TReturn, TNext>(f: Reducer<A, T, A, Async>, init: A, gen: Genable<T, Async, TReturn, TNext>):\n        A;\n\n    /**\n     * Returns a reducer function that, when applied to a `Generator` **gen**, reduces **gen** like\n     * `Array.prototype.reduce`. The 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     *\n     * Alternatively, the init value can be supplied along with the generator as a second argument.\n     * @param f\n     * @param init\n     */\n    reduce<A, T>(f: Reducer<A, T, A, Async>, init: A):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n            A;\n\n    reduce<A, T, TReturn, TNext>(\n        f: Reducer<A, T, A | T, Async>,\n        initOrGen?: A | Genable<T, Async, TReturn, TNext>,\n        gen?: Genable<T, Async, TReturn, TNext>\n    ): A\n        | Promise<A>\n        | (\n            (gen: Genable<T, Async, TReturn, TNext>) =>\n                A | Promise<A>\n        )\n        | (\n            (f: (acc: A, v: T) => A, init: A) =>\n                A | Promise<A>\n        )\n        | (\n            (f: (acc: A | T, v: T) => A) =>\n                A | Promise<A>\n        )\n    {\n\n        const reduce = async <XReturn, XNext>(init: A | PromiseLike<A> | undefined, it: AsyncIterator<T, XReturn, XNext>):\n            Promise<A> =>\n        {\n            let acc: A | T | undefined = await init;\n            if (acc === undefined) {\n                const r = await it.next();\n                if (r.done) throw new TypeError(`No initial value in reduce`);\n                acc = r.value;\n            }\n            while (true) {\n                const r = await it.next();\n                if (r.done) return acc as A;\n                acc = await f(acc, r.value);\n            }\n        };\n        if (isAsyncGenable(gen)) {\n            return reduce(initOrGen as A, toAsyncIterator(gen));\n        } else if (isAsyncGenable(initOrGen)) {\n            return reduce(undefined, toAsyncIterator(initOrGen));\n        }\n        return (gen: Genable<T, Async, TReturn, TNext>, init?: A) =>\n            reduce(init ?? initOrGen, toAsyncIterator(gen));\n    }\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    some<T, TReturn, TNext>(p: IndexedPredicate<T, Async>, thisArg?: any):\n        (gen: Genable<T, Async, TReturn, TNext>) =>\n            ReturnValue<boolean, Async>;\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     */\n    some<T>(p: IndexedPredicate<T, Async>):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, thisArg?: any) =>\n            ReturnValue<boolean, Async>;\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param gen the generator\n     */\n    some<T, TReturn, TNext>(p: IndexedPredicate<T, Async>, gen: Genable<T, Async, TReturn, TNext>):\n        ReturnValue<boolean, Async>;\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     * @param gen the generator\n     */\n    some<T, TReturn, TNext>(p: IndexedPredicate<T, Async>, thisArg: any, gen: Genable<T, Async, TReturn, TNext>):\n        ReturnValue<boolean, Async>;\n\n    some<T, TReturn, TNext>(\n        pred: IndexedPredicate<T, Async>,\n        thisOrGen?: any | Genable<T, Async, TReturn, TNext>,\n        gen?: Genable<T, Async, TReturn, TNext>\n    ):\n        ReturnValue<boolean, Async>\n        | (\n            (gen: Genable<T, Async, TReturn, TNext>) =>\n                ReturnValue<boolean, Async>\n        )\n    {\n        const some = async <XReturn, XNext>(thisArg: any, it: AsyncIterator<T, XReturn, XNext>): Promise<boolean> => {\n            let i = 0;\n            while (true) {\n                const r = await it.next();\n                if (r.done) return false;\n                if (pred.call(thisArg, r.value, i++)) return true;\n            }\n        };\n        if (isAsyncGenable(gen)) {\n            return some(thisOrGen, toAsyncIterator(gen));\n        } else if (isAsyncGenable(gen)) {\n            return (gen: Genable<T, Async, TReturn, TNext>, thisArg?: any) =>\n                some(thisArg ?? thisOrGen, toAsyncIterator(gen));\n        }\n        throw new Error(`Invalid argument to some: ${gen ?? thisOrGen}`);\n    }\n\n\n    /**\n     * Returns `false` and terminates the generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    every<T>(p: IndexedPredicate<T, Async>, thisArg?: any):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n            ReturnValue<boolean, Async>;\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     */\n    every<T>(p: IndexedPredicate<T, Async>):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, thisArg?: any) =>\n            ReturnValue<boolean, Async>;\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param gen the generator\n     */\n    every<T, TReturn, TNext>(p: IndexedPredicate<T, Async>, gen: Genable<T, Async,TReturn, TNext>):\n        ReturnValue<boolean, Async>;\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     * @param gen the generator\n     */\n    every<T, TReturn, TNext>(p: IndexedPredicate<T, Async>, thisArg: any, gen: Genable<T, Async, TReturn, TNext>):\n        ReturnValue<boolean, Async>;\n\n    every<T, TReturn, TNext>(\n        pred: IndexedPredicate<T, Async>,\n        genOrThis?: any | Genable<T, Async, TReturn, TNext>,\n        gen?: Genable<T, Async, TReturn, TNext>\n    ):\n        ReturnValue<boolean, Async>\n        | (\n            <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n                ReturnValue<boolean, Async>\n        )\n    {\n        const every = async <XReturn, XNext>(thisArg: any, it: AsyncIterator<T, XReturn, XNext>):\n            Promise<boolean> =>\n        {\n            let i = 0;\n            while (true) {\n                const r = await it.next();\n                if (r.done) return true;\n                if (!pred.call(thisArg, r.value, i++)) return false;\n            }\n        };\n        if (isAsyncGenable(gen)) {\n            return every(genOrThis, toAsyncIterator(gen));\n        } else if (isGenable(gen)) {\n            return <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, thisArg?: any) =>\n                every(thisArg ?? genOrThis, toAsyncIterator(gen));\n        }\n        throw new Error(`Invalid argument to every: ${gen ?? genOrThis}`);\n    }\n\n    /**\n     * Returns a new generator that repeats the last value returned by **gen** (or `undefined` if **gen**\n     * did not return any values).\n     *\n     * @param gen\n     * @param max\n     */\n    repeatLast<T, TReturn, TNext>(\n        gen: Genable<T, Async, TReturn, TNext>,\n        max: number = Number.POSITIVE_INFINITY\n    ):\n        Enhanced<T, Async, TReturn | undefined, TNext>\n    {\n        const it = toAsyncIterator(gen);\n        let nr: TNext;\n        let self: Enhanced<T, Async, TReturn | undefined, TNext>;\n\n        async function* repeatLast(): AsyncGenerator<T, TReturn | undefined, TNext> {\n            try {\n                let last: T;\n                while (true) {\n                    const r = await it.next(nr as unknown as TNext)\n                    if (r.done) break;\n                    try {\n                        nr = yield (last = r.value);\n                    } catch (e) {\n                        const re = await it.throw?.(e);\n                        if (re) {\n                            if (re.done) break;\n                            yield last = re.value;\n                        }\n                    }\n                }\n                for (let i = 0; i < max; i++) {\n                    // Important to await at the expected point for consistent behavior.\n                    yield await last!;\n                }\n            } finally {\n                await it.return?.(self?.returning);\n            }\n            return;\n        }\n\n        return self = this.enhance(repeatLast());\n    }\n\n\n    /**\n     * Returns a new generator that repeats the supplied value.\n     *\n     * @param value the value to repeat\n     * @param repetitions The number repetitions; the default is infinite.\n     */\n    repeat<T, TNext>(value: T, repetitions: number = Number.POSITIVE_INFINITY):\n        Enhanced<T, Async, void, TNext>\n    {\n        async function* repeat(): AsyncGenerator<T, void, TNext> {\n            for (let i = 0; i < repetitions; i++) {\n                // Important to await at the expected point for consistent behavior.\n                yield await value;\n            }\n        }\n\n        return this.enhance(repeat());\n    }\n\n    /**\n     * Combines generators, returning a generator that produces a tuple with each of their results.\n     *\n     * Terminates when the first generator terminates. To get other behaviors, use with [[EnhancedGenerator.repeat]] or\n     * [[EnhancedGenerator.repeatLast]].\n     * @param gens\n     */\n    zip<T, TReturn, TNext>(...gens: Array<Genable<T, Async, TReturn, TNext>>):\n        Enhanced<Array<T>, Async, TReturn, TNext>\n    {\n        if (gens.length === 0) return this.enhance([]);\n        const its = gens.map(toAsyncIterator);\n        let done = false;\n        let self: Enhanced<Array<T>, Async, TReturn, TNext>;\n\n        async function* zip2(): AsyncGenerator<Array<T>, TReturn, TNext> {\n            try {\n                while (true) {\n                    let result: Array<T> = [];\n                    for (const g of its) {\n                        const r = await g.next();\n                        if (r.done) {\n                            done = true;\n                            return r.value;\n                        }\n                        (result as any[]).push(r.value);\n                    }\n                    try {\n                        yield result;\n                    } catch (e) {\n                        for (const g of gens) {\n                            try {\n                                // Weird need for a typecast here.\n                                await (g as any).throw?.(e);\n                            } catch {\n                                // Ignore\n                            }\n                        }\n                        throw e;\n                    }\n                }\n            } finally {\n                if (!done) {\n                    for (const g of gens) {\n                        try {\n                            // Weird need for a typecast here.\n                            await (g as any).return?.(self?.returning);\n                        } catch {\n                            // Ignore\n                        }\n                    }\n                }\n            }\n        }\n\n        return self = this.enhance(zip2());\n    }\n\n\n    /**\n     * Returns a function that joins the elements produced by a [[Genable]], analogous to `Array.prototype.join`.\n     * @param sep (default = ',')\n     */\n    join(sep: string):\n        <T, TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>) =>\n            ReturnValue<string, Async>;\n\n    /**\n     * Joins the elements produced by a [[Genable]], analogous to `Array.prototype.join`.\n     * @param gen\n     * @param sep\n     */\n    join<T, TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>, sep?: string):\n        ReturnValue<string, Async>;\n\n    join<T, TReturn, TNext>(\n        genOrSeparator: Genable<T, Async, TReturn, TNext>|string,\n        sep?: string\n    ):\n        ReturnValue<string, Async>\n        | (\n            <X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>) =>\n                ReturnValue<string, Async>\n        )\n    {\n        if (typeof genOrSeparator === 'string') {\n            sep = genOrSeparator;\n            return <X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>) =>\n                this.join(gen, sep);\n        }\n        return Promise.resolve(this.enhance(genOrSeparator).asArray())\n            .then(a => a.join(sep));\n    }\n\n    /**\n     * Returns a new generator that returns values from each of the supplied sources as they are available.\n     * Values will be taken as they become available from any source.\n     * The yielded values will not be distinguished by which which source they are taken; for\n     * that, another method will be supplied.\n     *\n     * Any calls to `Generator.throw()` or `Generator.return()` will be passed to all non-terminated\n     * sources.\n     * @param sources\n     */\n    merge<T, TReturn, TNext>(...sources: Array<Genable<T, Async, TReturn, TNext>>):\n        Enhanced<T, Async, TReturn | void, TNext>\n    {\n        let self: Enhanced<T, Async, void | TReturn, TNext>;\n        let done: (r: IteratorReturnResult<TReturn>) => void;\n        const donePromise = new Promise<IteratorReturnResult<TReturn>>(r => (done = r));\n        let activeCount = sources.length;\n        let active: Array<Promise<() => (IteratorResult<T, TReturn> | null)> | Promise<IteratorReturnResult<TReturn>>>;\n        const dead = new Promise<() => (IteratorResult<T, TReturn> | null)>(() => null); // Never completes\n        let gens: Array<AsyncIterator<T, TReturn, TNext>> = [];\n        const wrap = async (g: Genable<T, Async, TReturn, TNext>, k: number) => {\n            const ag = toAsyncIterator(g);\n            gens[k] = ag;\n            const handle = async (val: IteratorResult<T, TReturn>): Promise<() => (IteratorResult<T, TReturn> | null)> =>\n                () => {\n                    if (val.done) {\n                        active[k] = dead;\n                        // Unless this is the last active generator, we return null to indicate\n                        // to the loop to go on to the next one.\n                        return --activeCount > 0\n                            ? null\n                            : (done(val), val);\n                    } else {\n                        const v = ag.next().then(handle);\n                        active[k] = v;\n                        return val;\n                    }\n                };\n            return (await ag.next().then(handle));\n        };\n        active = [...sources.map(wrap), donePromise];\n        async function* merge(): AsyncGenerator<T, TReturn | void, TNext> {\n            try {\n                let nv: TNext;\n                while (activeCount) {\n                    const race: Array<Promise<() => (IteratorResult<T, TReturn> | null)> | Promise<IteratorReturnResult<TReturn>>> = [];\n                    active.forEach(a => race.push(a))\n                    const result = await (await Promise.race(race));\n                    if (typeof result === 'function') {\n                        let r = result();\n                        if (r) {\n                            if (r.done) {\n                                return r.value;\n                            }\n                            nv = (yield r.value);\n                        }\n                    } else if (result && result.done) {\n                        return result.value;\n                    }\n                }\n            } finally {\n                if (activeCount) {\n                    for (let i = 0; i < sources.length; i++) {\n                        (active[i] === null ? null : gens[i])?.return?.(self?.returning);\n                    }\n                }\n            }\n        }\n        return self = Async.enhance(merge());\n    }\n\n    /**\n     * Returns a function that sorts the supplied sources and returns a sorted array.\n     * @param cmp a comparison function\n     */\n    sort<T>(cmp?: ((a: T, b: T) => number)) {\n        return async <TReturn, TNext>(...sources: Array<Genable<T, Async, TReturn, TNext>>) => {\n            const array: T[] = await this.merge(...sources).asArray();\n            return array.sort(cmp);\n        };\n    }\n\n    /**\n     * Enhance an existing generator (or iterator or iterable) to be a EnhancedGenerator.\n     * @param gen\n     */\n    enhance<T, TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>):\n        EnhancedAsyncGenerator<T, TReturn, TNext>\n    {\n        const gen2 = toAsyncGenerator(gen)as\n            unknown as Partial<EnhancedAsyncGenerator<T, TReturn, TNext>>;\n        const old = Object.getPrototypeOf(gen2);\n        const proto = Object.assign(Object.create(EnhancedAsyncGenerator.prototype), old);\n        proto.return = (v: any) => ((gen2 as any).returning = v, old.return.call(gen2, v));\n        proto[Symbol.asyncIterator] = () => gen2;\n        Object.setPrototypeOf(gen2, proto);\n        return gen2 as EnhancedAsyncGenerator<T, TReturn, TNext>;\n    }\n}\n\n/**\n * Factory for synchronous generator operators. See [[GeneratorOps]] for details.\n */\nconst Async: GeneratorOps<Async> = new Async_();\nexport {Async};\n\nexport abstract class EnhancedAsyncGenerator<T, TReturn, TNext>\n    extends Enhancements<T, TReturn, TNext, Async>\n    implements AsyncGenerator<T, TReturn, TNext>,\n        AsyncIterable<T>,\n        AsyncIterator<T, TReturn, TNext>\n{\n}\n\nconst makeProto = (base: any) => {\n    const newProto = Object.create(base);\n    const inherit = (proto: any) => {\n        for (const k of Reflect.ownKeys(proto)) {\n            if (k !== 'constructor') {\n                newProto[k] = proto[k];\n            }\n        }\n    };\n    inherit(Enhancements.prototype);\n    return newProto;\n}\n\n/**\n * @internal\n * @constructor\n */\nasync function* AsyncFoo() {\n}\n\n/**\n * @internal\n */\nexport const AsyncGenProto = Object.getPrototypeOf(AsyncFoo());\n\n// Make EnhancedGenerator inherit generator methods.\n\nObject.setPrototypeOf(EnhancedAsyncGenerator.prototype, makeProto(AsyncGenProto));\nObject.defineProperty(EnhancedAsyncGenerator.prototype, '_impl', {\n    value: Async,\n    writable: false,\n    enumerable: false,\n    configurable: false\n});\n","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n\n/**\n * This entry point loads synchronous and asynchronous extended generators\n * @packageDocumentation\n * @module generators\n * @preferred\n */\n\nexport type {SyncType} from './types';\nimport {Sync as SyncFoo} from './sync';\nimport {Async as AsyncFoo} from './async';\n\n/**\n * Factory for synchronous generator operators. See [[GeneratorOps]] for details.\n */\nconst Sync = SyncFoo;\n/**\n * Selector type to select the types for synchronous generators.\n */\ntype Sync = 'sync';\n\n/**\n * Factory for asynchronous generator operators. See [[GeneratorOps]] for details.\n */\nconst Async = AsyncFoo;\n/**\n * Selector type to select the types for ssynchronous generators.\n */\ntype Async = 'async';\nexport {Sync, Async};\n","'use strict';\n\n/**\n * Custom implementation of a double ended queue.\n */\nfunction Denque(array, options) {\n  var options = options || {};\n\n  this._head = 0;\n  this._tail = 0;\n  this._capacity = options.capacity;\n  this._capacityMask = 0x3;\n  this._list = new Array(4);\n  if (Array.isArray(array)) {\n    this._fromArray(array);\n  }\n}\n\n/**\n * -------------\n *  PUBLIC API\n * -------------\n */\n\n/**\n * Returns the item at the specified index from the list.\n * 0 is the first element, 1 is the second, and so on...\n * Elements at negative values are that many from the end: -1 is one before the end\n * (the last element), -2 is two before the end (one before last), etc.\n * @param index\n * @returns {*}\n */\nDenque.prototype.peekAt = function peekAt(index) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  var len = this.size();\n  if (i >= len || i < -len) return undefined;\n  if (i < 0) i += len;\n  i = (this._head + i) & this._capacityMask;\n  return this._list[i];\n};\n\n/**\n * Alias for peekAt()\n * @param i\n * @returns {*}\n */\nDenque.prototype.get = function get(i) {\n  return this.peekAt(i);\n};\n\n/**\n * Returns the first item in the list without removing it.\n * @returns {*}\n */\nDenque.prototype.peek = function peek() {\n  if (this._head === this._tail) return undefined;\n  return this._list[this._head];\n};\n\n/**\n * Alias for peek()\n * @returns {*}\n */\nDenque.prototype.peekFront = function peekFront() {\n  return this.peek();\n};\n\n/**\n * Returns the item that is at the back of the queue without removing it.\n * Uses peekAt(-1)\n */\nDenque.prototype.peekBack = function peekBack() {\n  return this.peekAt(-1);\n};\n\n/**\n * Returns the current length of the queue\n * @return {Number}\n */\nObject.defineProperty(Denque.prototype, 'length', {\n  get: function length() {\n    return this.size();\n  }\n});\n\n/**\n * Return the number of items on the list, or 0 if empty.\n * @returns {number}\n */\nDenque.prototype.size = function size() {\n  if (this._head === this._tail) return 0;\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Add an item at the beginning of the list.\n * @param item\n */\nDenque.prototype.unshift = function unshift(item) {\n  if (item === undefined) return this.size();\n  var len = this._list.length;\n  this._head = (this._head - 1 + len) & this._capacityMask;\n  this._list[this._head] = item;\n  if (this._tail === this._head) this._growArray();\n  if (this._capacity && this.size() > this._capacity) this.pop();\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Remove and return the first item on the list,\n * Returns undefined if the list is empty.\n * @returns {*}\n */\nDenque.prototype.shift = function shift() {\n  var head = this._head;\n  if (head === this._tail) return undefined;\n  var item = this._list[head];\n  this._list[head] = undefined;\n  this._head = (head + 1) & this._capacityMask;\n  if (head < 2 && this._tail > 10000 && this._tail <= this._list.length >>> 2) this._shrinkArray();\n  return item;\n};\n\n/**\n * Add an item to the bottom of the list.\n * @param item\n */\nDenque.prototype.push = function push(item) {\n  if (item === undefined) return this.size();\n  var tail = this._tail;\n  this._list[tail] = item;\n  this._tail = (tail + 1) & this._capacityMask;\n  if (this._tail === this._head) {\n    this._growArray();\n  }\n  if (this._capacity && this.size() > this._capacity) {\n    this.shift();\n  }\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Remove and return the last item on the list.\n * Returns undefined if the list is empty.\n * @returns {*}\n */\nDenque.prototype.pop = function pop() {\n  var tail = this._tail;\n  if (tail === this._head) return undefined;\n  var len = this._list.length;\n  this._tail = (tail - 1 + len) & this._capacityMask;\n  var item = this._list[this._tail];\n  this._list[this._tail] = undefined;\n  if (this._head < 2 && tail > 10000 && tail <= len >>> 2) this._shrinkArray();\n  return item;\n};\n\n/**\n * Remove and return the item at the specified index from the list.\n * Returns undefined if the list is empty.\n * @param index\n * @returns {*}\n */\nDenque.prototype.removeOne = function removeOne(index) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  if (this._head === this._tail) return void 0;\n  var size = this.size();\n  var len = this._list.length;\n  if (i >= size || i < -size) return void 0;\n  if (i < 0) i += size;\n  i = (this._head + i) & this._capacityMask;\n  var item = this._list[i];\n  var k;\n  if (index < size / 2) {\n    for (k = index; k > 0; k--) {\n      this._list[i] = this._list[i = (i - 1 + len) & this._capacityMask];\n    }\n    this._list[i] = void 0;\n    this._head = (this._head + 1 + len) & this._capacityMask;\n  } else {\n    for (k = size - 1 - index; k > 0; k--) {\n      this._list[i] = this._list[i = ( i + 1 + len) & this._capacityMask];\n    }\n    this._list[i] = void 0;\n    this._tail = (this._tail - 1 + len) & this._capacityMask;\n  }\n  return item;\n};\n\n/**\n * Remove number of items from the specified index from the list.\n * Returns array of removed items.\n * Returns undefined if the list is empty.\n * @param index\n * @param count\n * @returns {array}\n */\nDenque.prototype.remove = function remove(index, count) {\n  var i = index;\n  var removed;\n  var del_count = count;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  if (this._head === this._tail) return void 0;\n  var size = this.size();\n  var len = this._list.length;\n  if (i >= size || i < -size || count < 1) return void 0;\n  if (i < 0) i += size;\n  if (count === 1 || !count) {\n    removed = new Array(1);\n    removed[0] = this.removeOne(i);\n    return removed;\n  }\n  if (i === 0 && i + count >= size) {\n    removed = this.toArray();\n    this.clear();\n    return removed;\n  }\n  if (i + count > size) count = size - i;\n  var k;\n  removed = new Array(count);\n  for (k = 0; k < count; k++) {\n    removed[k] = this._list[(this._head + i + k) & this._capacityMask];\n  }\n  i = (this._head + i) & this._capacityMask;\n  if (index + count === size) {\n    this._tail = (this._tail - count + len) & this._capacityMask;\n    for (k = count; k > 0; k--) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n    }\n    return removed;\n  }\n  if (index === 0) {\n    this._head = (this._head + count + len) & this._capacityMask;\n    for (k = count - 1; k > 0; k--) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n    }\n    return removed;\n  }\n  if (i < size / 2) {\n    this._head = (this._head + index + count + len) & this._capacityMask;\n    for (k = index; k > 0; k--) {\n      this.unshift(this._list[i = (i - 1 + len) & this._capacityMask]);\n    }\n    i = (this._head - 1 + len) & this._capacityMask;\n    while (del_count > 0) {\n      this._list[i = (i - 1 + len) & this._capacityMask] = void 0;\n      del_count--;\n    }\n    if (index < 0) this._tail = i;\n  } else {\n    this._tail = i;\n    i = (i + count + len) & this._capacityMask;\n    for (k = size - (count + index); k > 0; k--) {\n      this.push(this._list[i++]);\n    }\n    i = this._tail;\n    while (del_count > 0) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n      del_count--;\n    }\n  }\n  if (this._head < 2 && this._tail > 10000 && this._tail <= len >>> 2) this._shrinkArray();\n  return removed;\n};\n\n/**\n * Native splice implementation.\n * Remove number of items from the specified index from the list and/or add new elements.\n * Returns array of removed items or empty array if count == 0.\n * Returns undefined if the list is empty.\n *\n * @param index\n * @param count\n * @param {...*} [elements]\n * @returns {array}\n */\nDenque.prototype.splice = function splice(index, count) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  var size = this.size();\n  if (i < 0) i += size;\n  if (i > size) return void 0;\n  if (arguments.length > 2) {\n    var k;\n    var temp;\n    var removed;\n    var arg_len = arguments.length;\n    var len = this._list.length;\n    var arguments_index = 2;\n    if (!size || i < size / 2) {\n      temp = new Array(i);\n      for (k = 0; k < i; k++) {\n        temp[k] = this._list[(this._head + k) & this._capacityMask];\n      }\n      if (count === 0) {\n        removed = [];\n        if (i > 0) {\n          this._head = (this._head + i + len) & this._capacityMask;\n        }\n      } else {\n        removed = this.remove(i, count);\n        this._head = (this._head + i + len) & this._capacityMask;\n      }\n      while (arg_len > arguments_index) {\n        this.unshift(arguments[--arg_len]);\n      }\n      for (k = i; k > 0; k--) {\n        this.unshift(temp[k - 1]);\n      }\n    } else {\n      temp = new Array(size - (i + count));\n      var leng = temp.length;\n      for (k = 0; k < leng; k++) {\n        temp[k] = this._list[(this._head + i + count + k) & this._capacityMask];\n      }\n      if (count === 0) {\n        removed = [];\n        if (i != size) {\n          this._tail = (this._head + i + len) & this._capacityMask;\n        }\n      } else {\n        removed = this.remove(i, count);\n        this._tail = (this._tail - leng + len) & this._capacityMask;\n      }\n      while (arguments_index < arg_len) {\n        this.push(arguments[arguments_index++]);\n      }\n      for (k = 0; k < leng; k++) {\n        this.push(temp[k]);\n      }\n    }\n    return removed;\n  } else {\n    return this.remove(i, count);\n  }\n};\n\n/**\n * Soft clear - does not reset capacity.\n */\nDenque.prototype.clear = function clear() {\n  this._head = 0;\n  this._tail = 0;\n};\n\n/**\n * Returns true or false whether the list is empty.\n * @returns {boolean}\n */\nDenque.prototype.isEmpty = function isEmpty() {\n  return this._head === this._tail;\n};\n\n/**\n * Returns an array of all queue items.\n * @returns {Array}\n */\nDenque.prototype.toArray = function toArray() {\n  return this._copyArray(false);\n};\n\n/**\n * -------------\n *   INTERNALS\n * -------------\n */\n\n/**\n * Fills the queue with items from an array\n * For use in the constructor\n * @param array\n * @private\n */\nDenque.prototype._fromArray = function _fromArray(array) {\n  for (var i = 0; i < array.length; i++) this.push(array[i]);\n};\n\n/**\n *\n * @param fullCopy\n * @returns {Array}\n * @private\n */\nDenque.prototype._copyArray = function _copyArray(fullCopy) {\n  var newArray = [];\n  var list = this._list;\n  var len = list.length;\n  var i;\n  if (fullCopy || this._head > this._tail) {\n    for (i = this._head; i < len; i++) newArray.push(list[i]);\n    for (i = 0; i < this._tail; i++) newArray.push(list[i]);\n  } else {\n    for (i = this._head; i < this._tail; i++) newArray.push(list[i]);\n  }\n  return newArray;\n};\n\n/**\n * Grows the internal list array.\n * @private\n */\nDenque.prototype._growArray = function _growArray() {\n  if (this._head) {\n    // copy existing data, head to end, then beginning to tail.\n    this._list = this._copyArray(true);\n    this._head = 0;\n  }\n\n  // head is at 0 and array is now full, safe to extend\n  this._tail = this._list.length;\n\n  this._list.length *= 2;\n  this._capacityMask = (this._capacityMask << 1) | 1;\n};\n\n/**\n * Shrinks the internal list array.\n * @private\n */\nDenque.prototype._shrinkArray = function _shrinkArray() {\n  this._list.length >>>= 1;\n  this._capacityMask >>>= 1;\n};\n\n\nmodule.exports = Denque;\n","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * Turn events/imperative calls into values returned by an async generator.\n * @module events\n * @packageDocumentation\n * @preferred\n */\n\nimport Denque from 'denque';\n\n/**\n * Interface for controlling the generators returned by {@link eventToGenerator}.\n */\nexport interface Controller<T, E = T | any> {\n    /**\n     * Queue _v_ to the generator.\n     * @param v\n     */\n    send(v: T): void,\n\n    /**\n     * Queue _e_ (optional) to be returned by the generator, ending it.\n     * @param e\n     */\n    end(e?: E): void,\n\n    /**\n     * Queue an error to be thrown by the generator, ending it.\n     * @param err\n     */\n    throw(err: Error): void;\n\n    /**\n     * Clear all pending values queued to the generator.\n     */\n    clear(): void;\n}\n\nconst endTag = Symbol.for(\"endTag\");\nconst returnMsg = {[endTag]: 'return'};\nconst throwMsg = {[endTag]: 'throw'};\ntype ReturnMsg<R> = typeof returnMsg & {value: R};\ntype ThrowMsg = typeof throwMsg & {value: Error};\ntype EndMsg<R> = ReturnMsg<R> | ThrowMsg;\nconst isReturnMsg = <R>(m: any): m is ReturnMsg<R> => m instanceof Object && (m[endTag] === 'return');\nconst isThrowMsg = (m: any): m is ThrowMsg => m instanceof Object && (m[endTag] === 'throw');\n\n/**\n * A queue usable by {@link eventToGenerator}.\n */\nexport interface Queue<T extends any> {\n    length: number;\n    push(value: T): number;\n    shift(): T | undefined;\n    clear(): void;\n}\n\n/**\n * A factory function that returns a {@link Queue}. It will be called with no arguments.\n */\nexport type QueueFactory<T> = () => Queue<T>;\n\n/**\n * async generator function `eventToGenerator`(_queue_) returns _[generator, controller]_\n *\n * Create a generator that can be made to return values to be supplied by a callback.\n * * _queue_: A {@link QueueFactory} function that returns the {@link Queue} to use.\n * * _generator_: The generator being controlled.\n * * _controller_: A {@link Controller} object with the following:\n * >   * `send(`_value_`)`: send the next value to generate.\n * >   * `end()`: Cause the generator to end\n * >   * `throw(`_error_`)`: Cause the generator to throw an exception.\n * >   * `clear()`: Remove any pending queue items.\n *\n * `end` and `throw` are synchronous with the queue. That is, they cause the queue to end or throw\n * when the consumer of the generator has read everything prior in the queue.\n *\n * _queue_ should return a {@link Queue} object that implements `.length`, `.push()`, `.shift()`, and `.clear()`.\n * The default implementation is [Denque](https://github.com/invertase/denque), which is fast for unbounded size.\n *\n * The returned generator may be enhanced with {@link Async_.enhance|Async.enhance} if desired.\n *\n * Other {@link QueueFactory} functions provided:\n * * {@link queue1}: returns a \"queue\" of maximum length 1. Older entries are discarded.\n * * {@link queueSticky}`: Returns a queue that returns the last value seen, forever (or until cleared).\n * * {@link queueOldest}_(n)_: Call with _n_ to set the size; when full new values are discarded.\n * * {@link queueNewest}_(n)_: Call with _n_ to set the size; when full old values are discarded.\n * * {@link queueUnique}: Returns a queue that discards duplicate enqueued values.\n * @returns [AsyncGenerator, {@link Controller}]\n */\nexport const eventToGenerator = <T, R = void>(queue: QueueFactory<T | EndMsg<R>> = () => new Denque()): [AsyncGenerator<T, R>, Controller<T>] => {\n    let unblock: (v?: any) => void = () => undefined;\n    let waiter = null;\n    const q = queue();\n    const send = (v?: any) => (q.push(v), unblock());\n    class EventController implements Controller<T> {\n        send(v?: T) {\n            return send(v);\n        }\n        end(value?: T) {\n           return send({[endTag]: 'return', value})\n        }\n        throw(value: Error) {\n            return send({ [endTag]: 'throw', value });\n        }\n        clear() { return q.clear(); }\n    }\n    async function* eventToGenerator(): AsyncGenerator<T, R> {\n        while (true) {\n            while (!q.length) {\n                waiter = new Promise(a => (unblock = a));\n                await waiter;\n                waiter = null;\n                unblock = () => undefined;\n            }\n            const v = q.shift();\n            if (isReturnMsg<R>(v)) return v.value;\n            if (isThrowMsg(v)) {\n                throw v.value;\n            }\n            yield v as T;\n        }\n    }\n    return [\n        eventToGenerator(),\n        new EventController()\n    ];\n}\n\n/**\n * A {@link QueueFactory} that returns a {@link Queue} of maximum length 1, which discards older values.\n */\nexport const queue1 = <V>(): Queue<V> => {\n    let value: V | undefined,\n        empty = true;\n    class Queue1 implements Queue<V> {\n        get length() { return empty ? 0 : 1}\n        push(v: V) {\n            empty = false;\n            value = v;\n            return 1;\n        }\n        shift() {\n            empty = true;\n            const tmp = value;\n            value = undefined;\n            return tmp;\n        }\n        clear() {\n            empty = true;\n            value = undefined;\n        }\n    }\n    return new Queue1();\n};\n\n/**\n * A {@link QueueFactory} that returns a {@link Queue} of maximum length 1, which discards older\n * values, but returns the last seen forever (until cleared).\n */\nexport const queueSticky = <V>(): Queue<V> => {\n    let value: V | undefined,\n        empty = true;\n    class QueueSticky implements Queue<V> {\n        get length() { return empty ? 0 : 1}\n        push(v: V) {\n            empty = false;\n            value = v;\n            return 1;\n        }\n        shift() {\n            return value;\n        }\n        clear() {\n            empty = true;\n            value = undefined;\n        }\n    }\n    return new QueueSticky();\n}\n\n/**\n * Make a {@link QueueFactory} that returns a {@link Queue} of maximum length _n_,\n * which discards newer values.\n * @param n the number of entries, default = `1`.\n */\nexport const queueOldest = <V>(n: number = 1): QueueFactory<V> => {\n    return (): Queue<V> => {\n        const queue = new Denque();\n        class QueueOldest implements Queue<V> {\n            get length() { return queue.length};\n            push(v: V) {\n                if (queue.length < n) {\n                    return queue.push(v);\n                }\n                // Otherwise, we let it drop.\n                return queue.length;\n            }\n            shift() { return queue.shift(); }\n            clear() { return queue.clear(); }\n        }\n        return new QueueOldest();\n    };\n};\n\n/**\n * Make a {@link QueueFactory} that returns a {@link Queue} of maximum length _n_, which discards older values.\n * @param n the number of entries, default = `1`.\n */\nexport const queueNewest = <V>(n: number = 1): QueueFactory<V> => {\n    return (): Queue<V> => {\n        const queue = new Denque();\n        class QueueNewest implements Queue<V> {\n            get length() { return queue.length; }\n            push(v: V) {\n                while (queue.length >= n) {\n                    queue.shift();\n                }\n                return queue.push(v);\n            }\n            shift() {\n                return queue.shift();\n            }\n            clear() {\n                return queue.clear();\n            }\n        }\n        return new QueueNewest();\n    };\n};\n\nexport type KeyFn = (k: any) => any;\nexport interface QueueUniqueSpec {\n    newest?: boolean;\n    keyFn?: KeyFn;\n}\n/**\n * function queueUnique({newest, keyFn}): () =>\n *\n * Return a {@link QueueFactory}, which supplies {@link Queue} instances that discard\n * already-enqueued entries. Values can be re-enqueued once delivered.\n * * _newest_: if `false` (the default), values are dequeued in the order they were first enqueued. Using `{newest: true}` deprioritizes more active values so less-busy items can get through. But in a sustained-busy situation, there is no guarantee they will ever be delivered. This can be an advantage or disadvantage, depending on requirements.\n * * _keyFn_: A function to identify what values count as \"equal\". The default regards +0 and -0 as the same, NaN's as all the same, and otherwise behaves as `===`.\n * @param spec a {@link QueueUniqueSpec}\n */\nexport const queueUnique = <E>(spec?: QueueUniqueSpec): QueueFactory<E> => {\n    const fn = (newest: boolean, keyFn: KeyFn) => (): Queue<E> => {\n        const queue = new Map();\n        let iter: null | Iterator<E> = null;\n        class QueueUnique implements Queue<E> {\n            get length() { return queue.size; }\n            push(v: any) {\n                const k = keyFn(v);\n                if (newest) {\n                    // As I read the spec, this should not be needed, but experimentally\n                    // in Chrome, it is.\n                    queue.delete(k);\n                    queue.set(k, v);\n                } else if (!queue.has(k)) {\n                    queue.set(k, v);\n                }\n                return queue.size;\n            }\n            shift() {\n                if (!iter) {\n                    iter = queue.values();\n                }\n                const r = iter.next();\n                if (r.done) {\n                    // If values had been added later, they would turn up\n                    // in the iterator, so we're done.\n                    iter = null;\n                    return undefined;\n                }\n                return r.value;\n            }\n            clear() {\n                return queue.clear();\n            }\n        }\n        return new QueueUnique();\n    };\n    if (spec === undefined) {\n        // Called without specifying a length, just return a size=1 queue.\n        return fn(false, i => i);\n    }\n    // Return a function to construct queues of the specified size.\n    return fn(!!spec.newest, spec.keyFn || (i => i));\n};\n\n/**\n * Accepts objects, and returns just the fields that have changed (are no longer `===`).\n *\n * This does not distinguish between deleted keys and keys assigned a value of `undefined` in the input.\n * In the output, a deleted key is represented as present with a value of `undefined`.\n *\n * @param init The initial value\n */\nexport const queueUpdateShallow = <E extends object>(init: Partial<E> = {}) => (): Queue<Partial<E>> => {\n    const state: Partial<E> = { ...init };\n    let pending: Partial<E> = {};\n    let hasPending = false;\n    class QueueUpdateShallow implements Queue<Partial<E>> {\n        get length() { return (hasPending ? 1 : 0); }\n        push(v: E) {\n            const check = (k: Partial<E>) => (Object.keys(k) as (keyof E)[]).forEach(k => {\n                if (state[k] !== v[k]) {\n                    pending[k] = v[k];\n                    hasPending = true;\n                }\n            });\n            check(state);\n            check(v);\n            return 1;\n        }\n        shift() {\n            try {\n                return pending;\n            } finally {\n                Object.assign(state, pending);\n                this.clear();\n            }\n        }\n        clear() {\n            pending = {};\n            hasPending = false;\n        }\n    }\n    return new QueueUpdateShallow();\n};\n","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * This entry point loads asynchronous extended generators\n * @packageDocumentation\n * @module future\n * @preferred\n */\n\n/**\n * A [[Future]] is a variant of a Promise that takes a function to start execution at a later point, when\n * the value is desired. It can be used to delay a computation, or to avoid it entirely if not needed.\n *\n * By default, the computation begins when the first _onfulfilled_ handler is added with {@link then}, but\n * if the _delay_ parameter is supplied as `true` an explicit call to the {@link eval} method is required.\n */\nexport class Future<T> extends Promise<T> {\n    #fn?: () => T;\n    #delay: boolean;\n\n    #accept?: (val: T) => void;\n    #reject?: (err: Error) => void;\n    #result?: T;\n    #error?: Error;\n    static [Symbol.toStringTag] = 'Future';\n    static [Symbol.species] = Promise;\n\n    /**\n     * Construct a {@link Future}.\n     *\n     * The supplied _fn_ argument will be discarded once run, so any data referenced\n     * by it can be freed by the GC.\n     * @param fn The function performing the future calculation\n     * @param delay true if the calculation should be delayed until an explicit call to `eval`.\n     */\n    constructor(fn: () => T, delay?: boolean) {\n        let accept;\n        let reject;\n        super((acc: (val: T) => void, rej: (err: Error) => void) => {\n            accept = acc;\n            reject = rej;\n        });\n        this.#accept = accept;\n        this.#reject = reject;\n        this.#fn = fn;\n        this.#delay = !!delay;\n    }\n\n    /**\n     * Perform the calculation supplied on construction. Takes arguments like {@link Promise#then}. Any pending\n     * handlers from `Promise.then()`, `Promise.catch()`, or `Promise.finally()` will be also be\n     * handled as normal.\n     *\n     * {@link eval} is run synchronously if the supplied function is synchronous. The result is not wrapped in a `Promise`,\n     * but will be a `Promise` if that's what the supplied function returns. The supplied handlers are _not_ run synchronously.\n     * @param onfulfilled\n     * @param onrejected\n     * @returns\n     */\n    eval<TResult1 = T, TResult2 = never>(\n        onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n        onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n        ):\n        T\n    {\n        if (this.#fn) {\n            try {\n                this.#result = this.#fn();\n                this.#accept?.(this.#result);\n                return this.#result;\n            } catch (e) {\n                this.#error = e;\n                this.#reject?.(e);\n                throw e;\n            } finally {\n                this.#fn = undefined;\n                this.#accept = undefined;\n                this.#reject = undefined;\n                if (onfulfilled || onrejected) {\n                    super.then(onfulfilled, onrejected);\n                }\n            }\n        } else if (this.#error) {\n            throw this.#error;\n        } else {\n            return this.#result!;\n        }\n    }\n\n    /**\n     * This runs {@link Promise#then} normally. If the supplied future function has not been run, runs\n     * that first, unless _delay_ was supplied as truthy, or unless neither _onfullfilled_ or _onrejected_\n     * was supplied.\n     * @param onfulfilled\n     * @param onrejected\n     * @returns\n     */\n    then<TResult1 = T, TResult2 = never>(\n        onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n        onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n        ):\n        Promise<TResult1 | TResult2>\n    {\n        if (this.#fn && !this.#delay && (onfulfilled || onrejected)) {\n            try {\n                this.eval();\n            } catch (e) {\n                // Do nothing; will be rejected inside this.eval().\n            }\n        }\n        if (onfulfilled || onrejected) {\n            return super.then(onfulfilled, onrejected);\n        } else {\n            return this as any as Promise<TResult1 | TResult2>;\n        }\n    }\n}","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * Utilities for implementing or using generators.\n * @module util\n */\n\n/**\n * Delay for the specified number of milliseconds.\n *\n * @param ms\n * @param value\n * @returns\n */\nexport const delay = (ms: number, value?: any) =>\n    new Promise(acc => setTimeout(() => acc(value), ms));","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/retirement-simulator\n */\n\n/**\n * Mixin for synchronous iterables.\n *\n * @module\n */\n\nimport { IEnhancements } from \"./ienhancement\";\nimport { Sync } from \"./sync\";\nimport { Constructor, Enhanced, Genable, IndexedFn, IndexedPredicate, Reducer, ReturnValue, SyncEnhancedConstructor, SyncType } from \"./types\";\n\n/**\n * Given a class that implements `Iterable<T, TReturn, TNext>`, this returns a class that implements {@link IEnhancements}, allowing one to treat it as if\n * it were an array, in supporting methods such as {@link IEnhancements.map|.map()} and {@link IEnhancements.filter|.filter()}.\n *\n * Usage:\n *\n * ```typescript\n * class MySyncIterable implements Iterable<number> {\n *   *[Symbol.iterator]() {\n *      yield 1;\n *      yield 2;\n *      yield 3;\n *   }\n * }\n *\n * const MyEnhancedSyncIterable = SyncMixin(MySyncIterable);\n * type MyEnhancedSyncIterable = ConstructorType<typeof MyEnhancedSyncIterable>;\n * const foo = new MyEnhancedSyncIterable();\n * foo.map(i => i * 2).toArray(); => [2, 4, 6]\n * foo.map(i => i + 2).toArray(); => [3, 4, 5]\n * ```\n * @param Base a constructor for a class that implements `Iterable`.\n * @returns a new constructor for an enhanced class.\n */\nexport function SyncMixin<T, TReturn, TNext>(Base: Constructor<Iterable<T>>): new (...args: any[]) => SyncEnhancedConstructor<T, TReturn, TNext, typeof Base> {\n    class SyncMixin extends Base implements IEnhancements<T, TReturn, TNext, 'sync'> {\n        #tag?: string = undefined;\n        constructor(...args: any[]) {\n            super(...args);\n        }\n        #iter() {\n            return Sync.enhance(this[Symbol.iterator]() as Iterator<T, TReturn, TNext>);\n        }\n        asArray(): ReturnValue<T[], 'sync'> {\n            return this.#iter().asArray();\n        }\n        limit(max: number): Enhanced<T, 'sync', TReturn, TNext> {\n            return this.#iter().limit(max);\n        }\n        forEach(f: IndexedFn<T, void, 'sync'>, thisArg?: any): void {\n            return this.#iter().forEach(f, thisArg);\n        }\n        map<V>(f: IndexedFn<T, V, 'sync'>, thisArg?: any): Enhanced<V, 'sync', TReturn, TNext> {\n            return this.#iter().map(f, thisArg);\n        }\n        filter(f: IndexedPredicate<T, 'sync'>, thisArg?: any): Enhanced<T, 'sync', TReturn, TNext> {\n            return this.#iter().filter(f, thisArg);\n        }\n        flat<D extends number = 1>(depth: D = 1 as D) {\n            return this.#iter().flat(depth);\n        }\n        flatMap<D extends number = 1>(f: IndexedFn<T, any, 'sync'>, depth: D = 1 as D) {\n            return this.#iter().flatMap(f, depth);\n        }\n        slice(start: number = 0, end: number = Number.MAX_SAFE_INTEGER): Enhanced<T, 'sync', TReturn | undefined, TNext> {\n            return this.#iter().slice(start, end);\n        }\n        concat<T, TReturn, TNext>(...gens: Genable<T, 'sync', TReturn, TNext>[]): Enhanced<T, 'sync', void | TReturn, TNext> {\n            return this.#iter().concat(...gens);\n        }\n        reduce<A, T, TReturn, TNext>(f: Reducer<A, T, T, 'sync'>): ReturnValue<A, 'sync'>;\n        reduce<A, T, TReturn = T, TNext = T>(f: Reducer<A, T, A, 'sync'>, init: A): ReturnValue<A, 'sync'>;\n        reduce<A>(f: Reducer<A, T, A, 'sync'>, init?: A): ReturnValue<A, 'sync'>;\n        reduce<A>(f: any, init?: any): ReturnValue<A, 'sync'> | ReturnValue<A, 'sync'> | ReturnValue<A, 'sync'> {\n            return this.#iter().reduce(f, init);\n        }\n        some<T>(p: IndexedPredicate<T, 'sync'>, thisArg?: any): ReturnValue<boolean, 'sync'> {\n            return this.#iter().some(p, thisArg);\n        }\n        every(p: IndexedPredicate<T, 'sync'>, thisArg?: any): ReturnValue<boolean, 'sync'> {\n            return this.#iter().every(p, thisArg);\n        }\n        repeatLast(max: number = Number.MAX_SAFE_INTEGER): Enhanced<T, 'sync', void | TReturn, TNext> {\n            return this.#iter().repeatLast(max);\n        }\n        repeat<N>(value: N, repetitions: number = Number.MAX_SAFE_INTEGER): Enhanced<T | N, 'sync', void, TNext> {\n            return this.#iter().repeat(value, repetitions);\n        }\n        join(sep: string = ''): ReturnValue<string, 'sync'> {\n            return this.#iter().join(sep);\n        }\n        sort(cmp?: (a: T, b: T) => number): ReturnValue<T[], 'sync'> {\n            return this.#iter().sort(cmp);\n        }\n        /**\n         * Tag instances with the type and name for easy recognition.\n         * @internal\n         */\n        get [Symbol.toStringTag]() {\n            try {\n                return this.#tag\n                    ?? (this.#tag = `SyncMixin(${Base.name})`);\n            } catch {\n                // This can happen when viewing the prototype, because #tag isn't declared\n                // on the prototype. That screws up ObservableHQ's inspector, which gets an unhandled\n                // failed promise and never completes if you try to expand the real instance, because\n                // it died on the prototype.\n                return `SyncMixin(${Base.name}).prototype`;\n            }\n        }\n\n    }\n    return SyncMixin;\n}","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/retirement-simulator\n */\n\n/**\n * Mixin for asynchronous iterables.\n *\n * @module\n */\n\nimport { IEnhancements } from \"./ienhancement\";\nimport { Async } from \"./async\";\nimport { AsyncEnhancedConstructor, Constructor, Enhanced, Genable, IndexedFn, IndexedPredicate, Reducer, ReturnValue, SyncType } from \"./types\";\n\n/**\n * Given a class that implements `Iterable<T, TReturn, TNext>`, this returns a class that implements {@link IEnhancements}, allowing one to treat it as if\n * it were an array, in supporting methods such as {@link IEnhancements.map|.map()} and {@link IEnhancements.filter|.filter()}.\n *\n * Usage:\n *\n * ```typescript\n * class MyAsyncIterable implements AsyncIterable<number> {\n *   async *[Symbol.Asynciterator]() {\n *      yield 1;\n *      yield 2;\n *      yield 3;\n *   }\n * }\n *\n * const MyEnhancedAsyncIterable = AsyncMixin(MyAsyncIterable);\n * type MyEnhancedAsyncIterable = ConstructorType<typeof MyEnhancedAsyncIterable>;\n * const foo = new MyEnhancedAsyncIterable();\n * await foo.map(i => i * 2).toArray(); => [2, 4, 6]\n * awaot foo.map(i => i + 2).toArray(); => [3, 4, 5]\n * ```\n * @param Base a constructor for a class that implements `AsyncIterable`.\n * @returns a new constructor for an enhanced class.\n */\nexport function AsyncMixin<T, TReturn, TNext>(Base: Constructor<AsyncIterable<T>>): new (...args: any[]) => AsyncEnhancedConstructor<T, TReturn, TNext, typeof Base> {\n    class AsyncMixin extends Base implements IEnhancements<T, TReturn, TNext, 'async'> {\n        #tag?: string = undefined;\n        constructor(...args: any[]) {\n            super(...args);\n        }\n        #iter() {\n            return Async.enhance(this[Symbol.asyncIterator]() as AsyncIterator<T, TReturn, TNext>);\n        }\n        asArray(): ReturnValue<T[], 'async'> {\n            return this.#iter().asArray();\n        }\n        limit(max: number): Enhanced<T, 'async', TReturn, TNext> {\n            return this.#iter().limit(max);\n        }\n        forEach(f: IndexedFn<T, void, 'async'>, thisArg?: any): void {\n            return this.#iter().forEach(f, thisArg);\n        }\n        map<V>(f: IndexedFn<T, V, 'async'>, thisArg?: any): Enhanced<V, 'async', TReturn, TNext> {\n            return this.#iter().map(f, thisArg);\n        }\n        filter(f: IndexedPredicate<T, 'async'>, thisArg?: any): Enhanced<T, 'async', TReturn, TNext> {\n            return this.#iter().filter(f, thisArg);\n        }\n        flat<D extends number = 1>(depth: D = 1 as D) {\n            return this.#iter().flat(depth);\n        }\n        flatMap<D extends number = 1>(f: IndexedFn<T, any, 'async'>, depth: D = 1 as D) {\n            return this.#iter().flatMap(f, depth);\n        }\n        slice(start: number = 0, end: number = Number.MAX_SAFE_INTEGER): Enhanced<T, 'async', TReturn | undefined, TNext> {\n            return this.#iter().slice(start, end);\n        }\n        concat<T, TReturn, TNext>(...gens: Genable<T, 'async', TReturn, TNext>[]): Enhanced<T, 'async', void | TReturn, TNext> {\n            return this.#iter().concat(...gens);\n        }\n        reduce<A, T, TReturn, TNext>(f: Reducer<A, T, T, 'async'>): ReturnValue<A, 'async'>;\n        reduce<A, T, TReturn = T, TNext = T>(f: Reducer<A, T, A, 'async'>, init: A): ReturnValue<A, 'async'>;\n        reduce<A>(f: Reducer<A, T, A, 'async'>, init?: A): ReturnValue<A, 'async'>;\n        reduce<A>(f: any, init?: any): ReturnValue<A, 'async'> | ReturnValue<A, 'async'> | ReturnValue<A, 'async'> {\n            return this.#iter().reduce(f, init);\n        }\n        some<T>(p: IndexedPredicate<T, 'async'>, thisArg?: any): ReturnValue<boolean, 'async'> {\n            return this.#iter().some(p, thisArg);\n        }\n        every(p: IndexedPredicate<T, 'async'>, thisArg?: any): ReturnValue<boolean, 'async'> {\n            return this.#iter().every(p, thisArg);\n        }\n        repeatLast(max: number = Number.MAX_SAFE_INTEGER): Enhanced<T, 'async', void | TReturn, TNext> {\n            return this.#iter().repeatLast(max);\n        }\n        repeat<N>(value: N, repetitions: number = Number.MAX_SAFE_INTEGER): Enhanced<T | N, 'async', void, TNext> {\n            return this.#iter().repeat(value, repetitions);\n        }\n        join(sep: string = ''): ReturnValue<string, 'async'> {\n            return this.#iter().join(sep);\n        }\n        sort(cmp?: (a: T, b: T) => number): ReturnValue<T[], 'async'> {\n            return this.#iter().sort(cmp);\n        }\n        /**\n         * Tag instances with the type and name for easy recognition.\n         * @internal\n         */\n        get [Symbol.toStringTag]() {\n            try {\n                return this.#tag\n                    ?? (this.#tag = `SyncMixin(${Base.name})`);\n            } catch {\n                // This can happen when viewing the prototype, because #tag isn't declared\n                // on the prototype. That screws up ObservableHQ's inspector, which gets an unhandled\n                // failed promise and never completes if you try to expand the real instance, because\n                // it died on the prototype.\n                return `SyncMixin(${Base.name}).prototype`;\n            }\n        }\n\n    }\n    return AsyncMixin;\n}"],"names":["isFunction","f","isGenable","g","isIterator","isIterable","isAsyncGenable","isAsyncIterator","isAsyncIterable","isGenerator","next","return","throw","Symbol","iterator","isAsyncGenerator","asyncIterator","toGenerator","i","it","r","done","value","wrap","Error","toAsyncGenerator","async","toIterator","toAsyncIterator","asyncAdaptor","self","nr","Promise","resolve","e","returning","toIterable","toAsyncIterable","toAsyncIterable_adaptor","iterable","toIterableIterator","_it","iit","val","toAsyncIterableIterator","isIterableIterator","isAsyncIterableIterator","doCatch","onError","args","Enhancements","toStringTag","asArray","this","_impl","limit","max","forEach","thisArg","map","filter","flat","depth","flatMap","slice","start","end","Number","POSITIVE_INFINITY","concat","gens","reduce","init","some","p","every","repeatLast","repeat","repetitions","tail","zip","join","sep","sort","cmp","EnhancedGenerator","Sync","of","values","enhance","gen","limited","err","RangeError","thisArgOrGen","idx","call","undefined","iter","v","genThisArg","x","Set","add","delete","TypeError","depthOrGen","nv","re","length","initOrGen","acc","pred","thisOrGen","genOrThis","last","its","result","push","zip2","genOrSeparator","merge","sources","running","gen2","old","Object","getPrototypeOf","proto","create","prototype","setPrototypeOf","GenProto","Foo","base","newProto","k","Reflect","ownKeys","inherit","makeProto","defineProperty","writable","enumerable","configurable","range","MAX_SAFE_INTEGER","step","range2","Async","then","a","donePromise","active","activeCount","dead","ag","handle","race","assign","EnhancedAsyncGenerator","AsyncGenProto","AsyncFoo","SyncFoo","Denque","array","options","_head","_tail","_capacity","capacity","_capacityMask","_list","Array","isArray","_fromArray","peekAt","index","len","size","get","peek","peekFront","peekBack","unshift","item","_growArray","pop","shift","head","_shrinkArray","removeOne","remove","count","removed","del_count","toArray","clear","splice","arguments","temp","arg_len","arguments_index","leng","isEmpty","_copyArray","fullCopy","newArray","list","denque","endTag","for","isThrowMsg","m","eventToGenerator","queue","unblock","waiter","q","send","queue1","empty","tmp","queueSticky","queueOldest","n","queueNewest","queueUnique","spec","fn","newest","keyFn","Map","set","has","queueUpdateShallow","state","pending","hasPending","check","keys","Future","delay","accept","reject","error","species","constructor","super","rej","eval","onfulfilled","onrejected","ms","setTimeout","SyncMixin","Base","tag","name","AsyncMixin"],"mappings":"AAoBO,MAAMA,EAAkCC,GACvB,mBAANA,EAQLC,EAAwCC,GAE7CA,IAAMC,EAAWD,IAAME,EAAWF,IAG7BG,EAAqCH,GAE1CA,IAAMI,EAAmCJ,IAAMK,EAAmCL,IAAME,EAA8BF,IAMjHM,EAAkCN,GAC3CA,GACAH,EAAWG,EAAEO,OACVV,EAAWG,EAAEQ,SACbX,EAAWG,EAAES,QACbZ,EAAWG,EAAEU,OAAOC,WAMdC,EAAuCZ,GAChDA,GACAH,EAAWG,EAAEO,OACVV,EAAWG,EAAEQ,SACbX,EAAWG,EAAES,QACbZ,EAAWG,EAAEU,OAAOG,yBAWXC,EAAuCC,GACnD,GAAIT,EAAYS,GAAI,OAAOA,EAC3B,GAAId,EAAWc,GAAI,CACf,MAAMC,EAAKD,EAUX,OARA,YACI,OAAa,CACT,MAAME,EAAID,EAAGT,OACb,GAAIU,EAAEC,KAAM,OAAOD,EAAEE,YACfF,EAAEE,OAITC,GACJ,GAAIlB,EAAWa,GAClB,OAAOD,EAAYC,EAAEL,OAAOC,aAE5B,MAAM,IAAIU,MAAM,iBAAiBN,cAczBO,EAAoCP,GAGhD,GAAIH,EAAiBG,GAAI,OAAOA,EAChC,GAAIX,EAAgBW,GAAI,CACpB,MAAMC,EAAKD,EAQX,OAPAQ,kBACI,OAAa,CACT,MAAMN,QAAUD,EAAGT,OACnB,GAAIU,EAAEC,KAAM,OAAOD,EAAEE,YACfF,EAAEE,OAGTC,GACJ,GAAIf,EAAgBU,GACvB,OAAOO,EAAiBP,EAAEL,OAAOG,kBAC9B,GAAIX,EAAWa,GAClB,OAAOO,EAAiBP,EAAEL,OAAOC,aAEjC,MAAM,IAAIU,MAAM,iBAAiBN,cASzBS,EAA8BT,GAC1C,GAAIT,EAAYS,GAAI,OAAOA,EAC3B,GAAId,EAAWc,GAAI,OAAOA,EAC1B,GAAIb,EAAWa,GACX,OAAOA,EAAEL,OAAOC,YAEhB,MAAM,IAAIU,MAAM,iBAAiBN,cAUzBU,EAAuCV,GACnD,GAAIH,EAAiBG,GAAI,OAAOA,EAChC,GAAIV,EAAgBU,GAChB,OAAOA,EAAEL,OAAOG,iBACb,GAAIX,EAAWa,GAClB,OAAOW,EAAaF,EAAWT,IAE/B,MAAM,IAAIM,MAAM,iBAAiBN,KAIzC,MAAMW,EAAmCX,IAGrC,MAAMC,EAAKD,EACX,IAAIY,EAwBJ,OAAOA,EAvBPJ,kBACI,IAAIK,EACAV,GAAO,EACX,IACI,OAAa,CACT,MAAMD,QAAUY,QAAQC,QAAQd,EAAGT,QACnC,GAAIU,EAAEC,KAEF,OADAA,GAAO,EACAD,EAAEE,MAEb,IACIS,QAAWX,EAAEE,MACf,MAAOY,GAEL,YADMf,EAAGP,QAAQsB,gBAKpBb,SACKH,EAAEP,SAASmB,EAAKK,aAIpBN,aASFO,EAAsClB,GAGlD,OAAIb,EAAWa,GAAWA,EACnB,CACH,CAACL,OAAOC,UAAW,IAAMI,YAWjBmB,EAAmCnB,GAG/C,OAAIV,EAAmCU,GAAWA,EAC9Cb,EAA8Ba,GACvBoB,EAA2CpB,GAG/C,CACH,CAACL,OAAOG,eAAgB,IAAME,GAGtCQ,eAAgBY,EAA2CC,GAGvD,MAAMpB,EAAKoB,EAAS1B,OAAOC,YAC3B,IAAIiB,EACJ,OAAa,CACT,MAAMX,QAAUD,EAAGT,KAAKqB,GACxB,GAAIX,EAAEC,KAAM,OAAOD,EAAEE,MACrBS,QAAWX,EAAEE,gBASLkB,EAA8CtB,GAC1D,GAAIb,EAAWa,IAAMd,EAAWc,GAAI,OAAOA,EAC3C,GAAIb,EAAWa,GAAI,CAEf,IAAIuB,EACJ,MAAMtB,EAAK,IAAMsB,IAAQA,EAAMvB,EAAEL,OAAOC,aAClC4B,EAAqD,CACvD,CAAC7B,OAAOC,UAAW,IAAM4B,EACzBhC,KAAOiC,GAAgBxB,IAAKT,KAAKiC,GACjChC,OAAQQ,IAAKR,SAAYgC,GAAQxB,IAAKR,OAAQgC,IAC9C/B,MAAOO,IAAKP,QAAW+B,GAAQxB,IAAKP,MAAO+B,KAE/C,OAAOD,EAEX,GAAItC,EAAWc,GAAI,CACf,MAAMwB,EAAqD,CACvD,CAAC7B,OAAOC,UAAW,IAAM4B,EACzBhC,KAAOiC,GAAgBzB,EAAER,KAAKiC,GAC9BhC,OAAQO,EAAEP,SAAYgC,GAAQzB,EAAEP,OAAQgC,IACxC/B,MAAOM,EAAEN,QAAW+B,GAAQzB,EAAEN,MAAO+B,KAEzC,OAAOD,EAEX,MAAM,IAAIlB,MAAM,8BAA8BN,cASlC0B,EAA2C1B,GAGvD,GAAIV,EAAmCU,IAAMX,EAAmCW,GAC5E,OAAOA,EAEX,GAAIV,EAAmCU,GAAI,CAEvC,IAAIuB,EACJ,MAAMtB,EAAK,IAAMsB,IAAQA,EAAMvB,EAAEL,OAAOG,kBAClC0B,EAAgC,CAClC,CAAC7B,OAAOG,eAAgB,IAAM0B,EAC9BhC,KAAM,IAAMS,IAAKT,OACjBC,OAAQQ,IAAKR,SAAYgC,GAAQxB,IAAKR,OAAQgC,IAC9C/B,MAAOO,IAAKP,QAAW+B,GAAQxB,IAAKP,MAAO+B,KAE/C,OAAOD,EAEX,GAAIrC,EAA8Ba,GAC9B,OAAOoB,EAAwBpB,GAEnC,GAAIX,EAAgBW,GAAI,CACpB,MAAMwB,EAAgC,CAClC,CAAC7B,OAAOG,eAAgB,IAAM0B,EAC9BhC,KAAOiC,GAAazB,EAAER,KAAKiC,GAC3BhC,OAAQO,EAAEP,SAAYgC,GAAQzB,EAAEP,OAAQgC,IACxC/B,MAAOM,EAAEN,QAAW+B,GAAQzB,EAAEN,MAAO+B,KAEzC,OAAOD,EAEX,MAAM,IAAIlB,MAAM,8BAA8BN,WAUrCd,EAAyCc,GAE9CA,GAAuB,mBAAXA,EAAER,KASTH,EAA8CW,GAEnDA,GAAuB,mBAAXA,EAAER,KAOTL,EAAyCa,GAClDA,GAAmC,mBAAvBA,EAAEL,OAAOC,UAOZN,EAA8CU,GAEnDA,GAAwC,mBAA5BA,EAAEL,OAAOG,eAOhB6B,EAAiD3B,GAEtDd,EAAWc,IAAMb,EAAWa,GAOvB4B,EAAsD5B,GAE3DX,EAAgBW,IAAMV,EAAgBU,GAOjC6B,EAAU,CAAqB9C,EAAsB+C,IAEvD,IAAIC,KACP,IACI,OAAOhD,KAAKgD,GACd,MAAOf,GACL,OAAOc,IAAUd,WChVPgB,EAOlBf,UA2BA,CAACtB,OAAOsC,aAURC,UACI,OAAOC,KAAKC,MAAMF,QAA2BC,MAQjDE,MAAMC,GACF,OAAOH,KAAKC,MAAMC,MAAMC,EAAKH,MASjCI,QAAQxD,EAA0ByD,GAC9BL,KAAKC,MAAMG,QAA2BxD,EAAGyD,EAASL,MAUtDM,IAAO1D,EAAuByD,GAC1B,OAAOL,KAAKC,MAAMK,IAAI1D,EAAGyD,EAASL,MAWtCO,OAAO3D,EAA2ByD,GAC9B,OAAOL,KAAKC,MAAMM,OAAO3D,EAAGyD,EAASL,MAWzCQ,KAAuBC,EAAW,GAC9B,OAAOT,KAAKC,MAAMO,KAA2BC,EAAOT,MAYxDU,QAA8B9D,EAAmC6D,EAAW,GAGxE,OAAOT,KAAKC,MAAMS,QAA6C9D,EAAG6D,EAAOT,MAS7EW,MAAMC,EAAgB,EAAGC,EAAcC,OAAOC,mBAC1C,OAAOf,KAAKC,MAAMU,MAAMC,EAAOC,EAAKb,MAUxCgB,UAA6BC,GAIzB,OAAOjB,KAAKC,MAAMe,OADLhB,QACqBiB,GAiBtCC,OAAUtE,EAAwBuE,GAC9B,OAAOnB,KAAKC,MAAMiB,OAA6BtE,EAAGuE,EAAWnB,MAWjEoB,KAAQC,EAA2BhB,GAG/B,OAAOL,KAAKC,MAAMmB,KAAKC,EAAGhB,EAASL,MAWvCsB,MAAMD,EAA2BhB,GAC7B,OAAOL,KAAKC,MAAMqB,MAAMD,EAAGhB,EAASL,MAUxCuB,WAAWpB,EAAcW,OAAOC,mBAC5B,OAAOf,KAAKC,MAAMsB,WAAWvB,KAAMG,GAYvCqB,OAAUvD,EAAUwD,EAAsBX,OAAOC,mBAC7C,MAAMW,EAAO1B,KAAKC,MAAMuB,OAAyBvD,EAAOwD,GAKxD,OAJezB,KAAKC,MAAMe,OACtBhB,KACA0B,GAcRC,OAAuEV,GAGnE,OAAOjB,KAAKC,MAAM0B,IAAI3B,QAA0CiB,GAUpEW,KAAKC,GACD,OAAO7B,KAAKC,MAAM2B,KAAK5B,KAAM6B,GAOjCC,KAAKC,GACD,OAAO/B,KAAKC,MAAM6B,KAAKC,EAAhB/B,CAAqBA,aC+0BdgC,UACVnC,EAIR,CAACrC,OAAOsC,aAMZ,MAAMmC,EAA2B,IAtlCjC,MAKIC,MAAuCC,GAGnC,OAAOnC,KAAKoC,QAAQD,GAOxBpC,QAA2BsC,GAGvB,MAAO,IAAItD,EAA8BsD,IAO7CnC,MAAyBC,EAAakC,GAIlC,IAAI5D,EACJ,SAAUyB,EAAyBmC,GAC/B,IAAI3D,EACA4D,GAAmB,EACvB,IACI,IAAK,IAAIzE,EAAI,EAAGA,EAAIsC,EAAKtC,IAAK,CAC1B,MAAME,EAAIsE,EAAIhF,KAAKqB,GACnB,GAAIX,EAAEC,KACF,OAAOD,EAAEE,MAEb,IACIS,QAAWX,EAAEE,MACf,MAAOY,GACLwD,EAAI9E,QAAQsB,IAGpByD,GAAU,EACV,MAAMC,EAAM,IAAIC,WAAW,yCAAyCrC,MAEpE,MADAkC,EAAI9E,QAAQgF,GACNA,UAEDD,GACDD,EAAI/E,SAASmB,GAAMK,YAK/B,OAAIuD,EACO5D,EAAOuB,KAAKoC,QAAQlC,EAAM5B,EAAW+D,KAErBA,GACvBrC,KAAKoC,QAAQlC,EAAM5B,EAAW+D,KAkCtCjC,QACQxD,EACA6F,EACAJ,GAGJ,MAAMjC,EAAU,CAAiBxD,EAA6ByD,EAAcgC,KAGpE,MAAMvE,EAAKQ,EAAW+D,GACtB,IAAIK,EAAM,EACV,OAAa,CACT,MAAM3E,EAAID,EAAGT,OACb,GAAIU,EAAEC,KAAM,OACZpB,EAAE+F,KAAKtC,EAAStC,EAAEE,MAAOyE,OAGrC,OAAIL,EAAYjC,EAAQxD,EAAG6F,EAAcJ,GACrCxF,EAAa4F,GAAsBrC,EAAQxD,OAAGgG,EAAWH,GACtD,CAAiBJ,EAAuChC,IAC3DD,EAAwBxD,EAAGyD,GAAWoC,EAAcJ,GAW5D/B,IAA0B1D,EAA0ByD,EAAkDwC,GAKlG,MAAMvC,EAAM,CAAiBD,EAAcwC,KACvC,MAAMR,EAAMzE,EAAYiF,GACxB,IAAIpE,EA6BJ,OAAOA,EAAOuB,KAAKoC,QA5BnB,YACI,IAAI1D,EACAgE,EAAM,EACV,OAEI,OACI,IACI,OAAa,CACT,MAAM3E,EAAIsE,EAAIhF,KAAKqB,GACnB,GAAIX,EAAEC,KAAM,OAAOD,EAAEE,MACrB,MAAM6E,EAAOlG,EAAE+F,KAAKtC,EAAStC,EAAEE,MAAOyE,KACtC,IACIhE,QAAWoE,EACb,MAAOjE,GACLwD,EAAI9E,MAAMsB,aAMlB,IAFUwD,EAAI/E,OAAOmB,GAAMK,WAEpBd,KAEH,OAMOsC,KAE/B,OAAIuC,EAAavC,EAAID,EAASwC,GAC1BhG,EAA6BwD,GAAiBC,OAAIsC,EAAWvC,GAC1D,CAAiBgC,EAAsCU,IAC1DzC,EAAIyC,GAAc1C,EAASgC,GA0DnC9B,OACI3D,EACAyD,EACAwC,GAKA,MAAMtC,EAAS,CAAiBF,EAAcwC,KAC1C,MAAMR,EAAMzE,EAAYiF,GACxB,IAAIpE,EA8BJ,OAAOA,EAAOuB,KAAKoC,QA7BnB,UAAoBxF,GAChB,IAAI8B,EACAgE,EAAM,EACV,OAEI,OACI,IACI,OAAa,CACT,MAAM3E,EAAIsE,EAAIhF,KAAKqB,GACnB,GAAIX,EAAEC,KAAM,OAAOD,EAAEE,MACrB,GAAIrB,EAAE+F,KAAKtC,EAAStC,EAAEE,MAAOyE,KACzB,IACIhE,QAAWX,EAAEE,MACf,MAAOY,GACLwD,EAAI9E,MAAMsB,aAKtB,MAAMmE,EAAIX,EAAI/E,SAASmB,GAAMK,WAE7B,IAAKkE,GAAGhF,KAEJ,OAMOuC,CAAO3D,KAGtC,OAAIiG,EAAatC,EAAOF,EAASwC,GAC7BhG,EAAawD,GAAiBE,OAAOqC,EAAWvC,GAC7C,CAAiBgC,EAAuCU,IAC3DxC,EAAOwC,GAAc1C,EAASgC,GAqCtC7B,KACIC,EACA4B,GAKA,MAAM7B,EAAO,CAAoBC,EAAU4B,KACvC,IAAI5D,EACJ,MAAMwC,EAAO,IAAIgC,IA4CjB,OA3CI7F,EAAYiF,IAAMpB,EAAKiC,IAAIb,GA2CxB5D,EAAOuB,KAAKoC,QAzCnB,SAAU5B,EAAuB1C,EAAuC2C,GACpE,IAAI/B,EACJ,OAEI,OACI,IACI,OAAa,CACT,MAAMX,EAAID,EAAGT,KAAKqB,GAClB,GAAIX,EAAEC,KAAM,OAAOD,EAAEE,MACrB,MAAM6E,EAAI/E,EAAEE,MACRb,EAAY0F,IACZ7B,EAAKiC,IAAIJ,GAEb,IACQrC,EAAQ,GAAK1D,EAAoC+F,SAC1CtC,EAAKsC,EAAGrC,EAAQ,GAChBA,EAAQ,GAAKzD,EAAW8F,SACxBtC,EAAKlC,EAAoCwE,GAAIrC,EAAQ,GAE5D/B,QAAWX,EAAEE,MAEnB,MAAOY,GACLf,EAAGP,QAAQsB,aAInB,MAAMmE,EAAIlF,EAAGR,SAASmB,GAAMK,WAG5B,GAFI1B,EAAYU,IAAKmD,EAAKkC,OAAOrF,GAE7BkF,IAAMA,EAAEhF,KAER,MAEJ,IAAK,MAAMlB,KAAKmE,EACZnE,EAAEQ,OAAOmB,GAAMK,YAOR0B,CAAKlC,EAAW+D,GAAM5B,KAErD,GAAqB,iBAAVA,EAAoB,CAC3B,GAAI4B,EAAK,CACL,GAAIxF,EAAUwF,GACV,OAAO7B,EAAKC,EAAO4B,GAEnB,MAAM,IAAIe,UAAU,oBAAoBf,KAGhD,OAA2BA,GACvB7B,EAAKC,EAAO4B,GACb,GAAIxF,EAAU4D,GACjB,OAAOD,EAAM6B,GAAO,EAAS5B,GAEjC,MAAM,IAAI2C,UAAU,+BAqDxB1C,QACQ9D,EACAyG,EACAhB,GAYJ,MAAM3B,EAAU,CAAoBD,EAAU4B,KAC1C,IAAI5D,EACAiE,EAAM,EAkDV,OAAOjE,EAAOuB,KAAKoC,QAhDnB,SAAU1B,EAA6C5C,EAAiC2C,GAGpF,IAAI/B,EACJ,OAEI,OACI,IACI,OAAa,CACT,MAAMX,EAAID,EAAGT,KAAKqB,GAClB,GAAIX,EAAEC,KAAM,OAAOD,EAAEE,MACrB,MAAM6E,EAAIlG,EAAEmB,EAAEE,MAAuByE,KACrC,IACQ3F,EAAoC+F,GAChCrC,EAAQ,QACDC,EAAQoC,EAAGrC,EAAQ,GACT,IAAVA,QACA7C,EAAYkF,SAEbA,EAEH9F,EAAW8F,GACdrC,EAAQ,QACDC,EAAQpC,EAAoCwE,GAAIrC,EAAQ,GAC9C,IAAVA,QACA7C,EAAYkF,SAEbA,EAGVpE,QAAYoE,EAElB,MAAOjE,GACLf,EAAGP,QAAQsB,aAInB,MAAMmE,EAAIlF,EAAGR,SAASmB,GAAMK,WAE5B,GAAIkE,IAAMA,EAAEhF,KAER,OAOO0C,CAAQpC,EAAW+D,GAAM5B,KAGxD,OAAI5D,EAAUwF,GACH3B,EAAQ2C,GAAmB,EAAQhB,GACnCxF,EAAWwG,GACX3C,EAAQ,EAAQ2C,GAEpB,CAAoBhB,EAAuC5B,IAC9DC,EAAQ2C,GAAc5C,GAAS,EAAQ4B,GAuB/C1B,MAAyBC,EAAeC,EAAagC,GAOjD,MAAMlC,EAA4BkC,IAG1B,MAAM/E,EAAKQ,EAAWuE,GAqCtB,OAAO7C,KAAKoC,QApCZ,UAAgBxB,EAAeC,GAC3B,IAAK,IAAIhD,EAAI,EAAGA,EAAI+C,EAAO/C,IAAK,CAC5B,MAAME,EAAID,EAAGT,OACb,GAAIU,EAAEC,KAAM,OAAOD,EAAEE,MAEzB,GAAI4C,IAAQC,OAAOC,wBACRhC,EAAWjB,OACf,CACH,IAAIwF,EACJ,OACI,IACI,IAAK,IAAIzF,EAAI+C,EAAO/C,EAAIgD,EAAKhD,IAAK,CAC9B,MAAME,EAAID,EAAGT,KAAKiG,GAClB,GAAIvF,EAAEC,KAAM,OAAOD,EAAEE,MACrB,IACIqF,QAAWvF,EAAEE,MACf,MAAOY,GACL,MAAM0E,EAAKzF,EAAGP,QAAQsB,GACtB,GAAI0E,EAAI,CACJ,GAAIA,EAAGvF,KAAM,OAAOuF,EAAGtF,MACvBqF,QAAWC,EAAGtF,iBAK1B,MAAM+E,EAAIlF,EAAGR,WAEb,GAAI0F,IAAMA,EAAEhF,KAER,QAOA2C,CAAMC,EAAOC,KAEzC,OAAKgC,EACElC,EAAMkC,GADKlC,EAUtBK,UAGKC,GAGD,IAAIxC,EAiBJ,OAAOA,EAAOuB,KAAKoC,QAhBnB,YACI,IAAIvE,EAAI,EACR,IACI,KAAOA,EAAIoD,EAAKuC,OAAQ3F,UACbkB,EAA6BkC,EAAKpD,YAI7C,KAAOA,EAAIoD,EAAKuC,OAAQ3F,IAAK,CACzB,MAAMf,EAAImE,EAAKpD,GACXT,EAAYN,IACZA,EAAEQ,OAAOmB,GAAMK,aAKJkC,IAyD/BE,OACItE,EACA6G,EACApB,GAOA,MAAMnB,EAAS,CAACC,EAAqBrD,KACjC,IAAI4F,EAAyBvC,EAC7B,QAAYyB,IAARc,EAAmB,CACnB,MAAM3F,EAAID,EAAGT,OACb,GAAIU,EAAEC,KAAM,MAAM,IAAIoF,UAAU,8BAChCM,EAAM3F,EAAEE,MAEZ,OAAa,CACT,MAAMF,EAAID,EAAGT,OACb,GAAIU,EAAEC,KAAM,OAAO0F,EACnBA,EAAM9G,EAAE8G,EAAK3F,EAAEE,SAGvB,OAAIpB,EAAUwF,GACHnB,EAAOuC,EAAgBnF,EAAW+D,IAClCxF,EAAU4G,GACVvC,OAAO0B,EAAWtE,EAAWmF,IAEjC,CAAepB,EAAqClB,IACvDD,EAAOC,GAAQsC,EAAWnF,EAAW+D,IAiD7CjB,KACIuC,EACAC,EACAvB,GAMA,MAAMjB,EAAO,CAAiBf,EAAcvC,KACxC,IAAID,EAAI,EACR,OAAa,CACT,MAAME,EAAID,EAAGT,OACb,GAAIU,EAAEC,KAAM,OAAO,EACnB,GAAI2F,EAAKhB,KAAKtC,EAAStC,EAAEE,MAAOJ,KAAM,OAAO,IAGrD,OAAIhB,EAAUwF,GACHjB,EAAKwC,EAAWtF,EAAW+D,IAC3BxF,EAA6B+G,GAC7BxC,OAAKwB,EAAWtE,EAAWsF,IAE3B,CAAiBvB,EAAuChC,IAC3De,EAAqBf,GAAWuD,EAAWtF,EAAW+D,IAkDlEf,MACIqC,EACAE,EACAxB,GAQA,MAAMf,EAAQ,CAAiBjB,EAAcvC,KACzC,IAAID,EAAI,EACR,OAAa,CACT,MAAME,EAAID,EAAGT,OACb,GAAIU,EAAEC,KAAM,OAAO,EACnB,IAAK2F,EAAKhB,KAAKtC,EAAStC,EAAEE,MAAOJ,KAAM,OAAO,IAGtD,GAAIhB,EAAUwF,GACV,OAAOf,EAAMuC,EAAWvF,EAAW+D,IAChC,GAAIxF,EAAUwF,GACjB,MAAO,CAAiBA,EAAuChC,IAC3DiB,EAAMjB,GAAWwD,EAAWvF,EAAW+D,IAE/C,MAAM,IAAIlE,MAAM,8BAA8BkE,GAAOwB,KAUzDtC,WACIc,EACAlC,EAAcW,OAAOC,mBAIrB,MAAMjD,EAAKQ,EAAW+D,GACtB,IAAI3D,EACAD,EA0BJ,OAAOA,EAAOuB,KAAKoC,QAxBnB,YACI,IACI,IAAI0B,EACJ,OAAa,CACT,MAAM/F,EAAID,EAAGT,KAAKqB,GAClB,GAAIX,EAAEC,KAAM,MACZ,IACIU,QAAYoF,EAAO/F,EAAEE,MACvB,MAAOY,GACL,MAAM0E,EAAKzF,EAAGP,QAAQsB,GACtB,GAAI0E,EAAI,CACJ,GAAIA,EAAGvF,KAAM,YACP8F,EAAOP,EAAGtF,QAI5B,IAAK,IAAIJ,EAAI,EAAGA,EAAIsC,EAAKtC,UACfiG,UAGVhG,EAAGR,SAASmB,GAAMK,YAICyC,IAS/BC,OAA0BvD,EAAUwD,EAAsBX,OAAOC,mBAS7D,OAAOf,KAAKoC,QANZ,YACI,IAAK,IAAIvE,EAAI,EAAGA,EAAI4D,EAAa5D,UACvBI,EAIMuD,IAWxBG,OAA0BV,GAGtB,GAAoB,IAAhBA,EAAKuC,OAAc,OAAOxD,KAAKoC,QAAQ,IAC3C,MAAM2B,EAAM9C,EAAKX,IAAIhC,GACrB,IACIG,EADAT,GAAO,EA2CX,OAAOS,EAAOuB,KAAKoC,QAxCnB,YACI,IACI,OAAa,CACT,IAAI4B,EAAmB,GACvB,IAAK,MAAMlH,KAAKiH,EAAK,CACjB,MAAMhG,EAAIjB,EAAEO,OACZ,GAAIU,EAAEC,KAEF,OADAA,GAAO,EACAD,EAAEE,MAEZ+F,EAAiBC,KAAKlG,EAAEE,OAE7B,UACU+F,EACR,MAAOnF,GACL,IAAK,MAAM/B,KAAKmE,EACZ,IAEKnE,EAAUS,QAAQsB,GACrB,OAIN,MAAMA,YAId,IAAKb,EACD,IAAK,MAAMlB,KAAKmE,EACZ,IAEKnE,EAAUQ,SAASmB,GAAMK,WAC5B,SAQSoF,IAmB/BtC,KACIuC,EACAtC,GAKA,MAA8B,iBAAnBsC,GACPtC,EAAMsC,EACqB9B,GACvBrC,KAAK4B,KAAKS,EAAKR,IAEhB,IAAI9C,EAAWoF,IAAiBvC,KAAKC,GAchDuC,SAA4BC,GAGxB,IAAI5F,EACAwC,EAAkDoD,EAAQ/D,IAAIhC,GAmClE,OAAOG,EAAOuB,KAAKoC,QAlCnB,UAAmCnB,GAG/B,IAEIqC,EAFAtF,GAAO,EACPsG,GAAU,EAEd,IACI,KAAOA,GAAS,CACZA,GAAU,EACV,IAAK,IAAIzG,EAAI,EAAGA,EAAIoD,EAAKuC,OAAQ3F,IAAK,CAClC,MAAMf,EAAImE,EAAKpD,GACf,GAAIf,EAAG,CACH,MAAMiB,EAAIjB,EAAEO,KAAKiG,GACjB,GAAIvF,EAAEC,KACFiD,EAAKpD,GAAK,SACP,CACHyG,GAAU,EACV,IACIhB,QAAWvF,EAAEE,MACf,MAAOY,GACLoC,EAAKb,QAAQV,GAAQ5C,GAAKA,GAAGS,QAAQsB,UAMzDb,GAAO,UAEFA,GACDiD,EAAKb,QAAQV,GAAQ5C,GAAKA,GAAGQ,SAASmB,GAAMK,cAGpD,OAAOL,GAAMK,UAEUsF,CAAMnD,IAOrCa,KAAQC,GACJ,MAAO,IAAoBsC,IACHrE,KAAKoE,SAASC,GAAStE,UAC7B+B,KAAKC,GAQ3BK,QAA2BC,GAGvB,MAAMkC,EAAO3G,EAAYyE,GACnBmC,EAAMC,OAAOC,eAAeH,GAC5BI,EAAQF,OAAOG,OAAO5C,EAAkB6C,WAI9C,OAHAF,EAAMrH,OAAUwF,IAAgByB,EAAKzF,UAAYgE,EAAG0B,EAAIlH,OAAOqF,KAAK4B,EAAMzB,IAC1E6B,EAAMnH,OAAOC,UAAY,IAAM8G,EAC/BE,OAAOK,eAAeP,EAAMvC,EAAkB6C,WACvCN,IA8DR,MAAMQ,EAAWN,OAAOC,eAN/B,aAM8CM,IAG9CP,OAAOK,eAAe9C,EAAkB6C,UA1BtB,CAACI,IACf,MAAMC,EAAWT,OAAOG,OAAOK,GAS/B,MARgB,CAACN,IACb,IAAK,MAAMQ,KAAKC,QAAQC,QAAQV,GAClB,gBAANQ,IACAD,EAASC,GAAKR,EAAMQ,KAIhCG,CAAQzF,EAAagF,WACdK,GAgBwCK,CAAUR,IAC7DN,OAAOe,eAAexD,EAAkB6C,UAAW,QAAS,CACxD5G,MAAOgE,EACPwD,UAAU,EACVC,YAAY,EACZC,cAAc,UC3nCLC,EAAQ,CAAChF,EAAQ,EAAGC,EAAMC,OAAO+E,iBAAkBC,EAAO,IAiB5D7D,EAAKG,QAhBZ,UAAiBxB,EAAQ,EAAGC,EAAMC,OAAO+E,iBAAkBC,EAAO,GAC9D,IAAI9C,EAAIpC,EACR,GAAIkF,EAAO,EACP,KAAO9C,EAAInC,SACDmC,EACNA,GAAK8C,MAEN,CAAA,KAAIA,EAAO,GAMd,MAAM,IAAI3H,MAAM,0BALhB,KAAO6E,EAAInC,SACDmC,EACNA,GAAK8C,GAMGC,CAAOnF,EAAOC,EAAKiF,IC4oC3C,MAAME,EAA6B,IAzpCnC,MAKI9D,MAAuCC,GAGnC,OAAOnC,KAAKoC,QAAQD,GAGxBpC,cAAiCsC,GAG7B,MAAMvE,EAAKS,EAAgB8D,GACrB2B,EAAc,GACpB,OAAa,CACT,MAAMjG,QAAUD,EAAGT,OACnB,GAAIU,EAAEC,KACF,OAAOgG,EAEXA,EAAOC,KAAKlG,EAAEE,QAUtBiC,MACIC,EACAkC,GAKA,IAAI5D,EACJJ,eAAgB6B,EAAiCmC,GAC7C,IAAI3D,EACA4D,GAAmB,EACvB,IACI,IAAK,IAAIzE,EAAI,EAAGA,EAAIsC,EAAKtC,IAAK,CAC1B,MAAME,QAAesE,EAAIhF,KAAKqB,GAC9B,GAAIX,EAAEC,KACF,OAAOD,EAAEE,MAEb,IACIS,QAAWX,EAAEE,MACf,MAAOY,SACCwD,EAAI9E,QAAQsB,KAG1ByD,GAAU,EACV,MAAMC,EAAM,IAAIC,WAAW,yCAAyCrC,MAEpE,YADMkC,EAAI9E,QAAQgF,IACZA,UAEDD,SACKD,EAAI/E,SAASmB,GAAMK,aAKrC,OAAIuD,EACO5D,EAAOuB,KAAKoC,QAAQlC,EAAM3B,EAAgB8D,KAElBA,GAC/BrC,KAAKoC,QAA2BlC,EAAM3B,EAAgB8D,KA6C9DjC,QACIxD,EACA6F,EACAJ,GAKA,MAAMjC,EAAU/B,MACQzB,EACAyD,EACAgC,KAGhB,MAAMvE,EAAKS,EAAgB8D,GAC3B,IAAIK,EAAM,EACV,OAAa,CACT,MAAM3E,QAAUD,EAAGT,OACnB,GAAIU,EAAEC,KAAM,aACNpB,EAAE+F,KAAKtC,EAAStC,EAAEE,MAAOyE,OAG3C,OAAIL,EAAYjC,EAAQxD,EAAG6F,EAAcJ,GACrCpF,EAAkCwF,GAAsBrC,EAAQxD,OAAGgG,EAAWH,GAC3E,CAAyBJ,EAAwChC,IACpED,EAAQxD,EAAGyD,GAAWoC,EAAcJ,GAe5C/B,IACI1D,EACAyD,EACAwC,GAQA,MAAMvC,EAAM,CAAyBD,EAAcwC,KAC/C,MAAMR,EAAMjE,EAAiByE,GAC7B,IAAIpE,EA6BJ,OAAOA,EAAOuB,KAAKoC,QA5BnB/D,kBACI,IAAIK,EACAgE,EAAM,EACV,OAEI,OACI,IACI,OAAa,CACT,MAAM3E,QAAUsE,EAAIhF,KAAKqB,GACzB,GAAIX,EAAEC,KAAM,OAAOD,EAAEE,MACrB,MAAM6E,QAAUlG,EAAE+F,KAAKtC,QAAetC,EAAEE,MAAOyE,KAC/C,IACIhE,QAAWoE,EACb,MAAOjE,SACCwD,EAAI9E,MAAMsB,aAMxB,WAFgBwD,EAAI/E,OAAOmB,GAAMK,YAE1Bd,KAEH,OAMOsC,KAE/B,OAAIuC,EAAavC,EAAID,EAASwC,GAC1B5F,EAAkCoD,GAAiBC,OAAIsC,EAAWvC,GAC/D,CAAiBgC,EAAwCU,IACpDzC,EAAIyC,GAAc1C,EAASgC,GA2D3C9B,OACI3D,EACAyD,EACAwC,GAKA,MAAMtC,EAAS,CAAiBF,EAAcwC,KAC1C,MAAMR,EAAMjE,EAAoCyE,GAChD,IAAIpE,EA8BJ,OAAOA,EAAOuB,KAAKoC,QA7BnB/D,gBAA0BzB,GACtB,IAAI8B,EACAgE,EAAM,EACV,OAEI,OACI,IACI,OAAa,CACT,MAAM3E,QAAUsE,EAAIhF,KAAKqB,GACzB,GAAIX,EAAEC,KAAM,OAAOD,EAAEE,MACrB,SAAUrB,EAAE+F,KAAKtC,EAAStC,EAAEE,MAAOyE,KAC/B,IACIhE,QAAWX,EAAEE,MACf,MAAOY,SACCwD,EAAI9E,MAAMsB,aAO5B,WAFgBwD,EAAI/E,SAASmB,GAAMK,cAE3Bd,KAEJ,OAMOuC,CAAO3D,KAGtC,OAAIiG,EAAatC,EAAOF,EAASwC,GAC7B5F,EAAkCoD,GAAiBE,OAAOqC,EAAWvC,GAClE,CAAiBgC,EAAwCU,IAC5DxC,EAAuBwC,GAAc1C,EAASgC,GAyCtD7B,KAA0CC,EAA4C4B,GAKlF,MAAM7B,EAAO,CAAoBC,EAAU4B,KACvC,IAAI5D,EACJ,MAAMwC,EAAO,IAAIgC,IA4CjB,OA3CIvF,EAAiB2E,IAAMpB,EAAKiC,IAAIb,GA2C7B5D,EAAOuB,KAAKoC,QAzCnB/D,eAAgBmC,EAA0C1C,EAAsC2C,GAC5F,IAAI/B,EACJ,OAEI,OACI,IACI,OAAa,CACT,MAAMX,QAAUD,EAAGT,KAAKqB,GACxB,GAAIX,EAAEC,KAAM,OAAOD,EAAEE,MACrB,MAAM6E,EAAS/E,EAAEE,MACbP,EAAiBoF,IACjB7B,EAAKiC,IAAIJ,GAEb,IACQrC,EAAQ,GAAKvD,EAAgB4F,SACtBtC,EAAKsC,EAAGrC,EAAQ,GAChBA,EAAQ,IAAMtD,EAAgB2F,IAAM9F,EAAW8F,UAC/CtC,EAAKjC,EAAgBuE,GAAIrC,EAAQ,GAExC/B,QAAWX,EAAEE,MAEnB,MAAOY,SACCf,EAAGP,QAAQsB,cAIzB,MAAMmE,QAAUlF,EAAGR,SAASmB,GAAMK,YAGlC,GAFIpB,EAAiBI,IAAKmD,EAAKkC,OAAOrF,GAElCkF,IAAMA,EAAEhF,KAER,MAEJ,IAAK,MAAMlB,KAAKmE,QACNnE,EAAEQ,OAAOmB,GAAMK,YAOd0B,CAAKjC,EAAgB8D,GAAM5B,KAE1D,GAAqB,iBAAVA,EAAoB,CAC3B,GAAI4B,EAAK,CACL,GAAIpF,EAAeoF,GACf,OAAO7B,EAAKC,EAAO4B,GAEnB,MAAM,IAAIe,UAAU,oBAAoBf,KAGhD,OAA2BA,GACvB7B,EAAKC,EAAO4B,GACb,GAAIpF,EAAewD,GACtB,OAAOD,EAAM6B,GAAO,EAAS5B,GAEjC,MAAM,IAAI2C,UAAU,+BA6DxB1C,QACI9D,EACAyG,EACAhB,GAYA,MAAM3B,EAAU,CAAoBD,EAAU4B,KAC1C,IAAI5D,EACAiE,EAAM,EAqDV,OAAOjE,EAAOuB,KAAKoC,QAnDnB/D,eAAgBqC,EACR5C,EAAsC2C,GAI1C,IAAI/B,EACJ,OAEI,OACI,IACI,OAAa,CACT,MAAMX,QAAUD,EAAGT,KAAKqB,GACxB,GAAIX,EAAEC,KAAM,OAAOD,EAAEE,MACrB,MAAM6E,QAAUlG,EAAEmB,EAAEE,MAAwByE,KAC5C,IACI,GAAIxF,EAAyC4F,GACzC,GAAIrC,EAAQ,QACDC,EAAQoC,EAAGrC,EAAQ,QACvB,GAAc,IAAVA,EAAa,CACpB,MAAM3C,EAAKS,EAAgBuE,SACpB1E,EAAiBN,cAElBgF,OAEH3F,EAAyC2F,IAAM9F,EAAoC8F,GACtFrC,EAAQ,QACDC,EAAQnC,EAAgBuE,GAAIrC,EAAQ,GAC1B,IAAVA,QACArC,EAAiB0E,SAElBA,EAGVpE,QAAWoE,EAEjB,MAAOjE,SACCf,EAAGP,QAAQsB,cAIzB,MAAMmE,QAAUlF,EAAGR,SAASmB,GAAMK,YAElC,GAAIkE,IAAMA,EAAEhF,KAER,OAOO0C,CAAQnC,EAAgB8D,GAAM5B,KAG7D,OAAIxD,EAAeoF,GACR3B,EAAQ2C,GAAmB,EAAQhB,GACnCpF,EAAgBoG,GAChB3C,EAAQ,EAAQ2C,GAEpB,CAAoBhB,EAAwC5B,IAC/DC,EAAQ2C,GAAc5C,GAAS,EAAQ4B,GAsB/C1B,MACIC,EACAC,EACAgC,GAQA,MAAMlC,EAA4BkC,IAG9B,MAAM/E,EAAKS,EAAgBsE,GAqC3B,OAAO7C,KAAKoC,QApCZ/D,gBAAsBuC,EAAeC,GACjC,IAAK,IAAIhD,EAAI,EAAGA,EAAI+C,EAAO/C,IAAK,CAC5B,MAAME,QAAUD,EAAGT,OACnB,GAAIU,EAAEC,KAAM,OAAOD,EAAEE,MAEzB,GAAI4C,IAAQC,OAAOC,wBACR/B,EAAgBlB,OACpB,CACH,IAAIwF,EACJ,OACI,IACI,IAAK,IAAIzF,EAAI+C,EAAO/C,EAAIgD,EAAKhD,IAAK,CAC9B,MAAME,QAAUD,EAAGT,KAAKiG,GACxB,GAAIvF,EAAEC,KAAM,OAAOD,EAAEE,MACrB,IACIqF,QAAWvF,EAAEE,MACf,MAAOY,GACL,MAAM0E,QAAWzF,EAAGP,QAAQsB,IAC5B,GAAI0E,EAAI,CACJ,GAAIA,EAAGvF,KAAM,OAAOuF,EAAGtF,MACvBqF,QAAWC,EAAGtF,iBAK1B,MAAM+E,QAAUlF,EAAGR,YAEnB,GAAI0F,IAAMA,EAAEhF,KAER,QAOA2C,CAAMC,EAAOC,KAErC,OAAKgC,EACElC,EAAMkC,GADKlC,EAUtBK,UAA6BC,GAGzB,IAAIxC,EAmBJ,OAAOA,EAAOuB,KAAKoC,QAlBnB/D,kBACI,IAAIR,EAAI,EACR,IACI,KAAOA,EAAIoD,EAAKuC,OAAQ3F,IAAK,CACzB,MAAMC,EAAKkB,EAAgBiC,EAAKpD,UACzBC,WAIX,KAAOD,EAAIoD,EAAKuC,OAAQ3F,IAAK,CACzB,MAAMf,EAAImE,EAAKpD,GACXH,EAAiBZ,UACXA,EAAEQ,OAAOmB,GAAMK,aAMVkC,IA2D/BE,OACItE,EACA6G,EACApB,GAiBA,MAAMnB,EAAS7C,MAAuB8C,EAAsCrD,KAGxE,IAAI4F,QAA+BvC,EACnC,QAAYyB,IAARc,EAAmB,CACnB,MAAM3F,QAAUD,EAAGT,OACnB,GAAIU,EAAEC,KAAM,MAAM,IAAIoF,UAAU,8BAChCM,EAAM3F,EAAEE,MAEZ,OAAa,CACT,MAAMF,QAAUD,EAAGT,OACnB,GAAIU,EAAEC,KAAM,OAAO0F,EACnBA,QAAY9G,EAAE8G,EAAK3F,EAAEE,SAG7B,OAAIhB,EAAeoF,GACRnB,EAAOuC,EAAgBlF,EAAgB8D,IACvCpF,EAAewG,GACfvC,OAAO0B,EAAWrE,EAAgBkF,IAEtC,CAACpB,EAAwClB,IAC5CD,EAAOC,GAAQsC,EAAWlF,EAAgB8D,IAiDlDjB,KACIuC,EACAC,EACAvB,GAQA,MAAMjB,EAAO/C,MAAuBgC,EAAcvC,KAC9C,IAAID,EAAI,EACR,OAAa,CACT,MAAME,QAAUD,EAAGT,OACnB,GAAIU,EAAEC,KAAM,OAAO,EACnB,GAAI2F,EAAKhB,KAAKtC,EAAStC,EAAEE,MAAOJ,KAAM,OAAO,IAGrD,GAAIZ,EAAeoF,GACf,OAAOjB,EAAKwC,EAAWrF,EAAgB8D,IACpC,GAAIpF,EAAeoF,GACtB,MAAO,CAACA,EAAwChC,IAC5Ce,EAAKf,GAAWuD,EAAWrF,EAAgB8D,IAEnD,MAAM,IAAIlE,MAAM,6BAA6BkE,GAAOuB,KAkDxDtC,MACIqC,EACAE,EACAxB,GAQA,MAAMf,EAAQjD,MAAuBgC,EAAcvC,KAG/C,IAAID,EAAI,EACR,OAAa,CACT,MAAME,QAAUD,EAAGT,OACnB,GAAIU,EAAEC,KAAM,OAAO,EACnB,IAAK2F,EAAKhB,KAAKtC,EAAStC,EAAEE,MAAOJ,KAAM,OAAO,IAGtD,GAAIZ,EAAeoF,GACf,OAAOf,EAAMuC,EAAWtF,EAAgB8D,IACrC,GAAIxF,EAAUwF,GACjB,MAAO,CAAiBA,EAAwChC,IAC5DiB,EAAMjB,GAAWwD,EAAWtF,EAAgB8D,IAEpD,MAAM,IAAIlE,MAAM,8BAA8BkE,GAAOwB,KAUzDtC,WACIc,EACAlC,EAAcW,OAAOC,mBAIrB,MAAMjD,EAAKS,EAAgB8D,GAC3B,IAAI3D,EACAD,EA4BJ,OAAOA,EAAOuB,KAAKoC,QA1BnB/D,kBACI,IACI,IAAIyF,EACJ,OAAa,CACT,MAAM/F,QAAUD,EAAGT,KAAKqB,GACxB,GAAIX,EAAEC,KAAM,MACZ,IACIU,QAAYoF,EAAO/F,EAAEE,MACvB,MAAOY,GACL,MAAM0E,QAAWzF,EAAGP,QAAQsB,IAC5B,GAAI0E,EAAI,CACJ,GAAIA,EAAGvF,KAAM,YACP8F,EAAOP,EAAGtF,QAI5B,IAAK,IAAIJ,EAAI,EAAGA,EAAIsC,EAAKtC,gBAETiG,gBAGVhG,EAAGR,SAASmB,GAAMK,aAKLyC,IAU/BC,OAAiBvD,EAAUwD,EAAsBX,OAAOC,mBAUpD,OAAOf,KAAKoC,QAPZ/D,kBACI,IAAK,IAAIR,EAAI,EAAGA,EAAI4D,EAAa5D,gBAEjBI,EAIAuD,IAUxBG,OAA0BV,GAGtB,GAAoB,IAAhBA,EAAKuC,OAAc,OAAOxD,KAAKoC,QAAQ,IAC3C,MAAM2B,EAAM9C,EAAKX,IAAI/B,GACrB,IACIE,EADAT,GAAO,EA2CX,OAAOS,EAAOuB,KAAKoC,QAxCnB/D,kBACI,IACI,OAAa,CACT,IAAI2F,EAAmB,GACvB,IAAK,MAAMlH,KAAKiH,EAAK,CACjB,MAAMhG,QAAUjB,EAAEO,OAClB,GAAIU,EAAEC,KAEF,OADAA,GAAO,EACAD,EAAEE,MAEZ+F,EAAiBC,KAAKlG,EAAEE,OAE7B,UACU+F,EACR,MAAOnF,GACL,IAAK,MAAM/B,KAAKmE,EACZ,UAEWnE,EAAUS,QAAQsB,IAC3B,OAIN,MAAMA,YAId,IAAKb,EACD,IAAK,MAAMlB,KAAKmE,EACZ,UAEWnE,EAAUQ,SAASmB,GAAMK,YAClC,SAQSoF,IAoB/BtC,KACIuC,EACAtC,GAQA,MAA8B,iBAAnBsC,GACPtC,EAAMsC,EACqB9B,GACvBrC,KAAK4B,KAAKS,EAAKR,IAEhBlD,QAAQC,QAAQoB,KAAKoC,QAAQ+B,GAAgBpE,WAC/CkG,MAAKC,GAAKA,EAAEtE,KAAKC,KAa1BuC,SAA4BC,GAGxB,IAAI5F,EACAT,EACJ,MAAMmI,EAAc,IAAIxH,SAAuCZ,GAAMC,EAAOD,IAC5E,IACIqI,EADAC,EAAchC,EAAQb,OAE1B,MAAM8C,EAAO,IAAI3H,SAAmD,IAAM,OAC1E,IAAIsC,EAAgD,GAiDpD,OA5BAmF,EAAS,IAAI/B,EAAQ/D,KApBRjC,MAAOvB,EAAsCqI,KACtD,MAAMoB,EAAKhI,EAAgBzB,GAC3BmE,EAAKkE,GAAKoB,EACV,MAAMC,EAASnI,MAAOiB,GAClB,KACI,GAAIA,EAAItB,KAIJ,OAHAoI,EAAOjB,GAAKmB,IAGHD,EAAc,EACjB,MACCrI,EAAKsB,GAAMA,GACf,CACH,MAAMwD,EAAIyD,EAAGlJ,OAAO4I,KAAKO,GAEzB,OADAJ,EAAOjB,GAAKrC,EACLxD,IAGnB,aAAciH,EAAGlJ,OAAO4I,KAAKO,MAEDL,GA4BzB1H,EAAOuH,EAAM5D,QA3BpB/D,kBACI,IACI,IAAIiF,EACJ,KAAO+C,GAAa,CAChB,MAAMI,EAA2G,GACjHL,EAAOhG,SAAQ8F,GAAKO,EAAKxC,KAAKiC,KAC9B,MAAMlC,cAAsBrF,QAAQ8H,KAAKA,GACzC,GAAsB,mBAAXzC,EAAuB,CAC9B,IAAIjG,EAAIiG,IACR,GAAIjG,EAAG,CACH,GAAIA,EAAEC,KACF,OAAOD,EAAEE,MAEbqF,QAAYvF,EAAEE,YAEf,GAAI+F,GAAUA,EAAOhG,KACxB,OAAOgG,EAAO/F,eAItB,GAAIoI,EACA,IAAK,IAAIxI,EAAI,EAAGA,EAAIwG,EAAQb,OAAQ3F,KACjB,OAAduI,EAAOvI,GAAc,KAAOoD,EAAKpD,KAAKP,SAASmB,GAAMK,YAK1CsF,IAOhCtC,KAAQC,GACJ,OAAO1D,SAA0BgG,WACJrE,KAAKoE,SAASC,GAAStE,WACnC+B,KAAKC,GAQ1BK,QAA2BC,GAGvB,MAAMkC,EAAOnG,EAAiBiE,GAExBmC,EAAMC,OAAOC,eAAeH,GAC5BI,EAAQF,OAAOiC,OAAOjC,OAAOG,OAAO+B,EAAuB9B,WAAYL,GAI7E,OAHAG,EAAMrH,OAAUwF,IAAayB,EAAazF,UAAYgE,EAAG0B,EAAIlH,OAAOqF,KAAK4B,EAAMzB,IAC/E6B,EAAMnH,OAAOG,eAAiB,IAAM4G,EACpCE,OAAOK,eAAeP,EAAMI,GACrBJ,UAUOoC,UACV9G,GA8BL,MAAM+G,EAAgBnC,OAAOC,eANpCrG,mBAMmDwI,IAInDpC,OAAOK,eAAe6B,EAAuB9B,UA3B3B,CAACI,IACf,MAAMC,EAAWT,OAAOG,OAAOK,GAS/B,MARgB,CAACN,IACb,IAAK,MAAMQ,KAAKC,QAAQC,QAAQV,GAClB,gBAANQ,IACAD,EAASC,GAAKR,EAAMQ,KAIhCG,CAAQzF,EAAagF,WACdK,GAiB6CK,CAAUqB,IAClEnC,OAAOe,eAAemB,EAAuB9B,UAAW,QAAS,CAC7D5G,MAAO+H,EACPP,UAAU,EACVC,YAAY,EACZC,cAAc,UC5sCZ1D,EAAO6E,EASPd,EAAQa,ECxBd,SAASE,EAAOC,EAAOC,GACjBA,EAAUA,GAAW,GAEzBjH,KAAKkH,MAAQ,EACblH,KAAKmH,MAAQ,EACbnH,KAAKoH,UAAYH,EAAQI,SACzBrH,KAAKsH,cAAgB,EACrBtH,KAAKuH,MAAQ,IAAIC,MAAM,GACnBA,MAAMC,QAAQT,IAChBhH,KAAK0H,WAAWV,GAkBpBD,EAAOlC,UAAU8C,OAAS,SAAgBC,GACxC,IAAI/J,EAAI+J,EAER,GAAK/J,KAAW,EAAJA,GAAZ,CAGA,IAAIgK,EAAM7H,KAAK8H,OACf,KAAIjK,GAAKgK,GAAOhK,GAAKgK,GAGrB,OAFIhK,EAAI,IAAGA,GAAKgK,GAChBhK,EAAKmC,KAAKkH,MAAQrJ,EAAKmC,KAAKsH,cACrBtH,KAAKuH,MAAM1J,KAQpBkJ,EAAOlC,UAAUkD,IAAM,SAAalK,GAClC,OAAOmC,KAAK2H,OAAO9J,IAOrBkJ,EAAOlC,UAAUmD,KAAO,WACtB,GAAIhI,KAAKkH,QAAUlH,KAAKmH,MACxB,OAAOnH,KAAKuH,MAAMvH,KAAKkH,QAOzBH,EAAOlC,UAAUoD,UAAY,WAC3B,OAAOjI,KAAKgI,QAOdjB,EAAOlC,UAAUqD,SAAW,WAC1B,OAAOlI,KAAK2H,QAAQ,IAOtBlD,OAAOe,eAAeuB,EAAOlC,UAAW,SAAU,CAChDkD,IAAK,WACH,OAAO/H,KAAK8H,UAQhBf,EAAOlC,UAAUiD,KAAO,WACtB,OAAI9H,KAAKkH,QAAUlH,KAAKmH,MAAc,EAClCnH,KAAKkH,MAAQlH,KAAKmH,MAAcnH,KAAKmH,MAAQnH,KAAKkH,MAC1ClH,KAAKsH,cAAgB,GAAKtH,KAAKkH,MAAQlH,KAAKmH,QAO1DJ,EAAOlC,UAAUsD,QAAU,SAAiBC,GAC1C,QAAaxF,IAATwF,EAAoB,OAAOpI,KAAK8H,OACpC,IAAID,EAAM7H,KAAKuH,MAAM/D,OAKrB,OAJAxD,KAAKkH,MAASlH,KAAKkH,MAAQ,EAAIW,EAAO7H,KAAKsH,cAC3CtH,KAAKuH,MAAMvH,KAAKkH,OAASkB,EACrBpI,KAAKmH,QAAUnH,KAAKkH,OAAOlH,KAAKqI,aAChCrI,KAAKoH,WAAapH,KAAK8H,OAAS9H,KAAKoH,WAAWpH,KAAKsI,MACrDtI,KAAKkH,MAAQlH,KAAKmH,MAAcnH,KAAKmH,MAAQnH,KAAKkH,MAC1ClH,KAAKsH,cAAgB,GAAKtH,KAAKkH,MAAQlH,KAAKmH,QAQ1DJ,EAAOlC,UAAU0D,MAAQ,WACvB,IAAIC,EAAOxI,KAAKkH,MAChB,GAAIsB,IAASxI,KAAKmH,MAAlB,CACA,IAAIiB,EAAOpI,KAAKuH,MAAMiB,GAItB,OAHAxI,KAAKuH,MAAMiB,QAAQ5F,EACnB5C,KAAKkH,MAASsB,EAAO,EAAKxI,KAAKsH,cAC3BkB,EAAO,GAAKxI,KAAKmH,MAAQ,KAASnH,KAAKmH,OAASnH,KAAKuH,MAAM/D,SAAW,GAAGxD,KAAKyI,eAC3EL,IAOTrB,EAAOlC,UAAUZ,KAAO,SAAcmE,GACpC,QAAaxF,IAATwF,EAAoB,OAAOpI,KAAK8H,OACpC,IAAIpG,EAAO1B,KAAKmH,MAShB,OARAnH,KAAKuH,MAAM7F,GAAQ0G,EACnBpI,KAAKmH,MAASzF,EAAO,EAAK1B,KAAKsH,cAC3BtH,KAAKmH,QAAUnH,KAAKkH,OACtBlH,KAAKqI,aAEHrI,KAAKoH,WAAapH,KAAK8H,OAAS9H,KAAKoH,WACvCpH,KAAKuI,QAEHvI,KAAKkH,MAAQlH,KAAKmH,MAAcnH,KAAKmH,MAAQnH,KAAKkH,MAC1ClH,KAAKsH,cAAgB,GAAKtH,KAAKkH,MAAQlH,KAAKmH,QAQ1DJ,EAAOlC,UAAUyD,IAAM,WACrB,IAAI5G,EAAO1B,KAAKmH,MAChB,GAAIzF,IAAS1B,KAAKkH,MAAlB,CACA,IAAIW,EAAM7H,KAAKuH,MAAM/D,OACrBxD,KAAKmH,MAASzF,EAAO,EAAImG,EAAO7H,KAAKsH,cACrC,IAAIc,EAAOpI,KAAKuH,MAAMvH,KAAKmH,OAG3B,OAFAnH,KAAKuH,MAAMvH,KAAKmH,YAASvE,EACrB5C,KAAKkH,MAAQ,GAAKxF,EAAO,KAASA,GAAQmG,IAAQ,GAAG7H,KAAKyI,eACvDL,IASTrB,EAAOlC,UAAU6D,UAAY,SAAmBd,GAC9C,IAAI/J,EAAI+J,EAER,GAAK/J,KAAW,EAAJA,IAGRmC,KAAKkH,QAAUlH,KAAKmH,MAAxB,CACA,IAAIW,EAAO9H,KAAK8H,OACZD,EAAM7H,KAAKuH,MAAM/D,OACrB,KAAI3F,GAAKiK,GAAQjK,GAAKiK,GAAtB,CACIjK,EAAI,IAAGA,GAAKiK,GAChBjK,EAAKmC,KAAKkH,MAAQrJ,EAAKmC,KAAKsH,cAC5B,IACInC,EADAiD,EAAOpI,KAAKuH,MAAM1J,GAEtB,GAAI+J,EAAQE,EAAO,EAAG,CACpB,IAAK3C,EAAIyC,EAAOzC,EAAI,EAAGA,IACrBnF,KAAKuH,MAAM1J,GAAKmC,KAAKuH,MAAM1J,EAAKA,EAAI,EAAIgK,EAAO7H,KAAKsH,eAEtDtH,KAAKuH,MAAM1J,QAAK,EAChBmC,KAAKkH,MAASlH,KAAKkH,MAAQ,EAAIW,EAAO7H,KAAKsH,kBACtC,CACL,IAAKnC,EAAI2C,EAAO,EAAIF,EAAOzC,EAAI,EAAGA,IAChCnF,KAAKuH,MAAM1J,GAAKmC,KAAKuH,MAAM1J,EAAMA,EAAI,EAAIgK,EAAO7H,KAAKsH,eAEvDtH,KAAKuH,MAAM1J,QAAK,EAChBmC,KAAKmH,MAASnH,KAAKmH,MAAQ,EAAIU,EAAO7H,KAAKsH,cAE7C,OAAOc,KAWTrB,EAAOlC,UAAU8D,OAAS,SAAgBf,EAAOgB,GAC/C,IACIC,EADAhL,EAAI+J,EAEJkB,EAAYF,EAEhB,GAAK/K,KAAW,EAAJA,IAGRmC,KAAKkH,QAAUlH,KAAKmH,MAAxB,CACA,IAAIW,EAAO9H,KAAK8H,OACZD,EAAM7H,KAAKuH,MAAM/D,OACrB,KAAI3F,GAAKiK,GAAQjK,GAAKiK,GAAQc,EAAQ,GAAtC,CAEA,GADI/K,EAAI,IAAGA,GAAKiK,GACF,IAAVc,IAAgBA,EAGlB,OAFAC,EAAU,IAAIrB,MAAM,IACZ,GAAKxH,KAAK0I,UAAU7K,GACrBgL,EAET,GAAU,IAANhL,GAAWA,EAAI+K,GAASd,EAG1B,OAFAe,EAAU7I,KAAK+I,UACf/I,KAAKgJ,QACEH,EAGT,IAAI1D,EAEJ,IAHItH,EAAI+K,EAAQd,IAAMc,EAAQd,EAAOjK,GAErCgL,EAAU,IAAIrB,MAAMoB,GACfzD,EAAI,EAAGA,EAAIyD,EAAOzD,IACrB0D,EAAQ1D,GAAKnF,KAAKuH,MAAOvH,KAAKkH,MAAQrJ,EAAIsH,EAAKnF,KAAKsH,eAGtD,GADAzJ,EAAKmC,KAAKkH,MAAQrJ,EAAKmC,KAAKsH,cACxBM,EAAQgB,IAAUd,EAAM,CAE1B,IADA9H,KAAKmH,MAASnH,KAAKmH,MAAQyB,EAAQf,EAAO7H,KAAKsH,cAC1CnC,EAAIyD,EAAOzD,EAAI,EAAGA,IACrBnF,KAAKuH,MAAM1J,EAAKA,EAAI,EAAIgK,EAAO7H,KAAKsH,oBAAiB,EAEvD,OAAOuB,EAET,GAAc,IAAVjB,EAAa,CAEf,IADA5H,KAAKkH,MAASlH,KAAKkH,MAAQ0B,EAAQf,EAAO7H,KAAKsH,cAC1CnC,EAAIyD,EAAQ,EAAGzD,EAAI,EAAGA,IACzBnF,KAAKuH,MAAM1J,EAAKA,EAAI,EAAIgK,EAAO7H,KAAKsH,oBAAiB,EAEvD,OAAOuB,EAET,GAAIhL,EAAIiK,EAAO,EAAG,CAEhB,IADA9H,KAAKkH,MAASlH,KAAKkH,MAAQU,EAAQgB,EAAQf,EAAO7H,KAAKsH,cAClDnC,EAAIyC,EAAOzC,EAAI,EAAGA,IACrBnF,KAAKmI,QAAQnI,KAAKuH,MAAM1J,EAAKA,EAAI,EAAIgK,EAAO7H,KAAKsH,gBAGnD,IADAzJ,EAAKmC,KAAKkH,MAAQ,EAAIW,EAAO7H,KAAKsH,cAC3BwB,EAAY,GACjB9I,KAAKuH,MAAM1J,EAAKA,EAAI,EAAIgK,EAAO7H,KAAKsH,oBAAiB,EACrDwB,IAEElB,EAAQ,IAAG5H,KAAKmH,MAAQtJ,OACvB,CAGL,IAFAmC,KAAKmH,MAAQtJ,EACbA,EAAKA,EAAI+K,EAAQf,EAAO7H,KAAKsH,cACxBnC,EAAI2C,GAAQc,EAAQhB,GAAQzC,EAAI,EAAGA,IACtCnF,KAAKiE,KAAKjE,KAAKuH,MAAM1J,MAGvB,IADAA,EAAImC,KAAKmH,MACF2B,EAAY,GACjB9I,KAAKuH,MAAM1J,EAAKA,EAAI,EAAIgK,EAAO7H,KAAKsH,oBAAiB,EACrDwB,IAIJ,OADI9I,KAAKkH,MAAQ,GAAKlH,KAAKmH,MAAQ,KAASnH,KAAKmH,OAASU,IAAQ,GAAG7H,KAAKyI,eACnEI,KAcT9B,EAAOlC,UAAUoE,OAAS,SAAgBrB,EAAOgB,GAC/C,IAAI/K,EAAI+J,EAER,GAAK/J,KAAW,EAAJA,GAAZ,CAGA,IAAIiK,EAAO9H,KAAK8H,OAEhB,GADIjK,EAAI,IAAGA,GAAKiK,KACZjK,EAAIiK,GAAR,CACA,GAAIoB,UAAU1F,OAAS,EAAG,CACxB,IAAI2B,EACAgE,EACAN,EACAO,EAAUF,UAAU1F,OACpBqE,EAAM7H,KAAKuH,MAAM/D,OACjB6F,EAAkB,EACtB,IAAKvB,GAAQjK,EAAIiK,EAAO,EAAG,CAEzB,IADAqB,EAAO,IAAI3B,MAAM3J,GACZsH,EAAI,EAAGA,EAAItH,EAAGsH,IACjBgE,EAAKhE,GAAKnF,KAAKuH,MAAOvH,KAAKkH,MAAQ/B,EAAKnF,KAAKsH,eAW/C,IATc,IAAVsB,GACFC,EAAU,GACNhL,EAAI,IACNmC,KAAKkH,MAASlH,KAAKkH,MAAQrJ,EAAIgK,EAAO7H,KAAKsH,iBAG7CuB,EAAU7I,KAAK2I,OAAO9K,EAAG+K,GACzB5I,KAAKkH,MAASlH,KAAKkH,MAAQrJ,EAAIgK,EAAO7H,KAAKsH,eAEtC8B,EAAUC,GACfrJ,KAAKmI,QAAQe,YAAYE,IAE3B,IAAKjE,EAAItH,EAAGsH,EAAI,EAAGA,IACjBnF,KAAKmI,QAAQgB,EAAKhE,EAAI,QAEnB,CAEL,IAAImE,GADJH,EAAO,IAAI3B,MAAMM,GAAQjK,EAAI+K,KACbpF,OAChB,IAAK2B,EAAI,EAAGA,EAAImE,EAAMnE,IACpBgE,EAAKhE,GAAKnF,KAAKuH,MAAOvH,KAAKkH,MAAQrJ,EAAI+K,EAAQzD,EAAKnF,KAAKsH,eAW3D,IATc,IAAVsB,GACFC,EAAU,GACNhL,GAAKiK,IACP9H,KAAKmH,MAASnH,KAAKkH,MAAQrJ,EAAIgK,EAAO7H,KAAKsH,iBAG7CuB,EAAU7I,KAAK2I,OAAO9K,EAAG+K,GACzB5I,KAAKmH,MAASnH,KAAKmH,MAAQmC,EAAOzB,EAAO7H,KAAKsH,eAEzC+B,EAAkBD,GACvBpJ,KAAKiE,KAAKiF,UAAUG,MAEtB,IAAKlE,EAAI,EAAGA,EAAImE,EAAMnE,IACpBnF,KAAKiE,KAAKkF,EAAKhE,IAGnB,OAAO0D,EAEP,OAAO7I,KAAK2I,OAAO9K,EAAG+K,MAO1B7B,EAAOlC,UAAUmE,MAAQ,WACvBhJ,KAAKkH,MAAQ,EACblH,KAAKmH,MAAQ,GAOfJ,EAAOlC,UAAU0E,QAAU,WACzB,OAAOvJ,KAAKkH,QAAUlH,KAAKmH,OAO7BJ,EAAOlC,UAAUkE,QAAU,WACzB,OAAO/I,KAAKwJ,YAAW,IAezBzC,EAAOlC,UAAU6C,WAAa,SAAoBV,GAChD,IAAK,IAAInJ,EAAI,EAAGA,EAAImJ,EAAMxD,OAAQ3F,IAAKmC,KAAKiE,KAAK+C,EAAMnJ,KASzDkJ,EAAOlC,UAAU2E,WAAa,SAAoBC,GAChD,IAGI5L,EAHA6L,EAAW,GACXC,EAAO3J,KAAKuH,MACZM,EAAM8B,EAAKnG,OAEf,GAAIiG,GAAYzJ,KAAKkH,MAAQlH,KAAKmH,MAAO,CACvC,IAAKtJ,EAAImC,KAAKkH,MAAOrJ,EAAIgK,EAAKhK,IAAK6L,EAASzF,KAAK0F,EAAK9L,IACtD,IAAKA,EAAI,EAAGA,EAAImC,KAAKmH,MAAOtJ,IAAK6L,EAASzF,KAAK0F,EAAK9L,SAEpD,IAAKA,EAAImC,KAAKkH,MAAOrJ,EAAImC,KAAKmH,MAAOtJ,IAAK6L,EAASzF,KAAK0F,EAAK9L,IAE/D,OAAO6L,GAOT3C,EAAOlC,UAAUwD,WAAa,WACxBrI,KAAKkH,QAEPlH,KAAKuH,MAAQvH,KAAKwJ,YAAW,GAC7BxJ,KAAKkH,MAAQ,GAIflH,KAAKmH,MAAQnH,KAAKuH,MAAM/D,OAExBxD,KAAKuH,MAAM/D,QAAU,EACrBxD,KAAKsH,cAAiBtH,KAAKsH,eAAiB,EAAK,GAOnDP,EAAOlC,UAAU4D,aAAe,WAC9BzI,KAAKuH,MAAM/D,UAAY,EACvBxD,KAAKsH,iBAAmB,OAI1BsC,EAAiB7C,EChZjB,MAAM8C,EAASrM,OAAOsM,IAAI,UAOpBC,EAAcC,GAA0BA,aAAavF,QAAyB,UAAduF,EAAEH,GA6C3DI,EAAmB,CAAcC,EAAqC,KAAM,IAAInD,MACzF,IAAIoD,EAA6B,OAC7BC,EAAS,KACb,MAAMC,EAAIH,IACJI,EAAQxH,IAAauH,EAAEpG,KAAKnB,GAAIqH,KA6BtC,MAAO,CAhBP9L,kBACI,OAAa,CACT,MAAQgM,EAAE7G,QACN4G,EAAS,IAAIzL,SAAQuH,GAAMiE,EAAUjE,UAC/BkE,EACNA,EAAS,KACTD,EAAU,OAEd,MAAMrH,EAAIuH,EAAE9B,QACZ,IAxEYyB,EAwEOlH,aAxEoC2B,QAAyB,WAAduF,EAAEH,GAwE7C,OAAO/G,EAAE7E,MAChC,GAAI8L,EAAWjH,GACX,MAAMA,EAAE7E,YAEN6E,EA5EE,IAAIkH,EAgFhBC,GACA,IA9BJ,MACIK,KAAKxH,GACD,OAAOwH,EAAKxH,GAEhBjC,IAAI5C,GACD,OAAOqM,EAAK,CAACT,CAACA,GAAS,SAAU5L,MAAAA,IAEpCV,MAAMU,GACF,OAAOqM,EAAK,CAAET,CAACA,GAAS,QAAS5L,MAAAA,IAErC+K,QAAU,OAAOqB,EAAErB,YA2BduB,EAAS,KAClB,IAAItM,EACAuM,GAAQ,EAmBZ,OAAO,IAlBP,MACIhH,aAAe,OAAOgH,EAAQ,EAAI,EAClCvG,KAAKnB,GAGD,OAFA0H,GAAQ,EACRvM,EAAQ6E,EACD,EAEXyF,QACIiC,GAAQ,EACR,MAAMC,EAAMxM,EAEZ,OADAA,OAAQ2E,EACD6H,EAEXzB,QACIwB,GAAQ,EACRvM,OAAQ2E,KAUP8H,EAAc,KACvB,IAAIzM,EACAuM,GAAQ,EAgBZ,OAAO,IAfP,MACIhH,aAAe,OAAOgH,EAAQ,EAAI,EAClCvG,KAAKnB,GAGD,OAFA0H,GAAQ,EACRvM,EAAQ6E,EACD,EAEXyF,QACI,OAAOtK,EAEX+K,QACIwB,GAAQ,EACRvM,OAAQ2E,KAWP+H,EAAc,CAAIC,EAAY,IAChC,KACH,MAAMV,EAAQ,IAAInD,EAalB,OAAO,IAZP,MACIvD,aAAe,OAAO0G,EAAM1G,OAC5BS,KAAKnB,GACD,OAAIoH,EAAM1G,OAASoH,EACRV,EAAMjG,KAAKnB,GAGfoH,EAAM1G,OAEjB+E,QAAU,OAAO2B,EAAM3B,QACvBS,QAAU,OAAOkB,EAAMlB,WAUtB6B,EAAc,CAAID,EAAY,IAChC,KACH,MAAMV,EAAQ,IAAInD,EAgBlB,OAAO,IAfP,MACIvD,aAAe,OAAO0G,EAAM1G,OAC5BS,KAAKnB,GACD,KAAOoH,EAAM1G,QAAUoH,GACnBV,EAAM3B,QAEV,OAAO2B,EAAMjG,KAAKnB,GAEtByF,QACI,OAAO2B,EAAM3B,QAEjBS,QACI,OAAOkB,EAAMlB,WAqBhB8B,EAAkBC,IAC3B,MAAMC,EAAK,CAACC,EAAiBC,IAAiB,KAC1C,MAAMhB,EAAQ,IAAIiB,IAClB,IAAItI,EAA2B,KAgC/B,OAAO,IA/BP,MACIW,aAAe,OAAO0G,EAAMpC,KAC5B7D,KAAKnB,GACD,MAAMqC,EAAI+F,EAAMpI,GAShB,OARImI,GAGAf,EAAM/G,OAAOgC,GACb+E,EAAMkB,IAAIjG,EAAGrC,IACLoH,EAAMmB,IAAIlG,IAClB+E,EAAMkB,IAAIjG,EAAGrC,GAEVoH,EAAMpC,KAEjBS,QACS1F,IACDA,EAAOqH,EAAM/H,UAEjB,MAAMpE,EAAI8E,EAAKxF,OACf,IAAIU,EAAEC,KAMN,OAAOD,EAAEE,MAHL4E,EAAO,KAKfmG,QACI,OAAOkB,EAAMlB,WAKzB,YAAapG,IAATmI,EAEOC,GAAG,GAAOnN,GAAKA,IAGnBmN,IAAKD,EAAKE,OAAQF,EAAKG,QAAUrN,GAAKA,KAWpCyN,EAAqB,CAAmBnK,EAAmB,KAAO,KAC3E,MAAMoK,EAAoB,IAAKpK,GAC/B,IAAIqK,EAAsB,GACtBC,GAAa,EA2BjB,OAAO,IA1BP,MACIjI,aAAe,OAAQiI,EAAa,EAAI,EACxCxH,KAAKnB,GACD,MAAM4I,EAASvG,GAAmBV,OAAOkH,KAAKxG,GAAmB/E,SAAQ+E,IACjEoG,EAAMpG,KAAOrC,EAAEqC,KACfqG,EAAQrG,GAAKrC,EAAEqC,GACfsG,GAAa,MAKrB,OAFAC,EAAMH,GACNG,EAAM5I,GACC,EAEXyF,QACI,IACI,OAAOiD,UAEP/G,OAAOiC,OAAO6E,EAAOC,GACrBxL,KAAKgJ,SAGbA,QACIwC,EAAU,GACVC,GAAa,WCtTZG,UAAkBjN,QAC3BqM,IACAa,OAEAC,QACAC,QACA/H,QACAgI,OACA,OAAQxO,OAAOsC,aAAe,SAC9B,OAAQtC,OAAOyO,SAAWtN,QAU1BuN,YAAYlB,EAAaa,GACrB,IAAIC,EACAC,EACJI,OAAM,CAACzI,EAAuB0I,KAC1BN,EAASpI,EACTqI,EAASK,KAEbpM,aAAe8L,EACf9L,aAAe+L,EACf/L,SAAWgL,EACXhL,cAAgB6L,EAcpBQ,KACIC,EACAC,GAIA,IAAIvM,SAiBG,CAAA,GAAIA,YACP,MAAMA,YAEN,OAAOA,aAnBP,IAGI,OAFAA,aAAeA,WACfA,eAAeA,cACRA,aACT,MAAOnB,GAGL,MAFAmB,YAAcnB,EACdmB,eAAenB,GACTA,UAENmB,cAAW4C,EACX5C,kBAAe4C,EACf5C,kBAAe4C,GACX0J,GAAeC,IACfJ,MAAMlG,KAAKqG,EAAaC,IAkBxCtG,KACIqG,EACAC,GAIA,GAAIvM,WAAaA,cAAgBsM,GAAeC,GAC5C,IACIvM,KAAKqM,OACP,MAAOxN,IAIb,OAAIyN,GAAeC,EACRJ,MAAMlG,KAAKqG,EAAaC,GAExBvM,YCnGN6L,EAAQ,CAACW,EAAYvO,IAC9B,IAAIU,SAAQ+E,GAAO+I,YAAW,IAAM/I,EAAIzF,IAAQuO,cCsBpCE,EAA6BC,GACzC,MAAMD,UAAkBC,EACpBC,UAAgBhK,EAChBsJ,eAAetM,GACXuM,SAASvM,GAEbiD,QACI,OAAOZ,EAAKG,QAAQpC,KAAKxC,OAAOC,aAEpCsC,UACI,OAAOC,aAAaD,UAExBG,MAAMC,GACF,OAAOH,aAAaE,MAAMC,GAE9BC,QAAQxD,EAA+ByD,GACnC,OAAOL,aAAaI,QAAQxD,EAAGyD,GAEnCC,IAAO1D,EAA4ByD,GAC/B,OAAOL,aAAaM,IAAI1D,EAAGyD,GAE/BE,OAAO3D,EAAgCyD,GACnC,OAAOL,aAAaO,OAAO3D,EAAGyD,GAElCG,KAA2BC,EAAW,GAClC,OAAOT,aAAaQ,KAAKC,GAE7BC,QAA8B9D,EAA8B6D,EAAW,GACnE,OAAOT,aAAaU,QAAQ9D,EAAG6D,GAEnCE,MAAMC,EAAgB,EAAGC,EAAcC,OAAO+E,kBAC1C,OAAO7F,aAAaW,MAAMC,EAAOC,GAErCG,UAA6BC,GACzB,OAAOjB,aAAagB,UAAUC,GAKlCC,OAAUtE,EAAQuE,GACd,OAAOnB,aAAakB,OAAOtE,EAAGuE,GAElCC,KAAQC,EAAgChB,GACpC,OAAOL,aAAaoB,KAAKC,EAAGhB,GAEhCiB,MAAMD,EAAgChB,GAClC,OAAOL,aAAasB,MAAMD,EAAGhB,GAEjCkB,WAAWpB,EAAcW,OAAO+E,kBAC5B,OAAO7F,aAAauB,WAAWpB,GAEnCqB,OAAUvD,EAAUwD,EAAsBX,OAAO+E,kBAC7C,OAAO7F,aAAawB,OAAOvD,EAAOwD,GAEtCG,KAAKC,EAAc,IACf,OAAO7B,aAAa4B,KAAKC,GAE7BC,KAAKC,GACD,OAAO/B,aAAa8B,KAAKC,GAM7BgG,IAAKvK,OAAOsC,eACR,IACI,OAAOE,YACCA,UAAY,aAAa2M,EAAKE,SACxC,MAKE,MAAO,aAAaF,EAAKE,oBAKrC,OAAOH,WC9EKI,EAA8BH,GAC1C,MAAMG,UAAmBH,EACrBC,UAAgBhK,EAChBsJ,eAAetM,GACXuM,SAASvM,GAEbiD,QACI,OAAOmD,EAAM5D,QAAQpC,KAAKxC,OAAOG,kBAErCoC,UACI,OAAOC,aAAaD,UAExBG,MAAMC,GACF,OAAOH,aAAaE,MAAMC,GAE9BC,QAAQxD,EAAgCyD,GACpC,OAAOL,aAAaI,QAAQxD,EAAGyD,GAEnCC,IAAO1D,EAA6ByD,GAChC,OAAOL,aAAaM,IAAI1D,EAAGyD,GAE/BE,OAAO3D,EAAiCyD,GACpC,OAAOL,aAAaO,OAAO3D,EAAGyD,GAElCG,KAA2BC,EAAW,GAClC,OAAOT,aAAaQ,KAAKC,GAE7BC,QAA8B9D,EAA+B6D,EAAW,GACpE,OAAOT,aAAaU,QAAQ9D,EAAG6D,GAEnCE,MAAMC,EAAgB,EAAGC,EAAcC,OAAO+E,kBAC1C,OAAO7F,aAAaW,MAAMC,EAAOC,GAErCG,UAA6BC,GACzB,OAAOjB,aAAagB,UAAUC,GAKlCC,OAAUtE,EAAQuE,GACd,OAAOnB,aAAakB,OAAOtE,EAAGuE,GAElCC,KAAQC,EAAiChB,GACrC,OAAOL,aAAaoB,KAAKC,EAAGhB,GAEhCiB,MAAMD,EAAiChB,GACnC,OAAOL,aAAasB,MAAMD,EAAGhB,GAEjCkB,WAAWpB,EAAcW,OAAO+E,kBAC5B,OAAO7F,aAAauB,WAAWpB,GAEnCqB,OAAUvD,EAAUwD,EAAsBX,OAAO+E,kBAC7C,OAAO7F,aAAawB,OAAOvD,EAAOwD,GAEtCG,KAAKC,EAAc,IACf,OAAO7B,aAAa4B,KAAKC,GAE7BC,KAAKC,GACD,OAAO/B,aAAa8B,KAAKC,GAM7BgG,IAAKvK,OAAOsC,eACR,IACI,OAAOE,YACCA,UAAY,aAAa2M,EAAKE,SACxC,MAKE,MAAO,aAAaF,EAAKE,oBAKrC,OAAOC"}