{"version":3,"file":"enhancements.js","sources":["../../src/enhancements.ts"],"sourcesContent":["/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * This provides the trampoline methods that are shared between synchronous and\n * asynchronous enhanced generators. Methods dispatch to {@link Sync} or {@link Async}\n * as appropriate.\n *\n * This becomes part of the prototype chain of enhanced generator instances. It does\n * __not__ modify any global prototypes.\n *\n * You should not need to reference this directly. In Typescript, if you need a\n * type that covers both sync and async enhanced generators, use {@link Enhanced} (for,\n * generators) or the {@link GeneratorOps} interface (for the functional interface).\n *\n * @packageDocumentation\n * @module enhancements\n * @preferred\n */\n\nimport {Async, Enhanced, FlatGen, Genable, GeneratorOps, IndexedFn, IndexedPredicate, Reducer, ReturnValue, SyncType, UnwrapArray} from \"./types\";\n\n/**\n * Enhancements for generators\n */\n\nexport type {Enhanced} from './types';\n\n/**\n * The trampoline methods that link enhanced generators to [[Sync]] or [[Async]]\n * methods.\n */\nexport abstract class Enhancements<\n        T, TReturn, TNext, S extends SyncType\n        >\n{\n    abstract _impl: GeneratorOps<S>;\n\n    // Set on a call to return().\n    returning?: any;\n\n    abstract next(...arg: [] | [arg: TNext]):\n        S extends Async\n            ? Promise<IteratorResult<T, TReturn>>\n            : IteratorResult<T, TReturn>;\n\n    abstract return(value: TReturn):\n        S extends Async\n            ? Promise<IteratorReturnResult<TReturn>>\n            : IteratorReturnResult<TReturn>;\n\n    abstract throw(e: any):\n        S extends Async\n            ? Promise<IteratorReturnResult<TReturn>>\n            : IteratorReturnResult<TReturn>;;\n\n    abstract [Symbol.iterator]:\n        S extends Async\n            ? undefined\n            : () => this & IterableIterator<T>;\n\n    abstract [Symbol.asyncIterator]:\n        S extends Async\n            ? () => this & AsyncIterableIterator<T>\n            : undefined;\n\n    [Symbol.toStringTag]:\n        S extends Async\n            ? 'EnhancedAsyncGenerator'\n            : 'EnhancedGenerator';\n\n    /**\n     * Return all of the values from this generator as an array. You do not want to call this on an\n     * infinite generator (for obvious reasons); consider using [[EnhancedGenerator.slice]] or\n     * [[EnhancedGenerator.limit]] to limit the size before calling this.\n     */\n    asArray(): ReturnValue<T[], S> {\n        return this._impl.asArray<T, TReturn, TNext>(this);\n    }\n\n    /**\n     * Limit the number of values that can be generated. A `RangeError` is thrown if this limit is\n     * exceeded. See [[EnhancedGenerator.slice]] if you want to truncate.\n     * @param max\n     */\n    limit(max: number): Enhanced<T, S, TReturn, TNext> {\n        return this._impl.limit(max, this);\n    }\n\n    /**\n     * Operate on each value produced by this generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @param thisArg Value to be supplied as context `this` for function _f_.\n     */\n    forEach(f: IndexedFn<T, void, S>, thisArg?: any): void {\n        this._impl.forEach<T, TReturn, TNext>(f, thisArg, this);\n    }\n\n    /**\n     * Apply the function to each value yielded by this generator. It is called with two arguments,\n     * the value yielded, and a sequential index. The return value is a generator that yields the\n     * values produced by the function.\n     * @param f\n     * @param thisArg Optional value to be supplied as context `this` for function _f_.\n     */\n    map<V>(f: IndexedFn<T, V, S>, thisArg?: any): Enhanced<V, S, TReturn, TNext> {\n        return this._impl.map(f, thisArg, this);\n    }\n\n\n    /**\n     * Return a new [[EnhancedGenerator]] that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     */\n    filter(f: IndexedPredicate<T, S>, thisArg?: any): Enhanced<T, S, TReturn, TNext> {\n        return this._impl.filter(f, thisArg, this);\n    }\n\n    /**\n     * Flatten the values yielded by this generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param depth (default = 1)\n     */\n    flat<D extends number>(depth: D = 1 as D): Enhanced<S, FlatGen<T, D>, TReturn, TNext> {\n        return this._impl.flat<D, T, TReturn, TNext>(depth, this);\n    }\n\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a generator that yields the individual values at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param depth\n     */\n    flatMap<D extends number = 1>(f: IndexedFn<T, FlatGen<T, D>, S>, depth: D = 1 as D):\n        Enhanced<S, FlatGen<T, D>, TReturn, TNext>\n    {\n        return this._impl.flatMap<D, T, FlatGen<T, D>, TReturn, TNext>(f, depth, this);\n    }\n\n    /**\n     * Return a new [[EnhancedGenerator]] that only yields the indicated values, skipping _start_ initial values\n     * and continuing until the _end_.\n     * @param start\n     * @param end\n     */\n    slice(start: number = 0, end: number = Number.POSITIVE_INFINITY): Enhanced<T, S, TReturn | undefined, TNext> {\n        return this._impl.slice(start, end, this);\n    }\n\n    /**\n     * Concatenates generators (or iterators or iterables).\n     *\n     * Ensures that any supplied generators are terminated when this is terminated.\n     * @param gens zero or more additional [[Genable]] to provide values.\n     */\n\n    concat<T, TReturn, TNext>(...gens: Array<Genable<T, S, TReturn, TNext>>):\n        Enhanced<T, S, TReturn | void, TNext>\n    {\n        const self = this as UnwrapArray<typeof gens>;\n        return this._impl.concat(self, ...gens);\n    }\n\n\n    /**\n     * Like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\") is omitted\n     * because there is no array.\n     * @param f\n     */\n    reduce<A, T, TReturn, TNext>(f: Reducer<A, T, T, S>): ReturnValue<A, S>;\n    /**\n     * Like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\") is omitted\n     * because there is no array.\n     * @param f\n     * @param init\n     */\n    reduce<A, T, TReturn = T, TNext = T>(f: Reducer<A, T, A, S>, init: A): ReturnValue<A, S>;\n    reduce<A>(f: Reducer<A, T, A, S>, init?: A): ReturnValue<A, S> {\n        return this._impl.reduce<A, T, TReturn, TNext>(f, init as A, this);\n    }\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    some<T>(p: IndexedPredicate<T, S>, thisArg?: any): ReturnValue<boolean, S> {\n        // Why is type typecast to Genable needed here?\n        // Yet the seemingly identical case of 'every' below does not?\n        return this._impl.some(p, thisArg, this as Genable<T, S, TReturn, TNext>);\n    }\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    every(p: IndexedPredicate<T, S>, thisArg?: any): ReturnValue<boolean, S> {\n        return this._impl.every(p, thisArg, this as Genable<T, S, TReturn, TNext>);\n    }\n\n\n    /**\n     * Returns a new generator that repeats the last value returned by this (or `undefined` if this\n     * did not return any values).\n     *\n     * @param max\n     */\n    repeatLast(max: number = Number.POSITIVE_INFINITY): Enhanced<T, S, TReturn | void, TNext> {\n        return this._impl.repeatLast(this, max);\n    }\n\n\n    /**\n     * Returns a new generator that repeats the supplied value after this generator\n     * completes.\n     *\n     * @param value the value to repeat\n     * @param repetitions The number repetitions; the default is infinite.\n     */\n\n    repeat<N>(value: N, repetitions: number = Number.POSITIVE_INFINITY): Enhanced<T | N, S, void, TNext> {\n        const tail = this._impl.repeat<T|N, void, TNext>(value, repetitions);\n        const result = this._impl.concat(\n            this as Genable<T|N, S, undefined, TNext>,\n            tail as Genable<T|N, S, undefined, TNext>\n        );\n        return result as Enhanced<T | N, S, undefined, TNext>;\n    }\n\n    /**\n     * Combines this generator with additional ones, returning a generator that produces a tuple with\n     * each of their results, with this generator's result first.\n     *\n     * Terminates when any generator terminates. To get other behaviors, use with [[EnhancedGenerator.repeat]] or\n     * [[EnhancedGenerator.repeatLast]].\n     * @param gens\n     */\n\n    zip<G extends (Genable<T, S, TReturn, TNext>)[], T, TReturn, TNext>(...gens: G):\n        Enhanced<Array<T>, S, TReturn, TNext>\n    {\n        return this._impl.zip(this as Genable<T, S, TReturn, TNext>, ...gens) as\n            Enhanced<Array<T>, S, TReturn, TNext>;\n    }\n\n    /**\n     * Trivial, but handy, same as **Array.prototype.join**.\n     * @param sep (default = ',').\n     *\n     * See also [[EnhancedGenerator.join]]\n     */\n    join(sep?: string): ReturnValue<string, S> {\n        return this._impl.join(this, sep);\n    }\n\n    /**\n     * Sorts the supplied values and returns a sorted array.\n     * @param cmp a comparison function\n     */\n    sort(cmp?: (a: T, b: T) => number): ReturnValue<T[], S> {\n        return this._impl.sort(cmp)(this as Genable<T, S, TReturn, TNext>);\n    }\n}\n"],"names":["Enhancements","returning","Symbol","toStringTag","asArray","this","_impl","limit","max","forEach","f","thisArg","map","filter","flat","depth","flatMap","slice","start","end","Number","POSITIVE_INFINITY","concat","gens","reduce","init","some","p","every","repeatLast","repeat","value","repetitions","tail","zip","join","sep","sort","cmp"],"mappings":"6DAkCsBA,EAOlBC,UA2BA,CAACC,OAAOC,aAURC,UACI,OAAOC,KAAKC,MAAMF,QAA2BC,MAQjDE,MAAMC,GACF,OAAOH,KAAKC,MAAMC,MAAMC,EAAKH,MASjCI,QAAQC,EAA0BC,GAC9BN,KAAKC,MAAMG,QAA2BC,EAAGC,EAASN,MAUtDO,IAAOF,EAAuBC,GAC1B,OAAON,KAAKC,MAAMM,IAAIF,EAAGC,EAASN,MAWtCQ,OAAOH,EAA2BC,GAC9B,OAAON,KAAKC,MAAMO,OAAOH,EAAGC,EAASN,MAWzCS,KAAuBC,EAAW,GAC9B,OAAOV,KAAKC,MAAMQ,KAA2BC,EAAOV,MAYxDW,QAA8BN,EAAmCK,EAAW,GAGxE,OAAOV,KAAKC,MAAMU,QAA6CN,EAAGK,EAAOV,MAS7EY,MAAMC,EAAgB,EAAGC,EAAcC,OAAOC,mBAC1C,OAAOhB,KAAKC,MAAMW,MAAMC,EAAOC,EAAKd,MAUxCiB,UAA6BC,GAIzB,OAAOlB,KAAKC,MAAMgB,OADLjB,QACqBkB,GAiBtCC,OAAUd,EAAwBe,GAC9B,OAAOpB,KAAKC,MAAMkB,OAA6Bd,EAAGe,EAAWpB,MAWjEqB,KAAQC,EAA2BhB,GAG/B,OAAON,KAAKC,MAAMoB,KAAKC,EAAGhB,EAASN,MAWvCuB,MAAMD,EAA2BhB,GAC7B,OAAON,KAAKC,MAAMsB,MAAMD,EAAGhB,EAASN,MAUxCwB,WAAWrB,EAAcY,OAAOC,mBAC5B,OAAOhB,KAAKC,MAAMuB,WAAWxB,KAAMG,GAYvCsB,OAAUC,EAAUC,EAAsBZ,OAAOC,mBAC7C,MAAMY,EAAO5B,KAAKC,MAAMwB,OAAyBC,EAAOC,GAKxD,OAJe3B,KAAKC,MAAMgB,OACtBjB,KACA4B,GAcRC,OAAuEX,GAGnE,OAAOlB,KAAKC,MAAM4B,IAAI7B,QAA0CkB,GAUpEY,KAAKC,GACD,OAAO/B,KAAKC,MAAM6B,KAAK9B,KAAM+B,GAOjCC,KAAKC,GACD,OAAOjC,KAAKC,MAAM+B,KAAKC,EAAhBjC,CAAqBA"}