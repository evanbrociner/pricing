{"version":3,"file":"index.js","sources":["../../src/functions.ts","../../src/enhancements.ts","../../src/sync.ts","../../src/async.ts","../../src/generators.ts","../../node_modules/denque/index.js","../../src/events.ts","../../src/future.ts","../../src/async-mixin.ts","../../src/sync-mixin.ts","../../src/util.ts","../../src/range.ts"],"sourcesContent":["/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * Functions to test (as typeguards) and coerce generators, iterators, etc.\n *\n * @packageDocumentation\n * @module functions\n * @preferred\n */\n\n\nimport type {Async, Sync, Genable, FullIterable, FullIterableIterator} from \"./types\";\n\n/**\n * Predicate/Type Guard for any function.\n * @param f\n */\nexport const isFunction = <A extends Function>(f: (A | any)): f is A => {\n    return typeof f === 'function';\n}\n\n/**\n * Predicate/type guard to determine if an object is [[Genable]]. An object is [[Genable]] if it\n * supports the `Iterator` or `Iterable` protocols. (Generators support both).\n * @param g\n */\nexport const isGenable = <T, TReturn = T, TNext = T>(g: Iterator<T, TReturn, TNext>|Iterable<T>|Generator<T, TReturn, TNext>|any):\n    g is Genable<T, Sync, TReturn, TNext> =>\n        g && (isIterator(g) || isIterable(g));\n\n\nexport const isAsyncGenable = <T, TReturn, TNext>(g: AsyncIterator<T, TReturn, TNext>|AsyncIterable<T>|AsyncGenerator<T,TReturn,TNext>|any):\n    g is Genable<T, Async, TReturn, TNext> =>\n        g && (isAsyncIterator<T, TReturn, TNext>(g) || isAsyncIterable<T, TReturn, TNext>(g) || isIterable<T, TReturn, TNext>(g));\n\n/**\n * Predicate/type guard to determine if an object is (or looks like, structurally) a Generator.\n * @param g\n */\nexport const isGenerator = <T, TReturn, TNext>(g: Genable<T, Sync, TReturn, TNext>|any): g is Generator<T, TReturn, TNext> =>\n    g &&\n    isFunction(g.next)\n    && isFunction(g.return)\n    && isFunction(g.throw)\n    && isFunction(g[Symbol.iterator]);\n\n/**\n * Predicate/type guard to determine if an object is (or looks like, structurally) a AsyncGenerator.\n * @param g\n */\nexport const isAsyncGenerator = <T, TReturn, TNext>(g: Genable<T, Async, TReturn, TNext>|any): g is AsyncGenerator<T> =>\n    g &&\n    isFunction(g.next)\n    && isFunction(g.return)\n    && isFunction(g.throw)\n    && isFunction(g[Symbol.asyncIterator]);\n\n/**\n * Coerce an object to an object that can act as a generator (that is, satisfy both `Iterator`\n * and `Iterable`).\n *\n * If it is an `Iterator` but not `Iterable`, or `Iterable` but not `Iterator`, it is wrapped\n * in a generator. This generator is __not__ enhanced. Use [[Sync.enhance]] on the result if\n * you need an enhanced generator.\n * @param i\n */\nexport function toGenerator<T, TReturn = T, TNext = T>(i: Genable<T, Sync, TReturn, TNext>): Generator<T, TReturn, TNext> {\n    if (isGenerator(i)) return i;\n    if (isIterator(i)) {\n        const it = i;\n\n        function* wrap() {\n            while (true) {\n                const r = it.next();\n                if (r.done) return r.value;\n                yield r.value;\n            }\n        }\n\n        return wrap();\n    } else if (isIterable(i)) {\n        return toGenerator(i[Symbol.iterator]() as Iterator<T, TReturn, TNext>);\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\n\n/**\n * Coerce an object to an object that can act as a async generator (that is, satisfy both `Iterator`\n * and `Iterable`).\n *\n * If it is an `AsyncIterator` but not `AsyncIterable`, or `AsyncIterable` but not `AsyncIterator`,\n * it is wrapped in an async generator. This generator is __not__ enhanced. Use [[Async.enhance]] on the result if\n * you need an enhanced generator.\n * @param i\n */\nexport function toAsyncGenerator<T, TReturn, TNext>(i: Genable<T, Async, TReturn, TNext>|Genable<T, Sync, TReturn, TNext>):\n    AsyncGenerator<T, TReturn, TNext>\n{\n    if (isAsyncGenerator(i)) return i;\n    if (isAsyncIterator(i)) {\n        const it = i;\n        async function* wrap() {\n            while (true) {\n                const r = await it.next();\n                if (r.done) return r.value;\n                yield r.value;\n            }\n        }\n        return wrap();\n    } else if (isAsyncIterable(i)) {\n        return toAsyncGenerator(i[Symbol.asyncIterator]()) as AsyncGenerator<T, TReturn, TNext>;\n    } else if (isIterable(i)) {\n        return toAsyncGenerator(i[Symbol.iterator]() as Iterator<T, TReturn, TNext>);\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\n/**\n * Coerce a sync [[Genable]] object to an `Iterator`. If the object is a `Generator` or an `Iterator` it is returned,\n * while if it is an `Iterable`, `[Symbol.iterator]`() is invoked.\n * @param i\n */\nexport function toIterator<T, TReturn, TNext>(i: Genable<T, Sync, TReturn, TNext>): Iterator<T, TReturn, TNext> {\n    if (isGenerator(i)) return i;\n    if (isIterator(i)) return i;\n    if (isIterable(i)) {\n        return i[Symbol.iterator]() as Iterator<T, TReturn, TNext>;\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\n\n/**\n * Coerce an async [[Genable]] object to an `AsyncIterator`. If the object is a `Generator` or an `Iterator` it is returned,\n * while if it is an `Iterable`, `[Symbol.iterator]`() is invoked.\n * @param i\n */\nexport function toAsyncIterator<T, TReturn, TNext = T>(i: Genable<T, Async, TReturn, TNext>): AsyncIterator<T, TReturn, TNext> {\n    if (isAsyncGenerator(i)) return i;\n    if (isAsyncIterable(i)) {\n        return i[Symbol.asyncIterator]() as AsyncIterator<T, TReturn, TNext>;\n    } else if (isIterable(i)) {\n        return asyncAdaptor(toIterator(i));\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\nconst asyncAdaptor = <T, TReturn, TNext>(i: Iterator<T, TReturn, TNext>):\n    AsyncGenerator<T, TReturn, TNext> =>\n{\n    const it = i as unknown as AsyncIterator<T>;\n    let self: AsyncGenerator<T> & {returning?: any};\n    async function* asyncAdaptor(): AsyncGenerator<T> {\n        let nr: any;\n        let done = false;\n        try {\n            while (true) {\n                const r = await Promise.resolve(it.next());\n                if (r.done) {\n                    done = true;\n                    return r.value;\n                }\n                try {\n                    nr = yield r.value;\n                } catch (e) {\n                    await it.throw?.(e);\n                    throw(e);\n                }\n            }\n        } finally {\n            if (!done) {\n                await i.return?.(self.returning);\n            }\n        }\n    }\n    return self = asyncAdaptor();\n};\n\n/**\n * Coerce a [[Genable]] object to `Iterable`. If it is already an `Iterable`, it is returned\n * unchanged. If it is an `Iterator`, it is wrapped in an object with a `[Symbol.iterator]`\n * method that returns the supplied iterator.\n * @param i\n */\nexport function toIterable<T, TReturn = T, TNext = T>(i: Genable<T,Sync,TReturn,TNext>):\n    FullIterable<T, Sync, TReturn, TNext>\n{\n    if (isIterable(i)) return i as FullIterable<T, Sync, TReturn, TNext>;\n    return {\n        [Symbol.iterator]: () => i\n    } as FullIterable<T, Sync, TReturn, TNext>;\n}\n\n\n/**\n * Coerce a [[Genable]] object to `AsyncIterable`. If it is already an `AsyncIterable`, it is returned\n * unchanged. If it is an `AsyncIterator`, it is wrapped in an object with a `[Symbol.asyncIterator]`\n * method that returns the supplied iterator.\n * @param i\n */\nexport function toAsyncIterable<T, TReturn, TNext>(i: Genable<T, Async, TReturn, TNext>):\n    FullIterable<T, Async, TReturn, TNext>\n{\n    if (isAsyncIterable<T, TReturn, TNext>(i)) return i;\n    if (isIterable<T, TReturn, TNext>(i)) {\n        return toAsyncIterable_adaptor<T, TReturn, TNext>(i) as\n            FullIterable<T, Async, TReturn, TNext>;\n    }\n    return {\n        [Symbol.asyncIterator]: () => i\n    } as FullIterable<T, Async, TReturn, TNext>;\n}\nasync function* toAsyncIterable_adaptor<T, TReturn, TNext>(iterable: Iterable<T>):\n    AsyncGenerator<T, TReturn, TNext>\n{\n    const it = iterable[Symbol.iterator]();\n    let nr: any = undefined;\n    while (true) {\n        const r = await it.next(nr);\n        if (r.done) return r.value;\n        nr = yield r.value;\n    }\n}\n\n// noinspection JSUnusedGlobalSymbols\n/**\n * Similar to [[toGenerator]], but does not require the presence of `Generator.return` or `Generator.throw` methods.\n * @param i\n */\nexport function toIterableIterator<T, TReturn = T, TNext = T>(i: Genable<T, Sync, TReturn, TNext>): FullIterableIterator<T, Sync, TReturn, TNext> {\n    if (isIterable(i) && isIterator(i)) return i as FullIterableIterator<T, Sync, TReturn, TNext>;\n    if (isIterable(i)) {\n        // Invoke [Symbol.iterator]() just once, on first use.\n        let _it: Iterator<T>|undefined = undefined;\n        const it = () => _it ?? (_it = i[Symbol.iterator]());\n        const iit: FullIterableIterator<T, Sync, TReturn, TNext> = {\n            [Symbol.iterator]: () => iit,\n            next: (val?: TNext) => it().next(val as undefined),\n            return: it().return && ((val) => it().return!(val)),\n            throw: it().throw && ((val) => it().throw!(val))\n        };\n        return iit;\n    }\n    if (isIterator(i)) {\n        const iit: FullIterableIterator<T, Sync, TReturn, TNext> = {\n            [Symbol.iterator]: () => iit,\n            next: (val?: TNext) => i.next(val!),\n            return: i.return && ((val) => i.return!(val)),\n            throw: i.throw && ((val) => i.throw!(val))\n        }\n        return iit;\n    }\n    throw new Error(`Not iterator nor iterable: ${i}`);\n}\n\n\n/**\n * Similar to [[toAsyncGenerator]], but does not require the presence of `AsyncGenerator.return` or\n * `AsyncGenerator.throw` methods.\n * @param i\n */\nexport function toAsyncIterableIterator<T, TReturn, TNext>(i: Genable<T, Async, TReturn, TNext>):\n    FullIterableIterator<T, Async, TReturn, TNext>\n{\n    if (isAsyncIterable<T, TReturn, TNext>(i) && isAsyncIterator<T, TReturn, TNext>(i)) {\n        return i as unknown as FullIterableIterator<T, Async, TReturn, TNext>;\n    }\n    if (isAsyncIterable<T, TReturn, TNext>(i)) {\n        // Invoke [Symbol.iterator]() just once, on first use.\n        let _it: AsyncIterator<T, TReturn, TNext>|undefined = undefined;\n        const it = () => _it ?? (_it = i[Symbol.asyncIterator]() as AsyncIterator<T, TReturn, TNext>);\n        const iit: AsyncIterableIterator<T> = {\n            [Symbol.asyncIterator]: () => iit,\n            next: () => it().next(),\n            return: it().return && ((val) => it().return!(val)),\n            throw: it().throw && ((val) => it().throw!(val))\n        };\n        return iit;\n    }\n    if (isIterable<T, TReturn, TNext>(i)) {\n        return toAsyncIterable_adaptor(i);\n    }\n    if (isAsyncIterator(i)) {\n        const iit: AsyncIterableIterator<T> = {\n            [Symbol.asyncIterator]: () => iit,\n            next: (val: any) => i.next(val),\n            return: i.return && ((val) => i.return!(val)),\n            throw: i.throw && ((val) => i.throw!(val))\n        }\n        return iit;\n    }\n    throw new Error(`Not iterator nor iterable: ${i}`);\n}\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `Iterator` protocol (has a `next()` method).\n *\n * Note: There is no way to statically distinguish between an `Iterator` and an `AsyncIterator`. You will get\n * runtime errors if you don't anticipate the distinction.\n * @param i\n */\nexport const isIterator = <K, KReturn = K, KNext = K>(i: Iterable<K> | FullIterable<K, Sync, KReturn, KNext> | any):\n    i is Iterator<K, KReturn, KNext> =>\n        i && typeof i.next === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `AsyncIterator` protocol (has a `next()` method).\n *\n * Note: There is no way to statically distinguish between an `Iterator` and an `AsyncIterator`. You will get\n * runtime errors if you don't anticipate the distinction.\n * @param i\n */\nexport const isAsyncIterator = <K, KReturn = K, KNext = K>(i: AsyncIterable<K> | AsyncIterator<K, KReturn, KNext>| any):\n    i is AsyncIterator<K, KReturn, KNext> =>\n        i && typeof i.next === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `Iterable` protocol (has a `[Symbol.iterator]`\n * method).\n * @param i\n */\nexport const isIterable = <K, KReturn = K, KNext = K>(i: Iterable<K> | FullIterable<K, Sync, KReturn, KNext> | any): i is FullIterable<K, Sync, KReturn, KNext>  =>\n    i && typeof i[Symbol.iterator] === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `AsyncIterable` protocol (has a `[Symbol.asyncIterator]`\n * method).\n * @param i\n */\nexport const isAsyncIterable = <K, KReturn = K, KNext = K>(i: AsyncIterable<K> | FullIterable<K, Async, KReturn, KNext> | any):\n    i is FullIterable<K, Async, KReturn, KNext> =>\n        i && typeof i[Symbol.asyncIterator] === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `Iterable` protocol (has a `[Symbol.iterator]`\n * method) and the `Iterator` protocol (a next() method).\n * @param i\n */\nexport const isIterableIterator = <K, KReturn = K, KNext = K>(i: Iterable<K>|Iterator<K, KReturn, KNext>|any):\n    i is FullIterableIterator<K, Sync, KReturn, KNext> =>\n        isIterator(i) && isIterable(i);\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `AsyncIterable` protocol (has a `[Symbol.asyncIterator]`\n * method) and the `AsyncIterator` protocol (a next() method).\n * @param i\n */\nexport const isAsyncIterableIterator = <K, KReturn = K, KNext = K>(i: Iterable<K>|Iterator<K, KReturn, KNext>|any):\n    i is FullIterableIterator<K, Async, KReturn, KNext> =>\n        isAsyncIterator(i) && isAsyncIterable(i);\n\n/**\n * Wrap a function in a catch block.\n * @param f\n * @param onError Called when an error is thrown. The return value is returned. If not supplied, undefined is returned.\n */\nexport const doCatch = <A extends any[], R>(f: (...args: A) => R, onError?: (e: Error) => R):\n    ((...args: A) => (R | undefined)) => {\n    return (...args: A) => {\n        try {\n            return f(...args);\n        } catch (e) {\n            return onError?.(e);\n        }\n    };\n};\n","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * This provides the trampoline methods that are shared between synchronous and\n * asynchronous enhanced generators. Methods dispatch to {@link Sync} or {@link Async}\n * as appropriate.\n *\n * This becomes part of the prototype chain of enhanced generator instances. It does\n * __not__ modify any global prototypes.\n *\n * You should not need to reference this directly. In Typescript, if you need a\n * type that covers both sync and async enhanced generators, use {@link Enhanced} (for,\n * generators) or the {@link GeneratorOps} interface (for the functional interface).\n *\n * @packageDocumentation\n * @module enhancements\n * @preferred\n */\n\nimport {Async, Enhanced, FlatGen, Genable, GeneratorOps, IndexedFn, IndexedPredicate, Reducer, ReturnValue, SyncType, UnwrapArray} from \"./types\";\n\n/**\n * Enhancements for generators\n */\n\nexport type {Enhanced} from './types';\n\n/**\n * The trampoline methods that link enhanced generators to [[Sync]] or [[Async]]\n * methods.\n */\nexport abstract class Enhancements<\n        T, TReturn, TNext, S extends SyncType\n        >\n{\n    abstract _impl: GeneratorOps<S>;\n\n    // Set on a call to return().\n    returning?: any;\n\n    abstract next(...arg: [] | [arg: TNext]):\n        S extends Async\n            ? Promise<IteratorResult<T, TReturn>>\n            : IteratorResult<T, TReturn>;\n\n    abstract return(value: TReturn):\n        S extends Async\n            ? Promise<IteratorReturnResult<TReturn>>\n            : IteratorReturnResult<TReturn>;\n\n    abstract throw(e: any):\n        S extends Async\n            ? Promise<IteratorReturnResult<TReturn>>\n            : IteratorReturnResult<TReturn>;;\n\n    abstract [Symbol.iterator]:\n        S extends Async\n            ? undefined\n            : () => this & IterableIterator<T>;\n\n    abstract [Symbol.asyncIterator]:\n        S extends Async\n            ? () => this & AsyncIterableIterator<T>\n            : undefined;\n\n    [Symbol.toStringTag]:\n        S extends Async\n            ? 'EnhancedAsyncGenerator'\n            : 'EnhancedGenerator';\n\n    /**\n     * Return all of the values from this generator as an array. You do not want to call this on an\n     * infinite generator (for obvious reasons); consider using [[EnhancedGenerator.slice]] or\n     * [[EnhancedGenerator.limit]] to limit the size before calling this.\n     */\n    asArray(): ReturnValue<T[], S> {\n        return this._impl.asArray<T, TReturn, TNext>(this);\n    }\n\n    /**\n     * Limit the number of values that can be generated. A `RangeError` is thrown if this limit is\n     * exceeded. See [[EnhancedGenerator.slice]] if you want to truncate.\n     * @param max\n     */\n    limit(max: number): Enhanced<T, S, TReturn, TNext> {\n        return this._impl.limit(max, this);\n    }\n\n    /**\n     * Operate on each value produced by this generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @param thisArg Value to be supplied as context `this` for function _f_.\n     */\n    forEach(f: IndexedFn<T, void, S>, thisArg?: any): void {\n        this._impl.forEach<T, TReturn, TNext>(f, thisArg, this);\n    }\n\n    /**\n     * Apply the function to each value yielded by this generator. It is called with two arguments,\n     * the value yielded, and a sequential index. The return value is a generator that yields the\n     * values produced by the function.\n     * @param f\n     * @param thisArg Optional value to be supplied as context `this` for function _f_.\n     */\n    map<V>(f: IndexedFn<T, V, S>, thisArg?: any): Enhanced<V, S, TReturn, TNext> {\n        return this._impl.map(f, thisArg, this);\n    }\n\n\n    /**\n     * Return a new [[EnhancedGenerator]] that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     */\n    filter(f: IndexedPredicate<T, S>, thisArg?: any): Enhanced<T, S, TReturn, TNext> {\n        return this._impl.filter(f, thisArg, this);\n    }\n\n    /**\n     * Flatten the values yielded by this generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param depth (default = 1)\n     */\n    flat<D extends number>(depth: D = 1 as D): Enhanced<S, FlatGen<T, D>, TReturn, TNext> {\n        return this._impl.flat<D, T, TReturn, TNext>(depth, this);\n    }\n\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a generator that yields the individual values at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param depth\n     */\n    flatMap<D extends number = 1>(f: IndexedFn<T, FlatGen<T, D>, S>, depth: D = 1 as D):\n        Enhanced<S, FlatGen<T, D>, TReturn, TNext>\n    {\n        return this._impl.flatMap<D, T, FlatGen<T, D>, TReturn, TNext>(f, depth, this);\n    }\n\n    /**\n     * Return a new [[EnhancedGenerator]] that only yields the indicated values, skipping _start_ initial values\n     * and continuing until the _end_.\n     * @param start\n     * @param end\n     */\n    slice(start: number = 0, end: number = Number.POSITIVE_INFINITY): Enhanced<T, S, TReturn | undefined, TNext> {\n        return this._impl.slice(start, end, this);\n    }\n\n    /**\n     * Concatenates generators (or iterators or iterables).\n     *\n     * Ensures that any supplied generators are terminated when this is terminated.\n     * @param gens zero or more additional [[Genable]] to provide values.\n     */\n\n    concat<T, TReturn, TNext>(...gens: Array<Genable<T, S, TReturn, TNext>>):\n        Enhanced<T, S, TReturn | void, TNext>\n    {\n        const self = this as UnwrapArray<typeof gens>;\n        return this._impl.concat(self, ...gens);\n    }\n\n\n    /**\n     * Like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\") is omitted\n     * because there is no array.\n     * @param f\n     */\n    reduce<A, T, TReturn, TNext>(f: Reducer<A, T, T, S>): ReturnValue<A, S>;\n    /**\n     * Like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\") is omitted\n     * because there is no array.\n     * @param f\n     * @param init\n     */\n    reduce<A, T, TReturn = T, TNext = T>(f: Reducer<A, T, A, S>, init: A): ReturnValue<A, S>;\n    reduce<A>(f: Reducer<A, T, A, S>, init?: A): ReturnValue<A, S> {\n        return this._impl.reduce<A, T, TReturn, TNext>(f, init as A, this);\n    }\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    some<T>(p: IndexedPredicate<T, S>, thisArg?: any): ReturnValue<boolean, S> {\n        // Why is type typecast to Genable needed here?\n        // Yet the seemingly identical case of 'every' below does not?\n        return this._impl.some(p, thisArg, this as Genable<T, S, TReturn, TNext>);\n    }\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    every(p: IndexedPredicate<T, S>, thisArg?: any): ReturnValue<boolean, S> {\n        return this._impl.every(p, thisArg, this as Genable<T, S, TReturn, TNext>);\n    }\n\n\n    /**\n     * Returns a new generator that repeats the last value returned by this (or `undefined` if this\n     * did not return any values).\n     *\n     * @param max\n     */\n    repeatLast(max: number = Number.POSITIVE_INFINITY): Enhanced<T, S, TReturn | void, TNext> {\n        return this._impl.repeatLast(this, max);\n    }\n\n\n    /**\n     * Returns a new generator that repeats the supplied value after this generator\n     * completes.\n     *\n     * @param value the value to repeat\n     * @param repetitions The number repetitions; the default is infinite.\n     */\n\n    repeat<N>(value: N, repetitions: number = Number.POSITIVE_INFINITY): Enhanced<T | N, S, void, TNext> {\n        const tail = this._impl.repeat<T|N, void, TNext>(value, repetitions);\n        const result = this._impl.concat(\n            this as Genable<T|N, S, undefined, TNext>,\n            tail as Genable<T|N, S, undefined, TNext>\n        );\n        return result as Enhanced<T | N, S, undefined, TNext>;\n    }\n\n    /**\n     * Combines this generator with additional ones, returning a generator that produces a tuple with\n     * each of their results, with this generator's result first.\n     *\n     * Terminates when any generator terminates. To get other behaviors, use with [[EnhancedGenerator.repeat]] or\n     * [[EnhancedGenerator.repeatLast]].\n     * @param gens\n     */\n\n    zip<G extends (Genable<T, S, TReturn, TNext>)[], T, TReturn, TNext>(...gens: G):\n        Enhanced<Array<T>, S, TReturn, TNext>\n    {\n        return this._impl.zip(this as Genable<T, S, TReturn, TNext>, ...gens) as\n            Enhanced<Array<T>, S, TReturn, TNext>;\n    }\n\n    /**\n     * Trivial, but handy, same as **Array.prototype.join**.\n     * @param sep (default = ',').\n     *\n     * See also [[EnhancedGenerator.join]]\n     */\n    join(sep?: string): ReturnValue<string, S> {\n        return this._impl.join(this, sep);\n    }\n\n    /**\n     * Sorts the supplied values and returns a sorted array.\n     * @param cmp a comparison function\n     */\n    sort(cmp?: (a: T, b: T) => number): ReturnValue<T[], S> {\n        return this._impl.sort(cmp)(this as Genable<T, S, TReturn, TNext>);\n    }\n}\n","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * This entry point loads synchronous extended generators\n * @packageDocumentation\n * @module sync\n * @preferred\n */\n\nimport type {Enhanced, FlatGen, Genable, GeneratorOps, GenOp, GenOpValue, GenVoid, IndexedFn, IndexedPredicate, Reducer, ReturnValue, UnwrapArray} from \"./types\";\n// Should be 'import type' but that makes TS insist it can't be a value here even after defining it.\nimport {Sync} from './types';\nimport {doCatch, isGenable, isGenerator, isIterable, isIterator, toGenerator, toIterable, toIterator} from \"./functions\";\nimport {Enhancements} from \"./enhancements\";\n\n/**\n * An extension to generators, that provides for operations like:\n * * map<T, R>(gen: Generator<T>) => (fn: T => R) => Generator<R>\n * * EnhancedGenerator<T>.map<R>(fn: T => R) => Generator<R>\n * @packageDocumentation\n * @module Generators\n * @preferred\n */\n\nclass Sync_ implements GeneratorOps<Sync> {\n    /**\n     * Return a generator that yields the supplied values.\n     * @param values\n     */\n    of<T extends any[], TReturn, TNext>(...values: T):\n        Enhanced<UnwrapArray<T>, Sync, TReturn, TNext>\n    {\n        return this.enhance(values);\n    }\n    /**\n     * Return all of the values from this generator as an array. You do not want to call this on an\n     * infinite generator (for obvious reasons); consider using [[EnhancedGenerator.slice]] or\n     * [[EnhancedGenerator.limit]] to limit the size before calling this.\n     */\n    asArray<T, TReturn, TNext>(gen: Genable<T, Sync, TReturn, TNext>):\n        T[]\n    {\n        return [...toIterable<T, TReturn, TNext>(gen)];\n    };\n\n    limit<T, TReturn, TNext>(max: number, gen: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<T, Sync, TReturn, TNext>;\n    limit(max: number): GenOp<Sync>;\n\n    limit<T, TReturn, TNext>(max: number, gen?: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<T, Sync, TReturn, TNext>\n        | GenOp<Sync>\n    {\n        let self: EnhancedGenerator<T, TReturn, TNext>;\n        function *limit<X, XReturn, XNext>(gen: Iterator<X, XReturn, XNext>): Generator<X, XReturn, XNext> {\n            let nr: XNext;\n            let limited: boolean = false;\n            try {\n                for (let i = 0; i < max; i++) {\n                    const r = gen.next(nr!);\n                    if (r.done) {\n                        return r.value;\n                    }\n                    try {\n                        nr = yield r.value;\n                    } catch (e) {\n                        gen.throw?.(e);\n                    }\n                }\n                limited = true;\n                const err = new RangeError(`Generator produced excessive values > ${max}.`);\n                gen.throw?.(err);\n                throw err;\n            } finally {\n                if (!limited) {\n                    gen.return?.(self?.returning);\n                    // Even if the supplied generator refuses to terminate, we terminate.\n                }\n            }\n        }\n        if (gen) {\n            return self = this.enhance(limit(toIterator(gen)));\n        }\n        return <X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) =>\n            this.enhance(limit(toIterator(gen)));\n    }\n\n    forEach<T, TReturn, TNext>(f: IndexedFn<T, void, Sync>, thisArg: any, gen: Genable<T, Sync, TReturn, TNext>):\n        GenVoid<Sync>;\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @param gen the generator.\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T, TReturn, TNext>(f: IndexedFn<T, void, Sync>, gen: Genable<T, Sync, TReturn, TNext>):\n        GenVoid<Sync>;\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @param thisArg Optional value to be supplied as context `this` for function _f_.\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T>(f: IndexedFn<T, void, Sync>, thisArg?: any):\n        <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>) =>\n            GenVoid<Sync>;\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T>(f: IndexedFn<T, void, Sync>):\n        <TReturn, TNext>(gen: Genable<T, Sync, TReturn, TNext>, thisArg?: any) =>\n            GenVoid<Sync>;\n\n    forEach<T, TReturn, TNext>(\n            f: IndexedFn<T, void, Sync>,\n            thisArgOrGen?: Genable<T, Sync, TReturn, TNext>|any,\n            gen?: Genable<T, Sync, TReturn, TNext>\n        )\n    {\n        const forEach = <XReturn, XNext>(f: IndexedFn<T, void, Sync>, thisArg: any, gen: Genable<T, Sync, XReturn, XNext>):\n                GenVoid<Sync> =>\n            {\n                const it = toIterator(gen);\n                let idx = 0;\n                while (true) {\n                    const r = it.next();\n                    if (r.done) return;\n                    f.call(thisArg, r.value, idx++);\n                }\n            };\n        if (gen) return forEach(f, thisArgOrGen, gen);\n        if (isGenable<T>(thisArgOrGen)) return forEach(f, undefined, thisArgOrGen);\n        return <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, thisArg?: any) =>\n            forEach<XReturn, XNext>(f, thisArg ?? thisArgOrGen, gen);\n    }\n\n    map<T, V>(f: IndexedFn<T, V, Sync>):\n        GenOpValue<Sync, T, V>;\n    map<T, V>(f: IndexedFn<T, V, Sync>, thisArg?: any):\n        GenOpValue<Sync, T, V>;\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Sync>, gen: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<V, Sync, TReturn, TNext>;\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Sync>, thisArg: any, gen: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<V, Sync, TReturn, TNext>;\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Sync>, thisArg?: any | Genable<T, Sync, TReturn, TNext>, iter?: Genable<T, Sync, TReturn, TNext>):\n        EnhancedGenerator<V, TReturn, TNext>\n        | (<XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>) => EnhancedGenerator<V, XReturn, XNext>)\n        | (<XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, thisArg?: any) => EnhancedGenerator<V, XReturn, XNext>)\n    {\n        const map = <XReturn, XNext>(thisArg: any, iter: Genable<T, Sync, XReturn, XNext>) => {\n            const gen = toGenerator(iter);\n            let self: EnhancedGenerator<V, XReturn, XNext>;\n            function* map(): Generator<V, XReturn, XNext> {\n                let nr: XNext;\n                let idx = 0;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = gen.next(nr!);\n                                if (r.done) return r.value;\n                                const v: V = f.call(thisArg, r.value, idx++);\n                                try {\n                                    nr = yield v;\n                                } catch (e) {\n                                    gen.throw(e);\n                                }\n                            }\n                        } finally {\n                            const x = gen.return(self?.returning);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (!x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            return self = this.enhance(map());\n        };\n        if (iter) return map(thisArg, iter);\n        if (isGenable<T, TReturn, TNext>(thisArg)) return map(undefined, thisArg);\n        return <XReturn, XNext>(gen: Genable<T, Sync,XReturn, XNext>, genThisArg?: any) =>\n            map(genThisArg ?? thisArg, gen);\n    }\n\n    /**\n     * Return a function that filters a [[Genable]] and yields a new [[EnhancedGenerator]]\n     * that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @typeParam T the type of value.\n     */\n    filter<T>(f: IndexedPredicate<T, Sync>):\n        GenOpValue<Sync, T, T>;\n\n    /**\n     * Return a function that filters a [[Genable]] and yields a new [[EnhancedGenerator]]\n     * that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     * @typeParam T the type of value.\n     */\n    filter<T>(f: IndexedPredicate<T, Sync>, thisArg: any):\n        GenOpValue<Sync, T, T>;\n\n    /**\n     * Return a new [[EnhancedGenerator]] that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param iter a [[Genable|Genable<T>]]\n     * @typeParam T the type of value.\n     */\n    filter<T, TReturn, TNext>(f: IndexedPredicate<T, Sync>, iter: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<T, Sync, TReturn, TNext>;\n    /**\n     * Return a new [[EnhancedGenerator]] that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     * @param iter a [[Genable|Genable<T>]]\n     * @typeParam T the type of value.\n     */\n    filter<T, TReturn, TNext>(f: IndexedPredicate<T, Sync>, thisArg: any, iter: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<T, Sync, TReturn, TNext>;\n\n    /**\n     * Return a function that filters a [[Genable]] and yields a new [[EnhancedGenerator]]\n     * that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     * @param iter the [[Genable]] to filter.\n     * @typeParam T the type of value.\n     */\n    filter<T, TReturn, TNext>(\n        f: IndexedPredicate<T, Sync>,\n        thisArg?: any | Genable<T, Sync, TReturn, TNext>,\n        iter?: Genable<T, Sync, TReturn, TNext>\n    ):\n        Enhanced<T, Sync, TReturn, TNext>\n        | GenOpValue<Sync, T, T>\n    {\n        const filter = <XReturn, XNext>(thisArg: any, iter: Genable<T, Sync, XReturn, XNext>) => {\n            const gen = toGenerator(iter);\n            let self: EnhancedGenerator<T, TReturn, TNext>;\n            function* filter<V>(f: IndexedPredicate<T, Sync>): Generator<T> {\n                let nr: any = undefined;\n                let idx = 0;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = gen.next(nr);\n                                if (r.done) return r.value;\n                                if (f.call(thisArg, r.value, idx++)) {\n                                    try {\n                                        nr = yield r.value;\n                                    } catch (e) {\n                                        gen.throw(e);\n                                    }\n                                }\n                            }\n                        } finally {\n                            const x = gen.return?.(self?.returning);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (!x?.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            return self = this.enhance(filter(f));\n        };\n\n        if (iter) return filter(thisArg, iter);\n        if (isGenable<T>(thisArg)) return filter(undefined, thisArg);\n        return <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, genThisArg?: any) =>\n            filter(genThisArg ?? thisArg, gen);\n    }\n\n    /**\n     * Flatten the values yielded by the generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param depth\n     */\n    flat<D extends number>(depth: D):\n        <X, XReturn = X, XNext = X>(gen: Genable<X, Sync, XReturn, XNext>) =>\n            Enhanced<Sync, FlatGen<X, D>, XReturn, XNext>;\n    /**\n     * Flatten the values yielded by the generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param depth\n     * @param gen\n     */\n    flat<D extends number, T, TReturn, TNext>(depth: D, gen: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<Sync, FlatGen<T, D>, TReturn, TNext>;\n    /**\n     * Flatten the values yielded by the generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param gen\n     * @param depth default = 1\n     */\n    flat<D extends number, T, TReturn, TNext>(gen: Genable<T, Sync, TReturn, TNext>, depth?: D):\n        Enhanced<Sync, FlatGen<T, D>, TReturn, TNext>;\n\n    flat<D extends number, T, TReturn, TNext>(\n        depth: D|Genable<T, Sync, TReturn, TNext>,\n        gen?: Genable<T, Sync, TReturn, TNext> | D\n    ):\n        Enhanced<Sync, FlatGen<T, D>, TReturn, TNext>\n        | (<X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) => Enhanced<Sync, FlatGen<X, D>, XReturn, XNext>)\n    {\n        const flat = <X, XReturn, XNext>(depth: D, gen: Genable<X, Sync, XReturn, XNext>) => {\n            let self: EnhancedGenerator<FlatGen<X, D>, XReturn, XNext>;\n            const gens = new Set<Generator>();\n            if (isGenerator(gen)) gens.add(gen);\n\n            function* flat<D extends number>(it: Iterator<unknown, XReturn, XNext>, depth: D): Generator<FlatGen<X, D>, XReturn, XNext> {\n                let nr: any = undefined;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = it.next(nr);\n                                if (r.done) return r.value;\n                                const v = r.value;\n                                if (isGenerator(v)) {\n                                    gens.add(v);\n                                }\n                                try {\n                                    if (depth > 0 && isIterator<unknown, XReturn, XNext>(v)) {\n                                        yield* flat(v, depth - 1);\n                                    } else if (depth > 0 && isIterable(v)) {\n                                        yield* flat(toIterator<unknown, XReturn, XNext>(v), depth - 1)\n                                    } else {\n                                        nr = yield r.value as FlatGen<T, D>;\n                                    }\n                                } catch (e) {\n                                    it.throw?.(e);\n                                }\n                            }\n                        } finally {\n                            const x = it.return?.(self?.returning);\n                            if (isGenerator(it)) gens.delete(it);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (x && !x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                            for (const g of gens) {\n                                g.return(self?.returning);\n                            }\n                        }\n                    }\n                }\n            }\n\n            return self = this.enhance(flat(toIterator(gen), depth));\n        }\n        if (typeof depth === 'number') {\n            if (gen) {\n                if (isGenable(gen)) {\n                    return flat(depth, gen);\n                } else {\n                    throw new TypeError(`Invalid Genable: ${gen}`);\n                }\n            }\n            return <X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) =>\n                flat(depth, gen);\n        } else if (isGenable(depth)) {\n            return flat((gen ?? 1) as D, depth);\n        }\n        throw new TypeError(`Illegal arguments to flat()`);\n    }\n\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a function that accepts a generator, and returns another generator that yields the individual value\n     * at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param depth\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T>(f: IndexedFn<T, R, Sync>, depth: D):\n        <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>) =>\n            Enhanced<R, Sync, XReturn, XNext>;\n\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a function that accepts a generator, and returns another generator that yields the individual value\n     * at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T>(f: IndexedFn<T, R, Sync>):\n        <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, depth?: D) =>\n            Enhanced<R, Sync, XReturn, XNext>;\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a generator that yields the individual values at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param gen\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T, TReturn, TNext>(f: IndexedFn<T, R, Sync>, gen: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<R, Sync, TReturn, TNext>;\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a generator that yields the individual values at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param depth\n     * @param gen\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T, TReturn, TNext>(f: IndexedFn<T, R, Sync>, depth: D, gen: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<R, Sync, TReturn, TNext>;\n\n    flatMap<D extends number, R extends FlatGen<T, D>, T, TReturn, TNext>(\n            f: IndexedFn<T, R, Sync>,\n            depthOrGen?: D | Genable<T, Sync, TReturn, TNext>,\n            gen?: Genable<T, Sync, TReturn, TNext>\n        ):\n            Enhanced<R, Sync, TReturn, TNext>\n            | (\n                <X, Y extends FlatGen<T, D>, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) =>\n                Enhanced<Y, Sync, XReturn, XNext>\n            )\n            | (\n                <X, Y extends FlatGen<T, D>, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>, depth?: D) =>\n                    Enhanced<Y, Sync, XReturn, XNext>\n            )\n    {\n        const flatMap = <X, XReturn, XNext>(depth: D, gen: Genable<X, Sync, XReturn, XNext>) => {\n            let self: Enhanced<FlatGen<X, D>, Sync, XReturn, XNext>;\n            let idx = 0;\n\n            function* flatMap<D extends number, Y, YReturn, YNext>(it: Iterator<Y, YReturn, YNext>, depth: D):\n                Generator<FlatGen<X, D>, XReturn, XNext>\n            {\n                let nr: YNext;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = it.next(nr!);\n                                if (r.done) return r.value as unknown as XReturn;\n                                const v = f(r.value as unknown as T, idx++);\n                                try {\n                                    if (isIterator<unknown, XReturn, XNext>(v)) {\n                                        if (depth > 1) {\n                                            yield* flatMap(v, depth - 1);\n                                        } else if (depth === 1) {\n                                            yield* toGenerator(v);\n                                        } else {\n                                            yield v;\n                                        }\n                                    } else if (isIterable(v)) {\n                                        if (depth > 1) {\n                                            yield* flatMap(toIterator<unknown, XReturn, XNext>(v), depth - 1);\n                                        } else if (depth === 1) {\n                                            yield* toGenerator(v);\n                                        } else {\n                                            yield v;\n                                        }\n                                    } else {\n                                        nr = (yield v) as unknown as YNext;\n                                    }\n                                } catch (e) {\n                                    it.throw?.(e);\n                                }\n                            }\n                        } finally {\n                            const x = it.return?.(self?.returning);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (x && !x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            return self = this.enhance(flatMap(toIterator(gen), depth));\n        }\n\n        if (isGenable(gen)) {\n            return flatMap(depthOrGen as D ?? 1 as D, gen);\n        } else if (isGenable( depthOrGen)) {\n            return flatMap(1 as D, depthOrGen);\n        }\n        return <X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>, depth?: D) =>\n            flatMap(depthOrGen ?? depth ?? 1 as D, gen);\n    }\n\n    /**\n     * Return a new [[EnhancedGenerator]] that only yields the indicated values, skipping _start_ initial values\n     * and continuing until the _end_.\n     * @param start\n     * @param end\n     */\n    slice<T>(start: number, end: number):\n        <X, XReturn, XNext>(iter: Genable<X, Sync, XReturn, XNext>) =>\n            Enhanced<X, Sync, XReturn | undefined, XNext>;\n\n    /**\n     * Return a new [[EnhancedGenerator]] that only yields the indicated values, skipping _start_ initial values\n     * and continuing until the _end_.\n     * @param start\n     * @param end\n     * @param iter\n     */\n    slice<T, TReturn, TNext>(start: number, end: number, iter: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<T, Sync, TReturn | undefined, TNext>;\n\n    slice<T, TReturn, TNext>(start: number, end: number, iter?: Genable<T, Sync, TReturn, TNext>):\n        Enhanced<T, Sync, TReturn | undefined, TNext>\n        | (\n            <X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) =>\n                Enhanced<X, Sync, XReturn | undefined, XNext>\n        )\n    {\n        const slice = <X, XReturn, XNext>(iter: Genable<X, Sync, XReturn, XNext>):\n                Enhanced<X, Sync, XReturn | undefined, XNext> =>\n            {\n                const it = toIterator(iter);\n                function* slice(start: number, end: number) {\n                    for (let i = 0; i < start; i++) {\n                        const r = it.next();\n                        if (r.done) return r.value;\n                    }\n                    if (end === Number.POSITIVE_INFINITY) {\n                        yield* toIterable(it);\n                    } else {\n                        let nv: XNext;\n                        while (true) {\n                            try {\n                                for (let i = start; i < end; i++) {\n                                    const r = it.next(nv!);\n                                    if (r.done) return r.value;\n                                    try {\n                                        nv = yield r.value;\n                                    } catch (e) {\n                                        const re = it.throw?.(e);\n                                        if (re) {\n                                            if (re.done) return re.value;\n                                            nv = yield re.value;\n                                        }\n                                    }\n                                }\n                            } finally {\n                                const x = it.return?.();\n                                // If the wrapped generator aborted the return, we will, too.\n                                if (x && !x.done) {\n                                    // noinspection ContinueOrBreakFromFinallyBlockJS\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    return;\n                }\n                return this.enhance(slice(start, end));\n        };\n        if (!iter) return slice;\n        return slice(iter);\n    }\n\n    /**\n     * Concatenates generators (or iterators or iterables).\n     *\n     * Ensures that any supplied generators are terminated when this is terminated.\n     * @param gens zero or more additional [[Genable]] to provide values.\n     */\n    concat<\n        T, TReturn, TNext,\n        A extends Array<Genable<T, Sync, TReturn, TNext>>\n    >(...gens: A):\n        Enhanced<T, Sync, TReturn | void, TNext>\n    {\n        let self: Enhanced<T, Sync, TReturn | void, TNext>;\n        function* concat(): Generator<T, TReturn | void, TNext> {\n            let i = 0;\n            try {\n                for (; i < gens.length; i++) {\n                    yield* toIterable<T,TReturn, TNext>(gens[i]);\n                }\n            } finally {\n                // Terminate any remaining generators.\n                for (; i < gens.length; i++) {\n                    const g = gens[i];\n                    if (isGenerator(g)) {\n                        g.return(self?.returning);\n                    }\n                }\n            }\n        }\n        return self = this.enhance(concat()) ;\n    }\n\n    /**\n     * Reduces **gen** like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     * @param f\n     * @param gen\n     */\n    reduce<A, T, TReturn, TNext>(f: Reducer<A, T, T, Sync>, gen: Genable<T, Sync, TReturn, TNext>):\n        A;\n    /**\n     *\n     * Returns a reducer function that, when applied to a `Generator` **gen**, reduces **gen** like\n     * **Array.prototype.reduce**. The 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     *\n     * @param f\n     */\n    reduce<A, T, TReturn, TNext>(f: Reducer<A, T, T, Sync>):\n        (gen: Genable<T, Sync, TReturn, TNext>) =>\n            A;\n    /**\n     *\n     * Returns a reducer function that, when applied to a `Generator` **gen**, reduces **gen** like\n     * `Array.prototype.reduce`. The 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     *\n     * @param f\n     */\n    reduce<A, T>(f: Reducer<A, T, A, Sync>):\n        <TReturn, TNext>(init: A, gen: Genable<T, Sync, TReturn, TNext>) =>\n            A;\n\n    /**\n     * Reduces **gen** like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     * @param f\n     * @param init\n     * @param gen\n     */\n    reduce<A, T, TReturn, TNext>(f: Reducer<A, T, A, Sync>, init: A, gen: Genable<T, Sync, TReturn, TNext>):\n        A;\n\n    /**\n     * Returns a reducer function that, when applied to a `Generator` **gen**, reduces **gen** like\n     * `Array.prototype.reduce`. The 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     *\n     * Alternatively, the init value can be supplied along with the generator as a second argument.\n     * @param f\n     * @param init\n     */\n    reduce<A, T>(f: Reducer<A, T, A, Sync>, init: A):\n        <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>) =>\n            A;\n\n    reduce<A, T, TReturn, TNext>(\n        f: Reducer<A, T, A | T, Sync>,\n        initOrGen?: A | Genable<T, Sync, TReturn, TNext>,\n        gen?: Genable<T, Sync, TReturn, TNext>\n    ): A\n        | (<XHome, XNext>(gen: Genable<T, Sync, XHome, XNext>) => A)\n        | ((f: (acc: A, v: T) => A, init: A) => A)\n        | ((f: (acc: A | T, v: T) => A) => A)\n    {\n\n        const reduce = (init: A | undefined, it: Iterator<T,unknown,unknown>): A => {\n            let acc: A | T | undefined = init;\n            if (acc === undefined) {\n                const r = it.next();\n                if (r.done) throw new TypeError(`No initial value in reduce`);\n                acc = r.value;\n            }\n            while (true) {\n                const r = it.next();\n                if (r.done) return acc as A;\n                acc = f(acc, r.value);\n            }\n        };\n        if (isGenable(gen)) {\n            return reduce(initOrGen as A, toIterator(gen));\n        } else if (isGenable(initOrGen)) {\n            return reduce(undefined, toIterator(initOrGen));\n        }\n        return <XHome, XNext>(gen: Genable<T, Sync, XHome, XNext>, init?: A) =>\n            reduce(init ?? initOrGen, toIterator(gen));\n    }\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    some<T>(p: IndexedPredicate<T, Sync>, thisArg?: any):\n        <XHome, XNext>(gen: Genable<T, Sync, XHome, XNext>) =>\n            ReturnValue<boolean, Sync>;\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     */\n    some<T>(p: IndexedPredicate<T, Sync>):\n        <XHome, XNext>(gen: Genable<T, Sync, XHome, XNext>, thisArg?: any) =>\n            ReturnValue<boolean, Sync>;\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param gen the generator\n     */\n    some<T, TReturn, TNext>(p: IndexedPredicate<T, Sync>, gen: Genable<T, Sync, TReturn, TNext>):\n        ReturnValue<boolean, Sync>;\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     * @param gen the generator\n     */\n    some<T, TReturn, TNext>(p: IndexedPredicate<T, Sync>, thisArg: any, gen: Genable<T, Sync, TReturn, TNext>):\n        ReturnValue<boolean, Sync>;\n\n    some<T, TReturn, TNext>(\n        pred: IndexedPredicate<T, Sync>,\n        thisOrGen?: any | Genable<T, Sync, TReturn, TNext>,\n        gen?: Genable<T, Sync, TReturn, TNext>\n    ):\n        ReturnValue<boolean, Sync>\n        | (<XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, thisArg?: any) =>\n            ReturnValue<boolean, Sync>)\n    {\n        const some = <XReturn, XNext>(thisArg: any, it: Iterator<T, XReturn, XNext>): boolean => {\n            let i = 0;\n            while (true) {\n                const r = it.next();\n                if (r.done) return false;\n                if (pred.call(thisArg, r.value, i++)) return true;\n            }\n        };\n        if (isGenable(gen)) {\n            return some(thisOrGen, toIterator(gen));\n        } else if (isGenable<T, TReturn, TNext>(thisOrGen)) {\n            return some(undefined, toIterator(thisOrGen));\n        } else {\n            return <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, thisArg?: any) =>\n                some<XReturn, XNext>(thisArg ?? thisOrGen, toIterator(gen));\n        }\n    }\n\n    /**\n     * Returns `false` and terminates the generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    every<T>(p: IndexedPredicate<T, Sync>, thisArg?: any):\n        <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>) =>\n            ReturnValue<boolean, Sync>;\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     */\n    every<T>(p: IndexedPredicate<T, Sync>):\n        <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext >, thisArg?: any) =>\n            ReturnValue<boolean, Sync>;\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param gen the generator\n     */\n    every<T, TReturn, TNext>(p: IndexedPredicate<T, Sync>, gen: Genable<T, Sync, TReturn, TNext>):\n        ReturnValue<boolean, Sync>;\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     * @param gen the generator\n     */\n    every<T, TReturn, TNext>(p: IndexedPredicate<T, Sync>, thisArg: any, gen: Genable<T, Sync, TReturn, TNext>):\n        ReturnValue<boolean, Sync>;\n\n    every<T, TReturn, TNext>(\n        pred: IndexedPredicate<T, Sync>,\n        genOrThis?: any | Genable<T, Sync, TReturn, TNext>,\n        gen?: Genable<T, Sync, TReturn, TNext>\n    ):\n        ReturnValue<boolean, Sync>\n        | (\n            <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>) =>\n                ReturnValue<boolean, Sync>\n        )\n    {\n        const every = <XReturn, XNext>(thisArg: any, it: Iterator<T, XReturn, XNext>): boolean => {\n            let i = 0;\n            while (true) {\n                const r = it.next();\n                if (r.done) return true;\n                if (!pred.call(thisArg, r.value, i++)) return false;\n            }\n        };\n        if (isGenable(gen)) {\n            return every(genOrThis, toIterator(gen));\n        } else if (isGenable(gen)) {\n            return <XReturn, XNext>(gen: Genable<T, Sync, XReturn, XNext>, thisArg?: any) =>\n                every(thisArg ?? genOrThis, toIterator(gen));\n        }\n        throw new Error(`Invalid argument to every: ${gen ?? genOrThis}`);\n    }\n\n    /**\n     * Returns a new generator that repeats the last value returned by **gen** (or `undefined` if **gen**\n     * did not return any values).\n     *\n     * @param gen\n     * @param max\n     */\n    repeatLast<T, TReturn, TNext>(\n        gen: Genable<T, Sync, TReturn, TNext>,\n        max: number = Number.POSITIVE_INFINITY\n    ):\n        Enhanced<T, Sync, TReturn | void, TNext>\n    {\n        const it = toIterator(gen);\n        let nr: any;\n        let self: EnhancedGenerator<T, TReturn | void, TNext>;\n\n        function* repeatLast(): Generator<T, TReturn | void, TNext> {\n            try {\n                let last: T;\n                while (true) {\n                    const r = it.next(nr)\n                    if (r.done) break;\n                    try {\n                        nr = yield (last = r.value);\n                    } catch (e) {\n                        const re = it.throw?.(e);\n                        if (re) {\n                            if (re.done) break;\n                            yield last = re.value;\n                        }\n                    }\n                }\n                for (let i = 0; i < max; i++) {\n                    yield last!;\n                }\n            } finally {\n                it.return?.(self?.returning);\n            }\n        }\n\n        return self = this.enhance(repeatLast());\n    }\n\n    /**\n     * Returns a new generator that repeats the supplied value.\n     *\n     * @param value the value to repeat\n     * @param repetitions The number repetitions; the default is infinite.\n     */\n    repeat<T, TReturn, TNext>(value: T, repetitions: number = Number.POSITIVE_INFINITY):\n        Enhanced<T, Sync, TReturn | void, TNext>\n    {\n        function* repeat(): Generator<T, TReturn | void, TNext> {\n            for (let i = 0; i < repetitions; i++) {\n                yield value;\n            }\n        }\n\n        return this.enhance(repeat());\n    }\n\n    /**\n     * Combines generators, returning a generator that produces a tuple with each of their results.\n     *\n     * Terminates when the first generator terminates. To get other behaviors, use with [[EnhancedGenerator.repeat]] or\n     * [[EnhancedGenerator.repeatLast]].\n     * @param gens\n     */\n\n    zip<T, TReturn, TNext>(...gens: Array<Genable<T, Sync, TReturn, TNext>>):\n        Enhanced<Array<T>, Sync, TReturn, TNext>\n    {\n        if (gens.length === 0) return this.enhance([]);\n        const its = gens.map(toIterator);\n        let done = false;\n        let self: Enhanced<Array<T>, Sync, TReturn, TNext>;\n\n        function* zip2(): Generator<Array<T>, TReturn, TNext> {\n            try {\n                while (true) {\n                    let result: Array<T> = [];\n                    for (const g of its) {\n                        const r = g.next();\n                        if (r.done) {\n                            done = true;\n                            return r.value as TReturn;\n                        }\n                        (result as any[]).push(r.value);\n                    }\n                    try {\n                        yield result;\n                    } catch (e) {\n                        for (const g of gens) {\n                            try {\n                                // Weird need for a typecast here.\n                                (g as any).throw?.(e);\n                            } catch {\n                                // Ignore\n                            }\n                        }\n                        throw e;\n                    }\n                }\n            } finally {\n                if (!done) {\n                    for (const g of gens) {\n                        try {\n                            // Weird need for a typecast here.\n                            (g as any).return?.(self?.returning);\n                        } catch {\n                            // Ignore\n                        }\n                    }\n                }\n            }\n        }\n\n        return self = this.enhance(zip2());\n    }\n\n    /**\n     * Returns a function that joins the elements produced by a [[Genable]], analogous to `Array.prototype.join`.\n     * @param sep (default = ',')\n     */\n    join(sep: string):\n        <X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) =>\n            ReturnValue<string, Sync>;\n\n    /**\n     * Joins the elements produced by a [[Genable]], analogous to `Array.prototype.join`.\n     * @param gen\n     * @param sep\n     */\n    join<T, TReturn, TNext>(gen: Genable<T, Sync, TReturn, TNext>, sep?: string):\n        ReturnValue<string, Sync>;\n\n    join<T, TReturn, TNext>(\n        genOrSeparator: Genable<T, Sync, TReturn, TNext>|string,\n        sep?: string\n    ):\n        string\n        | (<X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) => string)\n    {\n        if (typeof genOrSeparator === 'string') {\n            sep = genOrSeparator;\n            return <X, XReturn, XNext>(gen: Genable<X, Sync, XReturn, XNext>) =>\n                this.join(gen, sep);\n        }\n        return [...toIterable(genOrSeparator)].join(sep);\n    }\n\n    /**\n     * Returns a new generator that returns values from each of the supplied sources as they are available.\n     * These will be taken in round-robin fashion from each non-terminated generator, until all have\n     * terminated. The yielded values will not be distinguished by which which source they are taken; for\n     * that, another method will be supplied.\n     *\n     * Any calls to `Generator.throw()` or `Generator.return()` will be passed to all non-terminated\n     * sources.\n     * @param sources\n     */\n\n    merge<T, TReturn, TNext>(...sources: Array<Genable<T, Sync, TReturn, TNext>>):\n        Enhanced<T, Sync, TReturn, TNext>\n    {\n        let self: Enhanced<T, Sync, TReturn, TNext>;\n        let gens: Array<Iterator<T, TReturn, TNext> | null> = sources.map(toIterator);\n        function* merge<X, XReturn, XNext>(gens: Array<Iterator<X, XReturn, XNext> | null>):\n            Generator<X, XReturn, XNext>\n        {\n            let done = false;\n            let running = true;\n            let nv: XNext;\n            try {\n                while (running) {\n                    running = false;\n                    for (let i = 0; i < gens.length; i++) {\n                        const g = gens[i];\n                        if (g) {\n                            const r = g.next(nv!);\n                            if (r.done) {\n                                gens[i] = null;\n                            } else {\n                                running = true;\n                                try {\n                                    nv = yield r.value;\n                                } catch (e) {\n                                    gens.forEach(doCatch(g => g?.throw?.(e)));\n                                }\n                            }\n                        }\n                    }\n                }\n                done = true;\n            } finally {\n                if (!done) {\n                    gens.forEach(doCatch(g => g?.return?.(self?.returning)));\n                }\n            }\n            return self?.returning;\n        }\n        return self = this.enhance(merge(gens));\n    }\n\n    /**\n     * Returns a function that sorts the supplied sources and returns a sorted array.\n     * @param cmp a comparison function\n     */\n    sort<T>(cmp?: ((a: T, b: T) => number)) {\n        return <TReturn, TNext>(...sources: Array<Genable<T, Sync, TReturn, TNext>>) => {\n            const result: T[] = this.merge(...sources).asArray();\n            return result.sort(cmp);\n        }\n    }\n\n    /**\n     * Enhance an existing generator (or iterator or iterable) to be a EnhancedGenerator.\n     * @param gen\n     */\n    enhance<T, TReturn, TNext>(gen: Genable<T, Sync, TReturn, TNext>):\n        EnhancedGenerator<T, TReturn, TNext>\n    {\n        const gen2 = toGenerator(gen) as Partial<EnhancedGenerator<T, TReturn, TNext>>;\n        const old = Object.getPrototypeOf(gen2);\n        const proto = Object.create(EnhancedGenerator.prototype);\n        proto.return = (v: TReturn) => (gen2.returning = v, old.return.call(gen2, v));\n        proto[Symbol.iterator] = () => gen2;\n        Object.setPrototypeOf(gen2, EnhancedGenerator.prototype);\n        return gen2 as EnhancedGenerator<T, TReturn, TNext>;\n    }\n}\n\n/**\n * Utilities to create and use generators which can be manipulated in various ways.\n *\n * Most methods come both as instance (prototype) methods and as static methods. They\n * provide equivalent functionality, but the static methods allow use on `Iterator` and\n * `Iterable` objects without first converting to a generator.\n *\n * The [[EnhancedGenerator.enhance]] method will add additional instance methods to\n * an ordinary generator's prototype (a new prototype, **not** modifying any global prototype!).\n * It can also be used to convert `Iterator` and `Iterable` objects to [[EnhancedGenerator]].\n *\n * For methods which return a EnhancedGenerator, care is take to propagate any `Generator.throw`\n * and `Generator.return` calls to any supplied generators, so they can properly terminate.\n *\n * The exception is [[EnhancedGenerator.flat]] (and by extension, [[EnhancedGenerator.flatMap]]), which cannot know what nested generators\n * they might encounter in the future. Any generators encountered so far will be terminated, however.\n *\n * @typeParam T the type of values returned in the iteration result.\n * @typeParam TReturn the type of values returned in the iteration result when the generator terminates\n * @typeParam TNext the type of value which can be passed to `.next(val)`.\n */\nexport abstract class EnhancedGenerator<T, TReturn, TNext>\n    extends Enhancements<T, TReturn, TNext, Sync>\n    implements Generator<T, TReturn, TNext>, Iterable<T>,\n        Iterator<T, TReturn, TNext>\n{\n    [Symbol.toStringTag]: 'EnhancedGenerator';\n}\n\n/**\n * Factory for synchronous generator operators. See [[GeneratorOps]] for details.\n */\nconst Sync: GeneratorOps<Sync> = new Sync_();\nexport {Sync};\n\nconst makeProto = (base: any) => {\n    const newProto = Object.create(base);\n    const inherit = (proto: any) => {\n        for (const k of Reflect.ownKeys(proto)) {\n            if (k !== 'constructor') {\n                newProto[k] = proto[k];\n            }\n        }\n    };\n    inherit(Enhancements.prototype);\n    return newProto;\n}\n\n/**\n * @internal\n * @constructor\n */\nfunction* Foo() {\n}\n\n/**\n * @internal\n */\nexport const GenProto = Object.getPrototypeOf(Foo());\n\n// Make EnhancedGenerator inherit generator methods.\nObject.setPrototypeOf(EnhancedGenerator.prototype, makeProto(GenProto));\nObject.defineProperty(EnhancedGenerator.prototype, '_impl', {\n    value: Sync,\n    writable: false,\n    enumerable: false,\n    configurable: false\n});\n","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * This entry point loads asynchronous extended generators\n * @packageDocumentation\n * @module async\n * @preferred\n */\n\nimport type {\n    Enhanced, FlatGen, Genable, GeneratorOps, GenOp, GenOpValue, IndexedFn, IndexedPredicate, Reducer, ReturnValue, UnwrapArray\n    } from \"./types\";\n// Should be 'import type' but that makes TS insist it can't be a value here even after defining it.\nimport {Async} from './types';\nimport {\n    isAsyncGenable, isAsyncGenerator, isAsyncIterable, isAsyncIterator, isGenable, isIterable,\n    toAsyncGenerator, toAsyncIterable, toAsyncIterator\n} from \"./functions\";\nimport {Enhancements} from \"./enhancements\";\n\n/**\n * Asynchronous implementation of enhanced generators\n */\n\n\nclass Async_ implements GeneratorOps<Async> {\n    /**\n     * Return a generator that yields the supplied values.\n     * @param values\n     */\n    of<T extends any[], TReturn, TNext>(...values: T):\n        Enhanced<UnwrapArray<T>, Async, TReturn, TNext>\n    {\n        return this.enhance(values);\n    }\n\n    async asArray<T, TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>):\n        Promise<T[]>\n    {\n        const it = toAsyncIterator(gen);\n        const result: T[] = []\n        while (true) {\n            const r = await it.next();\n            if (r.done) {\n                return result;\n            }\n            result.push(r.value);\n        }\n    }\n\n    limit<T, TReturn, TNext>(max: number, gen: Genable<T, Async, TReturn, TNext>):\n        Enhanced<T, Async, TReturn, TNext>;\n\n    limit(max: number):\n        GenOp<Async>;\n\n    limit<T, TReturn, TNext>(\n        max: number,\n        gen?: Genable<T, Async, TReturn, TNext>\n    ):\n         Enhanced<T, Async, TReturn, TNext>\n         | GenOp<Async>\n    {\n        let self: EnhancedAsyncGenerator<T, TReturn, TNext>;\n        async function *limit<X, XReturn = X, XNext = X>(gen: AsyncIterator<X, XReturn, XNext>) {\n            let nr: XNext;\n            let limited: boolean = false;\n            try {\n                for (let i = 0; i < max; i++) {\n                    const r: any = await gen.next(nr!);\n                    if (r.done) {\n                        return r.value;\n                    }\n                    try {\n                        nr = yield r.value;\n                    } catch (e) {\n                        await gen.throw?.(e);\n                    }\n                }\n                limited = true;\n                const err = new RangeError(`Generator produced excessive values > ${max}.`);\n                await gen.throw?.(err);\n                throw err;\n            } finally {\n                if (!limited) {\n                    await gen.return?.(self?.returning);\n                    // Even if the supplied generator refuses to terminate, we terminate.\n                }\n            }\n        }\n        if (gen) {\n            return self = this.enhance(limit(toAsyncIterator(gen)));\n        }\n        return <X, XReturn = X, XNext = X>(gen: Genable<X, Async, XReturn, XNext>) =>\n            this.enhance<X, XReturn, XNext>(limit(toAsyncIterator(gen)));\n    }\n\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @param thisArg Optional value to be supplied as context `this` for function _f_.\n     * @param gen the generator.\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T, TReturn, TNext>(f: IndexedFn<T, undefined, Async>, thisArg: any, gen: Genable<T, Async, TReturn, TNext>):\n        Promise<undefined>;\n\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @param gen the generator.\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T, TReturn, TNext>(f: IndexedFn<T, undefined, Async>, gen: Genable<T, Async, TReturn, TNext>):\n        Promise<undefined>;\n\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @param thisArg Optional value to be supplied as context `this` for function _f_.\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T>(f: IndexedFn<T, undefined, Async>, thisArg?: any):\n        <TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>) =>\n            Promise<undefined>;\n\n    /**\n     * Operate on each value produced by the generator. f is called with two values, the\n     * value yielded by this generator and a sequential index.\n     * @param f\n     * @typeParam T the type of value produced by the generator.\n     */\n    forEach<T>(f: IndexedFn<T, undefined, Async>):\n        <TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>, thisArg?: any) =>\n            Promise<undefined>;\n\n    forEach<T, TReturn = T, TNext = T>(\n        f: IndexedFn<T, undefined, Async>,\n        thisArgOrGen?: Genable<T, Async, TReturn, TNext>|any,\n        gen?: Genable<T, Async, TReturn, TNext>\n        ): Promise<undefined>\n            | (<XReturn = TReturn, XNext = TNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n                                                Promise<undefined>)\n    {\n        const forEach = async <XReturn, XNext>(\n                                f: IndexedFn<T, XReturn, Async>,\n                                thisArg: any,\n                                gen: Genable<T, Async, XReturn, XNext>\n                            ): Promise<undefined> =>\n            {\n                const it = toAsyncIterator(gen);\n                let idx = 0;\n                while (true) {\n                    const r = await it.next();\n                    if (r.done) return;\n                    await f.call(thisArg, r.value, idx++);\n                }\n            };\n        if (gen) return forEach(f, thisArgOrGen, gen!);\n        if (isAsyncGenable<T, TReturn, TNext>(thisArgOrGen)) return forEach(f, undefined, thisArgOrGen);\n        return <XReturn = T, XNext = T>(gen: Genable<T, Async, XReturn, XNext>, thisArg?: any) =>\n            forEach(f, thisArg ?? thisArgOrGen, gen);\n    }\n\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Async>):\n            GenOpValue<Async, T, V>;\n\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Async>, thisArg?: any):\n            GenOpValue<Async, T, V>;\n\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Async>, gen: Genable<T, Async, TReturn, TNext>):\n            Enhanced<V, Async, TReturn, TNext>;\n\n    map<T, V, TReturn, TNext>(f: IndexedFn<T, V, Async>, thisArg: any, gen: Genable<T, Async, TReturn, TNext>):\n            Enhanced<V, Async, TReturn, TNext>;\n\n    map<T, V,TReturn, TNext>(\n        f: IndexedFn<T, V, Async>,\n        thisArg?: any | Genable<T, Async, TReturn, TNext>,\n        iter?: Genable<T, Async, TReturn, TNext>\n    ):\n        EnhancedAsyncGenerator<V, TReturn, TNext>\n        | (<XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n                EnhancedAsyncGenerator<V, XReturn, XNext>)\n        | (<XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, thisArg?: any) =>\n                EnhancedAsyncGenerator<V, XReturn, XNext>)\n    {\n        const map = <XReturn = T, XNext = T>(thisArg: any, iter: Genable<T, Async, XReturn, XNext>) => {\n            const gen = toAsyncGenerator(iter);\n            let self: EnhancedAsyncGenerator<V, XReturn, XNext>;\n            async function* map(): AsyncGenerator<V, XReturn, XNext> {\n                let nr: any = undefined;\n                let idx = 0;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = await gen.next(nr);\n                                if (r.done) return r.value;\n                                const v = await f.call(thisArg, await r.value, idx++);\n                                try {\n                                    nr = yield v;\n                                } catch (e) {\n                                    await gen.throw(e);\n                                }\n                            }\n                        } finally {\n                            const x = await gen.return(self?.returning);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (!x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            return self = this.enhance(map());\n        };\n        if (iter) return map(thisArg, iter);\n        if (isAsyncGenable<T, TReturn, TNext>(thisArg)) return map(undefined, thisArg);\n        return <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, genThisArg?: any) =>\n                    map(genThisArg ?? thisArg, gen);\n    }\n\n    /**\n     * Return a function that filters a [[Genable]] and yields a new [[EnhancedGenerator]]\n     * that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @typeParam T the type of value.\n     */\n    filter<T>(f: IndexedPredicate<T, Async>):\n        GenOpValue<Async, T, T>;\n\n    /**\n     * Return a function that filters a [[Genable]] and yields a new [[EnhancedGenerator]]\n     * that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     * @typeParam T the type of value.\n     */\n    filter<T>(f: IndexedPredicate<T, Async>, thisArg: any):\n        GenOpValue<Async, T, T>;\n\n    /**\n     * Return a new [[EnhancedGenerator]] that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param iter a [[Genable|Genable<T>]]\n     * @typeParam T the type of value.\n     */\n    filter<T, TReturn, TNext>(f: IndexedPredicate<T, Async>, iter: Genable<T, Async, TReturn, TNext>):\n        Enhanced<T, Async, TReturn, TNext>;\n\n    /**\n     * Return a new [[EnhancedGenerator]] that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     * @param iter a [[Genable|Genable<T>]]\n     * @typeParam T the type of value.\n     */\n    filter<T, TReturn, TNext>(f: IndexedPredicate<T, Async>, thisArg: any, iter: Genable<T, Async, TReturn, TNext>):\n        Enhanced<T, Async, TReturn, TNext>;\n\n    /**\n     * Return a function that filters a [[Genable]] and yields a new [[EnhancedGenerator]]\n     * that yields only the values that satisfy the predicate _f_.\n     *\n     * f receives the value and a sequential index.\n     * @param f\n     * @param thisArg Optional context to be passed as `this` to the predicate.\n     * @param iter the [[Genable]] to filter.\n     * @typeParam T the type of value.\n     */\n    filter<T, TReturn, TNext>(\n        f: IndexedPredicate<T, Async>,\n        thisArg?: any | Genable<T, Async, TReturn, TNext>,\n        iter?: Genable<T, Async, TReturn, TNext>\n    ):\n        Enhanced<T, Async, TReturn, TNext>\n        | GenOpValue<Async, T, T>\n    {\n        const filter = <XReturn, XNext>(thisArg: any, iter: Genable<T, Async, XReturn, XNext>) => {\n            const gen = toAsyncGenerator<T, XReturn, XNext>(iter);\n            let self: EnhancedAsyncGenerator<T, XReturn, XNext>;\n            async function* filter<V>(f: IndexedPredicate<T, Async>): AsyncGenerator<T, XReturn, XNext> {\n                let nr: any = undefined;\n                let idx = 0;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = await gen.next(nr);\n                                if (r.done) return r.value;\n                                if (await f.call(thisArg, r.value, idx++)) {\n                                    try {\n                                        nr = yield r.value;\n                                    } catch (e) {\n                                        await gen.throw(e);\n                                    }\n                                }\n                            }\n                        } finally {\n                            const x = await gen.return?.(self?.returning);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (!x?.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            return self = this.enhance(filter(f));\n        };\n\n        if (iter) return filter(thisArg, iter);\n        if (isAsyncGenable<T, TReturn, TNext>(thisArg)) return filter(undefined, thisArg);\n        return <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, genThisArg?: any) =>\n            filter<XReturn, XNext>(genThisArg ?? thisArg, gen);\n    }\n\n\n    /**\n     * Flatten the values yielded by the generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param depth\n     */\n    flat<D extends number>(depth: D):\n        <T, TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>) =>\n            Enhanced<FlatGen<T, D>, Async, TReturn, TNext>;\n\n    /**\n     * Flatten the values yielded by the generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param depth\n     * @param gen\n     */\n\n    flat<D extends number, T, TReturn, TNext>(depth: D, gen: Genable<T, Async, TReturn, TNext>):\n        Enhanced<FlatGen<T, D>, Async, TReturn, TNext>;\n\n    /**\n     * Flatten the values yielded by the generator to level _depth_. Produces a generator that yields\n     * the individual values at each level in depth-first order. Any iterable (including Array) or iterator\n     * will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param gen\n     * @param depth default = 1\n     */\n    flat<D extends number, T, TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>, depth?: D):\n        Enhanced<FlatGen<T, D>, Async, TReturn, TNext>;\n\n    flat<D extends number, T, TReturn, TNext>(depth: D|Genable<T, Async, TReturn, TNext>, gen?: Genable<T, Async, TReturn, TNext> | D):\n        Enhanced<FlatGen<T, D>, Async, TReturn, TNext>\n        | (<X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>) =>\n                Enhanced<FlatGen<X, D>, Async, XReturn, XNext>)\n    {\n        const flat = <X, XReturn, XNext>(depth: D, gen: Genable<X, Async, XReturn, XNext>) => {\n            let self: Enhanced<FlatGen<X, D>, Async, XReturn, XNext>;\n            const gens = new Set<AsyncGenerator>();\n            if (isAsyncGenerator(gen)) gens.add(gen);\n\n            async function* flat<D extends number, Y, YReturn, YNext>(it: AsyncIterator<Y, YReturn, YNext>, depth: D): AsyncGenerator<FlatGen<Y, D>, YReturn, YNext> {\n                let nr: any = undefined;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = await it.next(nr);\n                                if (r.done) return r.value;\n                                const v: any = r.value;\n                                if (isAsyncGenerator(v)) {\n                                    gens.add(v);\n                                }\n                                try {\n                                    if (depth > 0 && isAsyncIterator(v)) {\n                                        yield* flat(v, depth - 1);\n                                    } else if (depth > 0 && (isAsyncIterable(v) || isIterable(v))) {\n                                        yield* flat(toAsyncIterator(v), depth - 1)\n                                    } else {\n                                        nr = yield r.value as FlatGen<T, D>;\n                                    }\n                                } catch (e) {\n                                    await it.throw?.(e);\n                                }\n                            }\n                        } finally {\n                            const x = await it.return?.(self?.returning);\n                            if (isAsyncGenerator(it)) gens.delete(it);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (x && !x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                            for (const g of gens) {\n                                await g.return(self?.returning);\n                            }\n                        }\n                    }\n                }\n            }\n\n            return self = this.enhance(flat(toAsyncIterator(gen), depth));\n        }\n        if (typeof depth === 'number') {\n            if (gen) {\n                if (isAsyncGenable(gen)) {\n                    return flat(depth, gen);\n                } else {\n                    throw new TypeError(`Invalid Genable: ${gen}`);\n                }\n            }\n            return <X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>) =>\n                flat(depth, gen);\n        } else if (isAsyncGenable(depth)) {\n            return flat((gen ?? 1) as D, depth);\n        }\n        throw new TypeError(`Illegal arguments to flat()`);\n    }\n\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a function that accepts a generator, and returns another generator that yields the individual value\n     * at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param depth\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T>(f: IndexedFn<T, R, Async>, depth: D):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n            Enhanced<R, Async, XReturn, XNext>;\n\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a function that accepts a generator, and returns another generator that yields the individual value\n     * at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T>(f: IndexedFn<T, R, Async>):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, depth?: D) =>\n            Enhanced<R, Async, XReturn, XNext>;\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a generator that yields the individual values at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param gen\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T, TReturn, TNext>(\n            f: IndexedFn<T, R, Async>,\n            gen: Genable<T, Async, TReturn, TNext>\n    ):\n        Enhanced<R, Async, TReturn, TNext>;\n\n    /**\n     * Flatten the values yielded by applying the function to the values yielded by the generator to level _depth_.\n     * Produces a generator that yields the individual values at each level in depth-first order. Any iterable\n     * (including Array) or iterator will be traversed and its values yielded.\n     *\n     * The return type is currently over-broad\n     * @param f\n     * @param depth\n     * @param gen\n     */\n    flatMap<D extends number, R extends FlatGen<T, D>, T, TReturn, TNext>(\n        f: IndexedFn<T, R, Async>,\n        depth: D,\n        gen: Genable<T, Async, TReturn, TNext>\n    ):\n        Enhanced<R, Async, TReturn, TNext>;\n\n    flatMap<D extends number, R extends FlatGen<T, D>, T, TReturn, TNext>(\n        f: IndexedFn<T, R, Async>,\n        depthOrGen?: D | Genable<T, Async, TReturn, TNext>,\n        gen?: Genable<T, Async, TReturn, TNext>\n    ):\n        Enhanced<R, Async, TReturn, TNext>\n        | (\n            <Y extends FlatGen<T, D>, X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>) =>\n                Enhanced<Y, Async, XReturn, XNext>\n        )\n        | (\n            <Y extends FlatGen<T, D>, X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>, depth?: D) =>\n                Enhanced<Y, Async, XReturn, XNext>\n        )\n    {\n        const flatMap = <X, XReturn, XNext>(depth: D, gen: Genable<X, Async, XReturn, XNext>) => {\n            let self: Enhanced<FlatGen<X, D>, Async, XReturn, XNext>;\n            let idx = 0;\n\n            async function* flatMap<D extends number, Y, YReturn, YNext>(\n                    it: AsyncIterator<Y, YReturn, YNext>, depth: D\n                ):\n                    AsyncGenerator<FlatGen<T, D>, YReturn, YNext>\n                {\n                let nr: any = undefined;\n                while (true) {\n                    // noinspection LoopStatementThatDoesntLoopJS\n                    while (true) {\n                        try {\n                            while (true) {\n                                const r = await it.next(nr);\n                                if (r.done) return r.value;\n                                const v = await f(r.value as FlatGen<T, D>, idx++);\n                                try {\n                                    if (isAsyncIterator<unknown, YReturn, YNext>(v)) {\n                                        if (depth > 1) {\n                                            yield* flatMap(v, depth - 1);\n                                        } else if (depth === 1) {\n                                            const it = toAsyncIterator(v);\n                                            yield* toAsyncGenerator(it);\n                                        } else {\n                                            yield v;\n                                        }\n                                    } else if (isAsyncIterable<unknown, YReturn, YNext>(v) || isIterable<unknown, YReturn, YNext>(v)) {\n                                        if (depth > 1) {\n                                            yield* flatMap(toAsyncIterator(v), depth - 1);\n                                        } else if (depth === 1) {\n                                            yield* toAsyncGenerator(v);\n                                        } else {\n                                            yield v;\n                                        }\n                                    } else {\n                                        nr = yield v;\n                                    }\n                                } catch (e) {\n                                    await it.throw?.(e);\n                                }\n                            }\n                        } finally {\n                            const x = await it.return?.(self?.returning);\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (x && !x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            return self = this.enhance(flatMap(toAsyncIterator(gen), depth));\n        }\n\n        if (isAsyncGenable(gen)) {\n            return flatMap(depthOrGen as D ?? 1 as D, gen);\n        } else if (isAsyncGenable( depthOrGen)) {\n            return flatMap(1 as D, depthOrGen);\n        }\n        return <X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>, depth?: D) =>\n            flatMap(depthOrGen ?? depth ?? 1 as D, gen);\n    }\n\n    /**\n     * Return a new [[EnhancedGenerator]] that only yields the indicated values, skipping _start_ initial values\n     * and continuing until the _end_.\n     * @param start\n     * @param end\n     */\n    slice<T>(start: number, end: number):\n        <X, XReturn, XNext>(iter: Genable<X, Async, XReturn, XNext>) =>\n            Enhanced<X, Async, XReturn, XNext>;\n    /**\n     * Return a new [[EnhancedGenerator]] that only yields the indicated values, skipping _start_ initial values\n     * and continuing until the _end_.\n     * @param start\n     * @param end\n     * @param iter\n     */\n    slice<T, TReturn, TNext>(start: number, end: number, iter: Genable<T, Async, TReturn, TNext>):\n        Enhanced<T, Async, TReturn, TNext>;\n\n    slice<T, TReturn, TNext>(\n        start: number,\n        end: number,\n        iter?: Genable<T, Async, TReturn, TNext>\n    ):\n        Enhanced<T, Async, TReturn | undefined, TNext>\n        | (\n            <X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>) =>\n                Enhanced<X, Async, XReturn | undefined, XNext>\n        )\n    {\n        const slice = <X, XReturn, XNext>(iter: Genable<X, Async, XReturn, XNext>):\n            Enhanced<X, Async, XReturn | undefined, XNext> =>\n        {\n            const it = toAsyncIterator(iter);\n            async function* slice(start: number, end: number) {\n                for (let i = 0; i < start; i++) {\n                    const r = await it.next();\n                    if (r.done) return r.value;\n                }\n                if (end === Number.POSITIVE_INFINITY) {\n                    yield* toAsyncIterable(it);\n                } else {\n                    let nv: XNext;\n                    while (true) {\n                        try {\n                            for (let i = start; i < end; i++) {\n                                const r = await it.next(nv!);\n                                if (r.done) return r.value;\n                                try {\n                                    nv = yield r.value;\n                                } catch (e) {\n                                    const re = await it.throw?.(e);\n                                    if (re) {\n                                        if (re.done) return re.value;\n                                        nv = yield re.value;\n                                    }\n                                }\n                            }\n                        } finally {\n                            const x = await it.return?.();\n                            // If the wrapped generator aborted the return, we will, too.\n                            if (x && !x.done) {\n                                // noinspection ContinueOrBreakFromFinallyBlockJS\n                                break;\n                            }\n                        }\n                    }\n                }\n                return;\n            }\n            return this.enhance(slice(start, end));\n        };\n        if (!iter) return slice;\n        return slice(iter);\n    }\n\n    /**\n     * Concatenates generators (or iterators or iterables).\n     *\n     * Ensures that any supplied generators are terminated when this is terminated.\n     * @param gens zero or more additional [[Genable]] to provide values.\n     */\n    concat<T, TReturn, TNext>(...gens: Array<Genable<T, Async, TReturn, TNext>>):\n        Enhanced<T, Async, TReturn | void, TNext>\n    {\n        let self: Enhanced<T, Async, TReturn | void, TNext>;\n        async function* concat(): AsyncGenerator<T, TReturn | void, TNext> {\n            let i = 0;\n            try {\n                for (; i < gens.length; i++) {\n                    const it = toAsyncIterable(gens[i]);\n                    yield* it;\n                }\n            } finally {\n                // Terminate any remaining generators.\n                for (; i < gens.length; i++) {\n                    const g = gens[i];\n                    if (isAsyncGenerator(g)) {\n                        await g.return(self?.returning);\n                    }\n                }\n            }\n        }\n\n        return self = this.enhance(concat());\n    }\n\n    /**\n     * Reduces **gen** like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     * @param f\n     * @param gen\n     */\n    reduce<A, T, TReturn, TNext>(f: Reducer<A, T, T, Async>, gen: Genable<T, Async, TReturn, TNext>):\n        A;\n\n    /**\n     *\n     * Returns a reducer function that, when applied to a `Generator` **gen**, reduces **gen** like\n     * **Array.prototype.reduce**. The 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     *\n     * @param f\n     */\n    reduce<A, T>(f: Reducer<A, T, T, Async>):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n            A;\n\n    /**\n     *\n     * Returns a reducer function that, when applied to a `Generator` **gen**, reduces **gen** like\n     * `Array.prototype.reduce`. The 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     *\n     * @param f\n     */\n    reduce<A, T>(f: Reducer<A, T, A, Async>):\n        <XReturn, XNext>(init: A, gen: Genable<T, Async, XReturn, XNext>) =>\n            A;\n\n    /**\n     * Reduces **gen** like `Array.prototype.reduce`, but the 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     * @param f\n     * @param init\n     * @param gen\n     */\n    reduce<A, T, TReturn, TNext>(f: Reducer<A, T, A, Async>, init: A, gen: Genable<T, Async, TReturn, TNext>):\n        A;\n\n    /**\n     * Returns a reducer function that, when applied to a `Generator` **gen**, reduces **gen** like\n     * `Array.prototype.reduce`. The 3rd argument to the reducing function (\"array\")\n     * is omitted because there is no array.\n     *\n     * Alternatively, the init value can be supplied along with the generator as a second argument.\n     * @param f\n     * @param init\n     */\n    reduce<A, T>(f: Reducer<A, T, A, Async>, init: A):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n            A;\n\n    reduce<A, T, TReturn, TNext>(\n        f: Reducer<A, T, A | T, Async>,\n        initOrGen?: A | Genable<T, Async, TReturn, TNext>,\n        gen?: Genable<T, Async, TReturn, TNext>\n    ): A\n        | Promise<A>\n        | (\n            (gen: Genable<T, Async, TReturn, TNext>) =>\n                A | Promise<A>\n        )\n        | (\n            (f: (acc: A, v: T) => A, init: A) =>\n                A | Promise<A>\n        )\n        | (\n            (f: (acc: A | T, v: T) => A) =>\n                A | Promise<A>\n        )\n    {\n\n        const reduce = async <XReturn, XNext>(init: A | PromiseLike<A> | undefined, it: AsyncIterator<T, XReturn, XNext>):\n            Promise<A> =>\n        {\n            let acc: A | T | undefined = await init;\n            if (acc === undefined) {\n                const r = await it.next();\n                if (r.done) throw new TypeError(`No initial value in reduce`);\n                acc = r.value;\n            }\n            while (true) {\n                const r = await it.next();\n                if (r.done) return acc as A;\n                acc = await f(acc, r.value);\n            }\n        };\n        if (isAsyncGenable(gen)) {\n            return reduce(initOrGen as A, toAsyncIterator(gen));\n        } else if (isAsyncGenable(initOrGen)) {\n            return reduce(undefined, toAsyncIterator(initOrGen));\n        }\n        return (gen: Genable<T, Async, TReturn, TNext>, init?: A) =>\n            reduce(init ?? initOrGen, toAsyncIterator(gen));\n    }\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    some<T, TReturn, TNext>(p: IndexedPredicate<T, Async>, thisArg?: any):\n        (gen: Genable<T, Async, TReturn, TNext>) =>\n            ReturnValue<boolean, Async>;\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     */\n    some<T>(p: IndexedPredicate<T, Async>):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, thisArg?: any) =>\n            ReturnValue<boolean, Async>;\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param gen the generator\n     */\n    some<T, TReturn, TNext>(p: IndexedPredicate<T, Async>, gen: Genable<T, Async, TReturn, TNext>):\n        ReturnValue<boolean, Async>;\n\n    /**\n     * Returns `true` and terminates the generator if the predicate is true for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having satisfied the predicate, `false` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     * @param gen the generator\n     */\n    some<T, TReturn, TNext>(p: IndexedPredicate<T, Async>, thisArg: any, gen: Genable<T, Async, TReturn, TNext>):\n        ReturnValue<boolean, Async>;\n\n    some<T, TReturn, TNext>(\n        pred: IndexedPredicate<T, Async>,\n        thisOrGen?: any | Genable<T, Async, TReturn, TNext>,\n        gen?: Genable<T, Async, TReturn, TNext>\n    ):\n        ReturnValue<boolean, Async>\n        | (\n            (gen: Genable<T, Async, TReturn, TNext>) =>\n                ReturnValue<boolean, Async>\n        )\n    {\n        const some = async <XReturn, XNext>(thisArg: any, it: AsyncIterator<T, XReturn, XNext>): Promise<boolean> => {\n            let i = 0;\n            while (true) {\n                const r = await it.next();\n                if (r.done) return false;\n                if (pred.call(thisArg, r.value, i++)) return true;\n            }\n        };\n        if (isAsyncGenable(gen)) {\n            return some(thisOrGen, toAsyncIterator(gen));\n        } else if (isAsyncGenable(gen)) {\n            return (gen: Genable<T, Async, TReturn, TNext>, thisArg?: any) =>\n                some(thisArg ?? thisOrGen, toAsyncIterator(gen));\n        }\n        throw new Error(`Invalid argument to some: ${gen ?? thisOrGen}`);\n    }\n\n\n    /**\n     * Returns `false` and terminates the generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     */\n    every<T>(p: IndexedPredicate<T, Async>, thisArg?: any):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n            ReturnValue<boolean, Async>;\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     */\n    every<T>(p: IndexedPredicate<T, Async>):\n        <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, thisArg?: any) =>\n            ReturnValue<boolean, Async>;\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param gen the generator\n     */\n    every<T, TReturn, TNext>(p: IndexedPredicate<T, Async>, gen: Genable<T, Async,TReturn, TNext>):\n        ReturnValue<boolean, Async>;\n\n    /**\n     * Returns `false` and terminates this generator if the predicate is false for any of the generator's\n     * yielded values.\n     *\n     * If the generator terminates without having failed the predicate, `true` is returned.\n     * @param p predicate to apply to each yielded value.\n     * @param thisArg Optional value to supply as context (`this`) for the predicate\n     * @param gen the generator\n     */\n    every<T, TReturn, TNext>(p: IndexedPredicate<T, Async>, thisArg: any, gen: Genable<T, Async, TReturn, TNext>):\n        ReturnValue<boolean, Async>;\n\n    every<T, TReturn, TNext>(\n        pred: IndexedPredicate<T, Async>,\n        genOrThis?: any | Genable<T, Async, TReturn, TNext>,\n        gen?: Genable<T, Async, TReturn, TNext>\n    ):\n        ReturnValue<boolean, Async>\n        | (\n            <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>) =>\n                ReturnValue<boolean, Async>\n        )\n    {\n        const every = async <XReturn, XNext>(thisArg: any, it: AsyncIterator<T, XReturn, XNext>):\n            Promise<boolean> =>\n        {\n            let i = 0;\n            while (true) {\n                const r = await it.next();\n                if (r.done) return true;\n                if (!pred.call(thisArg, r.value, i++)) return false;\n            }\n        };\n        if (isAsyncGenable(gen)) {\n            return every(genOrThis, toAsyncIterator(gen));\n        } else if (isGenable(gen)) {\n            return <XReturn, XNext>(gen: Genable<T, Async, XReturn, XNext>, thisArg?: any) =>\n                every(thisArg ?? genOrThis, toAsyncIterator(gen));\n        }\n        throw new Error(`Invalid argument to every: ${gen ?? genOrThis}`);\n    }\n\n    /**\n     * Returns a new generator that repeats the last value returned by **gen** (or `undefined` if **gen**\n     * did not return any values).\n     *\n     * @param gen\n     * @param max\n     */\n    repeatLast<T, TReturn, TNext>(\n        gen: Genable<T, Async, TReturn, TNext>,\n        max: number = Number.POSITIVE_INFINITY\n    ):\n        Enhanced<T, Async, TReturn | undefined, TNext>\n    {\n        const it = toAsyncIterator(gen);\n        let nr: TNext;\n        let self: Enhanced<T, Async, TReturn | undefined, TNext>;\n\n        async function* repeatLast(): AsyncGenerator<T, TReturn | undefined, TNext> {\n            try {\n                let last: T;\n                while (true) {\n                    const r = await it.next(nr as unknown as TNext)\n                    if (r.done) break;\n                    try {\n                        nr = yield (last = r.value);\n                    } catch (e) {\n                        const re = await it.throw?.(e);\n                        if (re) {\n                            if (re.done) break;\n                            yield last = re.value;\n                        }\n                    }\n                }\n                for (let i = 0; i < max; i++) {\n                    // Important to await at the expected point for consistent behavior.\n                    yield await last!;\n                }\n            } finally {\n                await it.return?.(self?.returning);\n            }\n            return;\n        }\n\n        return self = this.enhance(repeatLast());\n    }\n\n\n    /**\n     * Returns a new generator that repeats the supplied value.\n     *\n     * @param value the value to repeat\n     * @param repetitions The number repetitions; the default is infinite.\n     */\n    repeat<T, TNext>(value: T, repetitions: number = Number.POSITIVE_INFINITY):\n        Enhanced<T, Async, void, TNext>\n    {\n        async function* repeat(): AsyncGenerator<T, void, TNext> {\n            for (let i = 0; i < repetitions; i++) {\n                // Important to await at the expected point for consistent behavior.\n                yield await value;\n            }\n        }\n\n        return this.enhance(repeat());\n    }\n\n    /**\n     * Combines generators, returning a generator that produces a tuple with each of their results.\n     *\n     * Terminates when the first generator terminates. To get other behaviors, use with [[EnhancedGenerator.repeat]] or\n     * [[EnhancedGenerator.repeatLast]].\n     * @param gens\n     */\n    zip<T, TReturn, TNext>(...gens: Array<Genable<T, Async, TReturn, TNext>>):\n        Enhanced<Array<T>, Async, TReturn, TNext>\n    {\n        if (gens.length === 0) return this.enhance([]);\n        const its = gens.map(toAsyncIterator);\n        let done = false;\n        let self: Enhanced<Array<T>, Async, TReturn, TNext>;\n\n        async function* zip2(): AsyncGenerator<Array<T>, TReturn, TNext> {\n            try {\n                while (true) {\n                    let result: Array<T> = [];\n                    for (const g of its) {\n                        const r = await g.next();\n                        if (r.done) {\n                            done = true;\n                            return r.value;\n                        }\n                        (result as any[]).push(r.value);\n                    }\n                    try {\n                        yield result;\n                    } catch (e) {\n                        for (const g of gens) {\n                            try {\n                                // Weird need for a typecast here.\n                                await (g as any).throw?.(e);\n                            } catch {\n                                // Ignore\n                            }\n                        }\n                        throw e;\n                    }\n                }\n            } finally {\n                if (!done) {\n                    for (const g of gens) {\n                        try {\n                            // Weird need for a typecast here.\n                            await (g as any).return?.(self?.returning);\n                        } catch {\n                            // Ignore\n                        }\n                    }\n                }\n            }\n        }\n\n        return self = this.enhance(zip2());\n    }\n\n\n    /**\n     * Returns a function that joins the elements produced by a [[Genable]], analogous to `Array.prototype.join`.\n     * @param sep (default = ',')\n     */\n    join(sep: string):\n        <T, TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>) =>\n            ReturnValue<string, Async>;\n\n    /**\n     * Joins the elements produced by a [[Genable]], analogous to `Array.prototype.join`.\n     * @param gen\n     * @param sep\n     */\n    join<T, TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>, sep?: string):\n        ReturnValue<string, Async>;\n\n    join<T, TReturn, TNext>(\n        genOrSeparator: Genable<T, Async, TReturn, TNext>|string,\n        sep?: string\n    ):\n        ReturnValue<string, Async>\n        | (\n            <X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>) =>\n                ReturnValue<string, Async>\n        )\n    {\n        if (typeof genOrSeparator === 'string') {\n            sep = genOrSeparator;\n            return <X, XReturn, XNext>(gen: Genable<X, Async, XReturn, XNext>) =>\n                this.join(gen, sep);\n        }\n        return Promise.resolve(this.enhance(genOrSeparator).asArray())\n            .then(a => a.join(sep));\n    }\n\n    /**\n     * Returns a new generator that returns values from each of the supplied sources as they are available.\n     * Values will be taken as they become available from any source.\n     * The yielded values will not be distinguished by which which source they are taken; for\n     * that, another method will be supplied.\n     *\n     * Any calls to `Generator.throw()` or `Generator.return()` will be passed to all non-terminated\n     * sources.\n     * @param sources\n     */\n    merge<T, TReturn, TNext>(...sources: Array<Genable<T, Async, TReturn, TNext>>):\n        Enhanced<T, Async, TReturn | void, TNext>\n    {\n        let self: Enhanced<T, Async, void | TReturn, TNext>;\n        let done: (r: IteratorReturnResult<TReturn>) => void;\n        const donePromise = new Promise<IteratorReturnResult<TReturn>>(r => (done = r));\n        let activeCount = sources.length;\n        let active: Array<Promise<() => (IteratorResult<T, TReturn> | null)> | Promise<IteratorReturnResult<TReturn>>>;\n        const dead = new Promise<() => (IteratorResult<T, TReturn> | null)>(() => null); // Never completes\n        let gens: Array<AsyncIterator<T, TReturn, TNext>> = [];\n        const wrap = async (g: Genable<T, Async, TReturn, TNext>, k: number) => {\n            const ag = toAsyncIterator(g);\n            gens[k] = ag;\n            const handle = async (val: IteratorResult<T, TReturn>): Promise<() => (IteratorResult<T, TReturn> | null)> =>\n                () => {\n                    if (val.done) {\n                        active[k] = dead;\n                        // Unless this is the last active generator, we return null to indicate\n                        // to the loop to go on to the next one.\n                        return --activeCount > 0\n                            ? null\n                            : (done(val), val);\n                    } else {\n                        const v = ag.next().then(handle);\n                        active[k] = v;\n                        return val;\n                    }\n                };\n            return (await ag.next().then(handle));\n        };\n        active = [...sources.map(wrap), donePromise];\n        async function* merge(): AsyncGenerator<T, TReturn | void, TNext> {\n            try {\n                let nv: TNext;\n                while (activeCount) {\n                    const race: Array<Promise<() => (IteratorResult<T, TReturn> | null)> | Promise<IteratorReturnResult<TReturn>>> = [];\n                    active.forEach(a => race.push(a))\n                    const result = await (await Promise.race(race));\n                    if (typeof result === 'function') {\n                        let r = result();\n                        if (r) {\n                            if (r.done) {\n                                return r.value;\n                            }\n                            nv = (yield r.value);\n                        }\n                    } else if (result && result.done) {\n                        return result.value;\n                    }\n                }\n            } finally {\n                if (activeCount) {\n                    for (let i = 0; i < sources.length; i++) {\n                        (active[i] === null ? null : gens[i])?.return?.(self?.returning);\n                    }\n                }\n            }\n        }\n        return self = Async.enhance(merge());\n    }\n\n    /**\n     * Returns a function that sorts the supplied sources and returns a sorted array.\n     * @param cmp a comparison function\n     */\n    sort<T>(cmp?: ((a: T, b: T) => number)) {\n        return async <TReturn, TNext>(...sources: Array<Genable<T, Async, TReturn, TNext>>) => {\n            const array: T[] = await this.merge(...sources).asArray();\n            return array.sort(cmp);\n        };\n    }\n\n    /**\n     * Enhance an existing generator (or iterator or iterable) to be a EnhancedGenerator.\n     * @param gen\n     */\n    enhance<T, TReturn, TNext>(gen: Genable<T, Async, TReturn, TNext>):\n        EnhancedAsyncGenerator<T, TReturn, TNext>\n    {\n        const gen2 = toAsyncGenerator(gen)as\n            unknown as Partial<EnhancedAsyncGenerator<T, TReturn, TNext>>;\n        const old = Object.getPrototypeOf(gen2);\n        const proto = Object.assign(Object.create(EnhancedAsyncGenerator.prototype), old);\n        proto.return = (v: any) => ((gen2 as any).returning = v, old.return.call(gen2, v));\n        proto[Symbol.asyncIterator] = () => gen2;\n        Object.setPrototypeOf(gen2, proto);\n        return gen2 as EnhancedAsyncGenerator<T, TReturn, TNext>;\n    }\n}\n\n/**\n * Factory for synchronous generator operators. See [[GeneratorOps]] for details.\n */\nconst Async: GeneratorOps<Async> = new Async_();\nexport {Async};\n\nexport abstract class EnhancedAsyncGenerator<T, TReturn, TNext>\n    extends Enhancements<T, TReturn, TNext, Async>\n    implements AsyncGenerator<T, TReturn, TNext>,\n        AsyncIterable<T>,\n        AsyncIterator<T, TReturn, TNext>\n{\n}\n\nconst makeProto = (base: any) => {\n    const newProto = Object.create(base);\n    const inherit = (proto: any) => {\n        for (const k of Reflect.ownKeys(proto)) {\n            if (k !== 'constructor') {\n                newProto[k] = proto[k];\n            }\n        }\n    };\n    inherit(Enhancements.prototype);\n    return newProto;\n}\n\n/**\n * @internal\n * @constructor\n */\nasync function* AsyncFoo() {\n}\n\n/**\n * @internal\n */\nexport const AsyncGenProto = Object.getPrototypeOf(AsyncFoo());\n\n// Make EnhancedGenerator inherit generator methods.\n\nObject.setPrototypeOf(EnhancedAsyncGenerator.prototype, makeProto(AsyncGenProto));\nObject.defineProperty(EnhancedAsyncGenerator.prototype, '_impl', {\n    value: Async,\n    writable: false,\n    enumerable: false,\n    configurable: false\n});\n","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n\n/**\n * This entry point loads synchronous and asynchronous extended generators\n * @packageDocumentation\n * @module generators\n * @preferred\n */\n\nexport type {SyncType} from './types';\nimport {Sync as SyncFoo} from './sync';\nimport {Async as AsyncFoo} from './async';\n\n/**\n * Factory for synchronous generator operators. See [[GeneratorOps]] for details.\n */\nconst Sync = SyncFoo;\n/**\n * Selector type to select the types for synchronous generators.\n */\ntype Sync = 'sync';\n\n/**\n * Factory for asynchronous generator operators. See [[GeneratorOps]] for details.\n */\nconst Async = AsyncFoo;\n/**\n * Selector type to select the types for ssynchronous generators.\n */\ntype Async = 'async';\nexport {Sync, Async};\n","'use strict';\n\n/**\n * Custom implementation of a double ended queue.\n */\nfunction Denque(array, options) {\n  var options = options || {};\n\n  this._head = 0;\n  this._tail = 0;\n  this._capacity = options.capacity;\n  this._capacityMask = 0x3;\n  this._list = new Array(4);\n  if (Array.isArray(array)) {\n    this._fromArray(array);\n  }\n}\n\n/**\n * -------------\n *  PUBLIC API\n * -------------\n */\n\n/**\n * Returns the item at the specified index from the list.\n * 0 is the first element, 1 is the second, and so on...\n * Elements at negative values are that many from the end: -1 is one before the end\n * (the last element), -2 is two before the end (one before last), etc.\n * @param index\n * @returns {*}\n */\nDenque.prototype.peekAt = function peekAt(index) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  var len = this.size();\n  if (i >= len || i < -len) return undefined;\n  if (i < 0) i += len;\n  i = (this._head + i) & this._capacityMask;\n  return this._list[i];\n};\n\n/**\n * Alias for peekAt()\n * @param i\n * @returns {*}\n */\nDenque.prototype.get = function get(i) {\n  return this.peekAt(i);\n};\n\n/**\n * Returns the first item in the list without removing it.\n * @returns {*}\n */\nDenque.prototype.peek = function peek() {\n  if (this._head === this._tail) return undefined;\n  return this._list[this._head];\n};\n\n/**\n * Alias for peek()\n * @returns {*}\n */\nDenque.prototype.peekFront = function peekFront() {\n  return this.peek();\n};\n\n/**\n * Returns the item that is at the back of the queue without removing it.\n * Uses peekAt(-1)\n */\nDenque.prototype.peekBack = function peekBack() {\n  return this.peekAt(-1);\n};\n\n/**\n * Returns the current length of the queue\n * @return {Number}\n */\nObject.defineProperty(Denque.prototype, 'length', {\n  get: function length() {\n    return this.size();\n  }\n});\n\n/**\n * Return the number of items on the list, or 0 if empty.\n * @returns {number}\n */\nDenque.prototype.size = function size() {\n  if (this._head === this._tail) return 0;\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Add an item at the beginning of the list.\n * @param item\n */\nDenque.prototype.unshift = function unshift(item) {\n  if (item === undefined) return this.size();\n  var len = this._list.length;\n  this._head = (this._head - 1 + len) & this._capacityMask;\n  this._list[this._head] = item;\n  if (this._tail === this._head) this._growArray();\n  if (this._capacity && this.size() > this._capacity) this.pop();\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Remove and return the first item on the list,\n * Returns undefined if the list is empty.\n * @returns {*}\n */\nDenque.prototype.shift = function shift() {\n  var head = this._head;\n  if (head === this._tail) return undefined;\n  var item = this._list[head];\n  this._list[head] = undefined;\n  this._head = (head + 1) & this._capacityMask;\n  if (head < 2 && this._tail > 10000 && this._tail <= this._list.length >>> 2) this._shrinkArray();\n  return item;\n};\n\n/**\n * Add an item to the bottom of the list.\n * @param item\n */\nDenque.prototype.push = function push(item) {\n  if (item === undefined) return this.size();\n  var tail = this._tail;\n  this._list[tail] = item;\n  this._tail = (tail + 1) & this._capacityMask;\n  if (this._tail === this._head) {\n    this._growArray();\n  }\n  if (this._capacity && this.size() > this._capacity) {\n    this.shift();\n  }\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Remove and return the last item on the list.\n * Returns undefined if the list is empty.\n * @returns {*}\n */\nDenque.prototype.pop = function pop() {\n  var tail = this._tail;\n  if (tail === this._head) return undefined;\n  var len = this._list.length;\n  this._tail = (tail - 1 + len) & this._capacityMask;\n  var item = this._list[this._tail];\n  this._list[this._tail] = undefined;\n  if (this._head < 2 && tail > 10000 && tail <= len >>> 2) this._shrinkArray();\n  return item;\n};\n\n/**\n * Remove and return the item at the specified index from the list.\n * Returns undefined if the list is empty.\n * @param index\n * @returns {*}\n */\nDenque.prototype.removeOne = function removeOne(index) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  if (this._head === this._tail) return void 0;\n  var size = this.size();\n  var len = this._list.length;\n  if (i >= size || i < -size) return void 0;\n  if (i < 0) i += size;\n  i = (this._head + i) & this._capacityMask;\n  var item = this._list[i];\n  var k;\n  if (index < size / 2) {\n    for (k = index; k > 0; k--) {\n      this._list[i] = this._list[i = (i - 1 + len) & this._capacityMask];\n    }\n    this._list[i] = void 0;\n    this._head = (this._head + 1 + len) & this._capacityMask;\n  } else {\n    for (k = size - 1 - index; k > 0; k--) {\n      this._list[i] = this._list[i = ( i + 1 + len) & this._capacityMask];\n    }\n    this._list[i] = void 0;\n    this._tail = (this._tail - 1 + len) & this._capacityMask;\n  }\n  return item;\n};\n\n/**\n * Remove number of items from the specified index from the list.\n * Returns array of removed items.\n * Returns undefined if the list is empty.\n * @param index\n * @param count\n * @returns {array}\n */\nDenque.prototype.remove = function remove(index, count) {\n  var i = index;\n  var removed;\n  var del_count = count;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  if (this._head === this._tail) return void 0;\n  var size = this.size();\n  var len = this._list.length;\n  if (i >= size || i < -size || count < 1) return void 0;\n  if (i < 0) i += size;\n  if (count === 1 || !count) {\n    removed = new Array(1);\n    removed[0] = this.removeOne(i);\n    return removed;\n  }\n  if (i === 0 && i + count >= size) {\n    removed = this.toArray();\n    this.clear();\n    return removed;\n  }\n  if (i + count > size) count = size - i;\n  var k;\n  removed = new Array(count);\n  for (k = 0; k < count; k++) {\n    removed[k] = this._list[(this._head + i + k) & this._capacityMask];\n  }\n  i = (this._head + i) & this._capacityMask;\n  if (index + count === size) {\n    this._tail = (this._tail - count + len) & this._capacityMask;\n    for (k = count; k > 0; k--) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n    }\n    return removed;\n  }\n  if (index === 0) {\n    this._head = (this._head + count + len) & this._capacityMask;\n    for (k = count - 1; k > 0; k--) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n    }\n    return removed;\n  }\n  if (i < size / 2) {\n    this._head = (this._head + index + count + len) & this._capacityMask;\n    for (k = index; k > 0; k--) {\n      this.unshift(this._list[i = (i - 1 + len) & this._capacityMask]);\n    }\n    i = (this._head - 1 + len) & this._capacityMask;\n    while (del_count > 0) {\n      this._list[i = (i - 1 + len) & this._capacityMask] = void 0;\n      del_count--;\n    }\n    if (index < 0) this._tail = i;\n  } else {\n    this._tail = i;\n    i = (i + count + len) & this._capacityMask;\n    for (k = size - (count + index); k > 0; k--) {\n      this.push(this._list[i++]);\n    }\n    i = this._tail;\n    while (del_count > 0) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n      del_count--;\n    }\n  }\n  if (this._head < 2 && this._tail > 10000 && this._tail <= len >>> 2) this._shrinkArray();\n  return removed;\n};\n\n/**\n * Native splice implementation.\n * Remove number of items from the specified index from the list and/or add new elements.\n * Returns array of removed items or empty array if count == 0.\n * Returns undefined if the list is empty.\n *\n * @param index\n * @param count\n * @param {...*} [elements]\n * @returns {array}\n */\nDenque.prototype.splice = function splice(index, count) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  var size = this.size();\n  if (i < 0) i += size;\n  if (i > size) return void 0;\n  if (arguments.length > 2) {\n    var k;\n    var temp;\n    var removed;\n    var arg_len = arguments.length;\n    var len = this._list.length;\n    var arguments_index = 2;\n    if (!size || i < size / 2) {\n      temp = new Array(i);\n      for (k = 0; k < i; k++) {\n        temp[k] = this._list[(this._head + k) & this._capacityMask];\n      }\n      if (count === 0) {\n        removed = [];\n        if (i > 0) {\n          this._head = (this._head + i + len) & this._capacityMask;\n        }\n      } else {\n        removed = this.remove(i, count);\n        this._head = (this._head + i + len) & this._capacityMask;\n      }\n      while (arg_len > arguments_index) {\n        this.unshift(arguments[--arg_len]);\n      }\n      for (k = i; k > 0; k--) {\n        this.unshift(temp[k - 1]);\n      }\n    } else {\n      temp = new Array(size - (i + count));\n      var leng = temp.length;\n      for (k = 0; k < leng; k++) {\n        temp[k] = this._list[(this._head + i + count + k) & this._capacityMask];\n      }\n      if (count === 0) {\n        removed = [];\n        if (i != size) {\n          this._tail = (this._head + i + len) & this._capacityMask;\n        }\n      } else {\n        removed = this.remove(i, count);\n        this._tail = (this._tail - leng + len) & this._capacityMask;\n      }\n      while (arguments_index < arg_len) {\n        this.push(arguments[arguments_index++]);\n      }\n      for (k = 0; k < leng; k++) {\n        this.push(temp[k]);\n      }\n    }\n    return removed;\n  } else {\n    return this.remove(i, count);\n  }\n};\n\n/**\n * Soft clear - does not reset capacity.\n */\nDenque.prototype.clear = function clear() {\n  this._head = 0;\n  this._tail = 0;\n};\n\n/**\n * Returns true or false whether the list is empty.\n * @returns {boolean}\n */\nDenque.prototype.isEmpty = function isEmpty() {\n  return this._head === this._tail;\n};\n\n/**\n * Returns an array of all queue items.\n * @returns {Array}\n */\nDenque.prototype.toArray = function toArray() {\n  return this._copyArray(false);\n};\n\n/**\n * -------------\n *   INTERNALS\n * -------------\n */\n\n/**\n * Fills the queue with items from an array\n * For use in the constructor\n * @param array\n * @private\n */\nDenque.prototype._fromArray = function _fromArray(array) {\n  for (var i = 0; i < array.length; i++) this.push(array[i]);\n};\n\n/**\n *\n * @param fullCopy\n * @returns {Array}\n * @private\n */\nDenque.prototype._copyArray = function _copyArray(fullCopy) {\n  var newArray = [];\n  var list = this._list;\n  var len = list.length;\n  var i;\n  if (fullCopy || this._head > this._tail) {\n    for (i = this._head; i < len; i++) newArray.push(list[i]);\n    for (i = 0; i < this._tail; i++) newArray.push(list[i]);\n  } else {\n    for (i = this._head; i < this._tail; i++) newArray.push(list[i]);\n  }\n  return newArray;\n};\n\n/**\n * Grows the internal list array.\n * @private\n */\nDenque.prototype._growArray = function _growArray() {\n  if (this._head) {\n    // copy existing data, head to end, then beginning to tail.\n    this._list = this._copyArray(true);\n    this._head = 0;\n  }\n\n  // head is at 0 and array is now full, safe to extend\n  this._tail = this._list.length;\n\n  this._list.length *= 2;\n  this._capacityMask = (this._capacityMask << 1) | 1;\n};\n\n/**\n * Shrinks the internal list array.\n * @private\n */\nDenque.prototype._shrinkArray = function _shrinkArray() {\n  this._list.length >>>= 1;\n  this._capacityMask >>>= 1;\n};\n\n\nmodule.exports = Denque;\n","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * Turn events/imperative calls into values returned by an async generator.\n * @module events\n * @packageDocumentation\n * @preferred\n */\n\nimport Denque from 'denque';\n\n/**\n * Interface for controlling the generators returned by {@link eventToGenerator}.\n */\nexport interface Controller<T, E = T | any> {\n    /**\n     * Queue _v_ to the generator.\n     * @param v\n     */\n    send(v: T): void,\n\n    /**\n     * Queue _e_ (optional) to be returned by the generator, ending it.\n     * @param e\n     */\n    end(e?: E): void,\n\n    /**\n     * Queue an error to be thrown by the generator, ending it.\n     * @param err\n     */\n    throw(err: Error): void;\n\n    /**\n     * Clear all pending values queued to the generator.\n     */\n    clear(): void;\n}\n\nconst endTag = Symbol.for(\"endTag\");\nconst returnMsg = {[endTag]: 'return'};\nconst throwMsg = {[endTag]: 'throw'};\ntype ReturnMsg<R> = typeof returnMsg & {value: R};\ntype ThrowMsg = typeof throwMsg & {value: Error};\ntype EndMsg<R> = ReturnMsg<R> | ThrowMsg;\nconst isReturnMsg = <R>(m: any): m is ReturnMsg<R> => m instanceof Object && (m[endTag] === 'return');\nconst isThrowMsg = (m: any): m is ThrowMsg => m instanceof Object && (m[endTag] === 'throw');\n\n/**\n * A queue usable by {@link eventToGenerator}.\n */\nexport interface Queue<T extends any> {\n    length: number;\n    push(value: T): number;\n    shift(): T | undefined;\n    clear(): void;\n}\n\n/**\n * A factory function that returns a {@link Queue}. It will be called with no arguments.\n */\nexport type QueueFactory<T> = () => Queue<T>;\n\n/**\n * async generator function `eventToGenerator`(_queue_) returns _[generator, controller]_\n *\n * Create a generator that can be made to return values to be supplied by a callback.\n * * _queue_: A {@link QueueFactory} function that returns the {@link Queue} to use.\n * * _generator_: The generator being controlled.\n * * _controller_: A {@link Controller} object with the following:\n * >   * `send(`_value_`)`: send the next value to generate.\n * >   * `end()`: Cause the generator to end\n * >   * `throw(`_error_`)`: Cause the generator to throw an exception.\n * >   * `clear()`: Remove any pending queue items.\n *\n * `end` and `throw` are synchronous with the queue. That is, they cause the queue to end or throw\n * when the consumer of the generator has read everything prior in the queue.\n *\n * _queue_ should return a {@link Queue} object that implements `.length`, `.push()`, `.shift()`, and `.clear()`.\n * The default implementation is [Denque](https://github.com/invertase/denque), which is fast for unbounded size.\n *\n * The returned generator may be enhanced with {@link Async_.enhance|Async.enhance} if desired.\n *\n * Other {@link QueueFactory} functions provided:\n * * {@link queue1}: returns a \"queue\" of maximum length 1. Older entries are discarded.\n * * {@link queueSticky}`: Returns a queue that returns the last value seen, forever (or until cleared).\n * * {@link queueOldest}_(n)_: Call with _n_ to set the size; when full new values are discarded.\n * * {@link queueNewest}_(n)_: Call with _n_ to set the size; when full old values are discarded.\n * * {@link queueUnique}: Returns a queue that discards duplicate enqueued values.\n * @returns [AsyncGenerator, {@link Controller}]\n */\nexport const eventToGenerator = <T, R = void>(queue: QueueFactory<T | EndMsg<R>> = () => new Denque()): [AsyncGenerator<T, R>, Controller<T>] => {\n    let unblock: (v?: any) => void = () => undefined;\n    let waiter = null;\n    const q = queue();\n    const send = (v?: any) => (q.push(v), unblock());\n    class EventController implements Controller<T> {\n        send(v?: T) {\n            return send(v);\n        }\n        end(value?: T) {\n           return send({[endTag]: 'return', value})\n        }\n        throw(value: Error) {\n            return send({ [endTag]: 'throw', value });\n        }\n        clear() { return q.clear(); }\n    }\n    async function* eventToGenerator(): AsyncGenerator<T, R> {\n        while (true) {\n            while (!q.length) {\n                waiter = new Promise(a => (unblock = a));\n                await waiter;\n                waiter = null;\n                unblock = () => undefined;\n            }\n            const v = q.shift();\n            if (isReturnMsg<R>(v)) return v.value;\n            if (isThrowMsg(v)) {\n                throw v.value;\n            }\n            yield v as T;\n        }\n    }\n    return [\n        eventToGenerator(),\n        new EventController()\n    ];\n}\n\n/**\n * A {@link QueueFactory} that returns a {@link Queue} of maximum length 1, which discards older values.\n */\nexport const queue1 = <V>(): Queue<V> => {\n    let value: V | undefined,\n        empty = true;\n    class Queue1 implements Queue<V> {\n        get length() { return empty ? 0 : 1}\n        push(v: V) {\n            empty = false;\n            value = v;\n            return 1;\n        }\n        shift() {\n            empty = true;\n            const tmp = value;\n            value = undefined;\n            return tmp;\n        }\n        clear() {\n            empty = true;\n            value = undefined;\n        }\n    }\n    return new Queue1();\n};\n\n/**\n * A {@link QueueFactory} that returns a {@link Queue} of maximum length 1, which discards older\n * values, but returns the last seen forever (until cleared).\n */\nexport const queueSticky = <V>(): Queue<V> => {\n    let value: V | undefined,\n        empty = true;\n    class QueueSticky implements Queue<V> {\n        get length() { return empty ? 0 : 1}\n        push(v: V) {\n            empty = false;\n            value = v;\n            return 1;\n        }\n        shift() {\n            return value;\n        }\n        clear() {\n            empty = true;\n            value = undefined;\n        }\n    }\n    return new QueueSticky();\n}\n\n/**\n * Make a {@link QueueFactory} that returns a {@link Queue} of maximum length _n_,\n * which discards newer values.\n * @param n the number of entries, default = `1`.\n */\nexport const queueOldest = <V>(n: number = 1): QueueFactory<V> => {\n    return (): Queue<V> => {\n        const queue = new Denque();\n        class QueueOldest implements Queue<V> {\n            get length() { return queue.length};\n            push(v: V) {\n                if (queue.length < n) {\n                    return queue.push(v);\n                }\n                // Otherwise, we let it drop.\n                return queue.length;\n            }\n            shift() { return queue.shift(); }\n            clear() { return queue.clear(); }\n        }\n        return new QueueOldest();\n    };\n};\n\n/**\n * Make a {@link QueueFactory} that returns a {@link Queue} of maximum length _n_, which discards older values.\n * @param n the number of entries, default = `1`.\n */\nexport const queueNewest = <V>(n: number = 1): QueueFactory<V> => {\n    return (): Queue<V> => {\n        const queue = new Denque();\n        class QueueNewest implements Queue<V> {\n            get length() { return queue.length; }\n            push(v: V) {\n                while (queue.length >= n) {\n                    queue.shift();\n                }\n                return queue.push(v);\n            }\n            shift() {\n                return queue.shift();\n            }\n            clear() {\n                return queue.clear();\n            }\n        }\n        return new QueueNewest();\n    };\n};\n\nexport type KeyFn = (k: any) => any;\nexport interface QueueUniqueSpec {\n    newest?: boolean;\n    keyFn?: KeyFn;\n}\n/**\n * function queueUnique({newest, keyFn}): () =>\n *\n * Return a {@link QueueFactory}, which supplies {@link Queue} instances that discard\n * already-enqueued entries. Values can be re-enqueued once delivered.\n * * _newest_: if `false` (the default), values are dequeued in the order they were first enqueued. Using `{newest: true}` deprioritizes more active values so less-busy items can get through. But in a sustained-busy situation, there is no guarantee they will ever be delivered. This can be an advantage or disadvantage, depending on requirements.\n * * _keyFn_: A function to identify what values count as \"equal\". The default regards +0 and -0 as the same, NaN's as all the same, and otherwise behaves as `===`.\n * @param spec a {@link QueueUniqueSpec}\n */\nexport const queueUnique = <E>(spec?: QueueUniqueSpec): QueueFactory<E> => {\n    const fn = (newest: boolean, keyFn: KeyFn) => (): Queue<E> => {\n        const queue = new Map();\n        let iter: null | Iterator<E> = null;\n        class QueueUnique implements Queue<E> {\n            get length() { return queue.size; }\n            push(v: any) {\n                const k = keyFn(v);\n                if (newest) {\n                    // As I read the spec, this should not be needed, but experimentally\n                    // in Chrome, it is.\n                    queue.delete(k);\n                    queue.set(k, v);\n                } else if (!queue.has(k)) {\n                    queue.set(k, v);\n                }\n                return queue.size;\n            }\n            shift() {\n                if (!iter) {\n                    iter = queue.values();\n                }\n                const r = iter.next();\n                if (r.done) {\n                    // If values had been added later, they would turn up\n                    // in the iterator, so we're done.\n                    iter = null;\n                    return undefined;\n                }\n                return r.value;\n            }\n            clear() {\n                return queue.clear();\n            }\n        }\n        return new QueueUnique();\n    };\n    if (spec === undefined) {\n        // Called without specifying a length, just return a size=1 queue.\n        return fn(false, i => i);\n    }\n    // Return a function to construct queues of the specified size.\n    return fn(!!spec.newest, spec.keyFn || (i => i));\n};\n\n/**\n * Accepts objects, and returns just the fields that have changed (are no longer `===`).\n *\n * This does not distinguish between deleted keys and keys assigned a value of `undefined` in the input.\n * In the output, a deleted key is represented as present with a value of `undefined`.\n *\n * @param init The initial value\n */\nexport const queueUpdateShallow = <E extends object>(init: Partial<E> = {}) => (): Queue<Partial<E>> => {\n    const state: Partial<E> = { ...init };\n    let pending: Partial<E> = {};\n    let hasPending = false;\n    class QueueUpdateShallow implements Queue<Partial<E>> {\n        get length() { return (hasPending ? 1 : 0); }\n        push(v: E) {\n            const check = (k: Partial<E>) => (Object.keys(k) as (keyof E)[]).forEach(k => {\n                if (state[k] !== v[k]) {\n                    pending[k] = v[k];\n                    hasPending = true;\n                }\n            });\n            check(state);\n            check(v);\n            return 1;\n        }\n        shift() {\n            try {\n                return pending;\n            } finally {\n                Object.assign(state, pending);\n                this.clear();\n            }\n        }\n        clear() {\n            pending = {};\n            hasPending = false;\n        }\n    }\n    return new QueueUpdateShallow();\n};\n","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * This entry point loads asynchronous extended generators\n * @packageDocumentation\n * @module future\n * @preferred\n */\n\n/**\n * A [[Future]] is a variant of a Promise that takes a function to start execution at a later point, when\n * the value is desired. It can be used to delay a computation, or to avoid it entirely if not needed.\n *\n * By default, the computation begins when the first _onfulfilled_ handler is added with {@link then}, but\n * if the _delay_ parameter is supplied as `true` an explicit call to the {@link eval} method is required.\n */\nexport class Future<T> extends Promise<T> {\n    #fn?: () => T;\n    #delay: boolean;\n\n    #accept?: (val: T) => void;\n    #reject?: (err: Error) => void;\n    #result?: T;\n    #error?: Error;\n    static [Symbol.toStringTag] = 'Future';\n    static [Symbol.species] = Promise;\n\n    /**\n     * Construct a {@link Future}.\n     *\n     * The supplied _fn_ argument will be discarded once run, so any data referenced\n     * by it can be freed by the GC.\n     * @param fn The function performing the future calculation\n     * @param delay true if the calculation should be delayed until an explicit call to `eval`.\n     */\n    constructor(fn: () => T, delay?: boolean) {\n        let accept;\n        let reject;\n        super((acc: (val: T) => void, rej: (err: Error) => void) => {\n            accept = acc;\n            reject = rej;\n        });\n        this.#accept = accept;\n        this.#reject = reject;\n        this.#fn = fn;\n        this.#delay = !!delay;\n    }\n\n    /**\n     * Perform the calculation supplied on construction. Takes arguments like {@link Promise#then}. Any pending\n     * handlers from `Promise.then()`, `Promise.catch()`, or `Promise.finally()` will be also be\n     * handled as normal.\n     *\n     * {@link eval} is run synchronously if the supplied function is synchronous. The result is not wrapped in a `Promise`,\n     * but will be a `Promise` if that's what the supplied function returns. The supplied handlers are _not_ run synchronously.\n     * @param onfulfilled\n     * @param onrejected\n     * @returns\n     */\n    eval<TResult1 = T, TResult2 = never>(\n        onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n        onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n        ):\n        T\n    {\n        if (this.#fn) {\n            try {\n                this.#result = this.#fn();\n                this.#accept?.(this.#result);\n                return this.#result;\n            } catch (e) {\n                this.#error = e;\n                this.#reject?.(e);\n                throw e;\n            } finally {\n                this.#fn = undefined;\n                this.#accept = undefined;\n                this.#reject = undefined;\n                if (onfulfilled || onrejected) {\n                    super.then(onfulfilled, onrejected);\n                }\n            }\n        } else if (this.#error) {\n            throw this.#error;\n        } else {\n            return this.#result!;\n        }\n    }\n\n    /**\n     * This runs {@link Promise#then} normally. If the supplied future function has not been run, runs\n     * that first, unless _delay_ was supplied as truthy, or unless neither _onfullfilled_ or _onrejected_\n     * was supplied.\n     * @param onfulfilled\n     * @param onrejected\n     * @returns\n     */\n    then<TResult1 = T, TResult2 = never>(\n        onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n        onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n        ):\n        Promise<TResult1 | TResult2>\n    {\n        if (this.#fn && !this.#delay && (onfulfilled || onrejected)) {\n            try {\n                this.eval();\n            } catch (e) {\n                // Do nothing; will be rejected inside this.eval().\n            }\n        }\n        if (onfulfilled || onrejected) {\n            return super.then(onfulfilled, onrejected);\n        } else {\n            return this as any as Promise<TResult1 | TResult2>;\n        }\n    }\n}","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/retirement-simulator\n */\n\n/**\n * Mixin for asynchronous iterables.\n *\n * @module\n */\n\nimport { IEnhancements } from \"./ienhancement\";\nimport { Async } from \"./async\";\nimport { AsyncEnhancedConstructor, Constructor, Enhanced, Genable, IndexedFn, IndexedPredicate, Reducer, ReturnValue, SyncType } from \"./types\";\n\n/**\n * Given a class that implements `Iterable<T, TReturn, TNext>`, this returns a class that implements {@link IEnhancements}, allowing one to treat it as if\n * it were an array, in supporting methods such as {@link IEnhancements.map|.map()} and {@link IEnhancements.filter|.filter()}.\n *\n * Usage:\n *\n * ```typescript\n * class MyAsyncIterable implements AsyncIterable<number> {\n *   async *[Symbol.Asynciterator]() {\n *      yield 1;\n *      yield 2;\n *      yield 3;\n *   }\n * }\n *\n * const MyEnhancedAsyncIterable = AsyncMixin(MyAsyncIterable);\n * type MyEnhancedAsyncIterable = ConstructorType<typeof MyEnhancedAsyncIterable>;\n * const foo = new MyEnhancedAsyncIterable();\n * await foo.map(i => i * 2).toArray(); => [2, 4, 6]\n * awaot foo.map(i => i + 2).toArray(); => [3, 4, 5]\n * ```\n * @param Base a constructor for a class that implements `AsyncIterable`.\n * @returns a new constructor for an enhanced class.\n */\nexport function AsyncMixin<T, TReturn, TNext>(Base: Constructor<AsyncIterable<T>>): new (...args: any[]) => AsyncEnhancedConstructor<T, TReturn, TNext, typeof Base> {\n    class AsyncMixin extends Base implements IEnhancements<T, TReturn, TNext, 'async'> {\n        #tag?: string = undefined;\n        constructor(...args: any[]) {\n            super(...args);\n        }\n        #iter() {\n            return Async.enhance(this[Symbol.asyncIterator]() as AsyncIterator<T, TReturn, TNext>);\n        }\n        asArray(): ReturnValue<T[], 'async'> {\n            return this.#iter().asArray();\n        }\n        limit(max: number): Enhanced<T, 'async', TReturn, TNext> {\n            return this.#iter().limit(max);\n        }\n        forEach(f: IndexedFn<T, void, 'async'>, thisArg?: any): void {\n            return this.#iter().forEach(f, thisArg);\n        }\n        map<V>(f: IndexedFn<T, V, 'async'>, thisArg?: any): Enhanced<V, 'async', TReturn, TNext> {\n            return this.#iter().map(f, thisArg);\n        }\n        filter(f: IndexedPredicate<T, 'async'>, thisArg?: any): Enhanced<T, 'async', TReturn, TNext> {\n            return this.#iter().filter(f, thisArg);\n        }\n        flat<D extends number = 1>(depth: D = 1 as D) {\n            return this.#iter().flat(depth);\n        }\n        flatMap<D extends number = 1>(f: IndexedFn<T, any, 'async'>, depth: D = 1 as D) {\n            return this.#iter().flatMap(f, depth);\n        }\n        slice(start: number = 0, end: number = Number.MAX_SAFE_INTEGER): Enhanced<T, 'async', TReturn | undefined, TNext> {\n            return this.#iter().slice(start, end);\n        }\n        concat<T, TReturn, TNext>(...gens: Genable<T, 'async', TReturn, TNext>[]): Enhanced<T, 'async', void | TReturn, TNext> {\n            return this.#iter().concat(...gens);\n        }\n        reduce<A, T, TReturn, TNext>(f: Reducer<A, T, T, 'async'>): ReturnValue<A, 'async'>;\n        reduce<A, T, TReturn = T, TNext = T>(f: Reducer<A, T, A, 'async'>, init: A): ReturnValue<A, 'async'>;\n        reduce<A>(f: Reducer<A, T, A, 'async'>, init?: A): ReturnValue<A, 'async'>;\n        reduce<A>(f: any, init?: any): ReturnValue<A, 'async'> | ReturnValue<A, 'async'> | ReturnValue<A, 'async'> {\n            return this.#iter().reduce(f, init);\n        }\n        some<T>(p: IndexedPredicate<T, 'async'>, thisArg?: any): ReturnValue<boolean, 'async'> {\n            return this.#iter().some(p, thisArg);\n        }\n        every(p: IndexedPredicate<T, 'async'>, thisArg?: any): ReturnValue<boolean, 'async'> {\n            return this.#iter().every(p, thisArg);\n        }\n        repeatLast(max: number = Number.MAX_SAFE_INTEGER): Enhanced<T, 'async', void | TReturn, TNext> {\n            return this.#iter().repeatLast(max);\n        }\n        repeat<N>(value: N, repetitions: number = Number.MAX_SAFE_INTEGER): Enhanced<T | N, 'async', void, TNext> {\n            return this.#iter().repeat(value, repetitions);\n        }\n        join(sep: string = ''): ReturnValue<string, 'async'> {\n            return this.#iter().join(sep);\n        }\n        sort(cmp?: (a: T, b: T) => number): ReturnValue<T[], 'async'> {\n            return this.#iter().sort(cmp);\n        }\n        /**\n         * Tag instances with the type and name for easy recognition.\n         * @internal\n         */\n        get [Symbol.toStringTag]() {\n            try {\n                return this.#tag\n                    ?? (this.#tag = `SyncMixin(${Base.name})`);\n            } catch {\n                // This can happen when viewing the prototype, because #tag isn't declared\n                // on the prototype. That screws up ObservableHQ's inspector, which gets an unhandled\n                // failed promise and never completes if you try to expand the real instance, because\n                // it died on the prototype.\n                return `SyncMixin(${Base.name}).prototype`;\n            }\n        }\n\n    }\n    return AsyncMixin;\n}","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/retirement-simulator\n */\n\n/**\n * Mixin for synchronous iterables.\n *\n * @module\n */\n\nimport { IEnhancements } from \"./ienhancement\";\nimport { Sync } from \"./sync\";\nimport { Constructor, Enhanced, Genable, IndexedFn, IndexedPredicate, Reducer, ReturnValue, SyncEnhancedConstructor, SyncType } from \"./types\";\n\n/**\n * Given a class that implements `Iterable<T, TReturn, TNext>`, this returns a class that implements {@link IEnhancements}, allowing one to treat it as if\n * it were an array, in supporting methods such as {@link IEnhancements.map|.map()} and {@link IEnhancements.filter|.filter()}.\n *\n * Usage:\n *\n * ```typescript\n * class MySyncIterable implements Iterable<number> {\n *   *[Symbol.iterator]() {\n *      yield 1;\n *      yield 2;\n *      yield 3;\n *   }\n * }\n *\n * const MyEnhancedSyncIterable = SyncMixin(MySyncIterable);\n * type MyEnhancedSyncIterable = ConstructorType<typeof MyEnhancedSyncIterable>;\n * const foo = new MyEnhancedSyncIterable();\n * foo.map(i => i * 2).toArray(); => [2, 4, 6]\n * foo.map(i => i + 2).toArray(); => [3, 4, 5]\n * ```\n * @param Base a constructor for a class that implements `Iterable`.\n * @returns a new constructor for an enhanced class.\n */\nexport function SyncMixin<T, TReturn, TNext>(Base: Constructor<Iterable<T>>): new (...args: any[]) => SyncEnhancedConstructor<T, TReturn, TNext, typeof Base> {\n    class SyncMixin extends Base implements IEnhancements<T, TReturn, TNext, 'sync'> {\n        #tag?: string = undefined;\n        constructor(...args: any[]) {\n            super(...args);\n        }\n        #iter() {\n            return Sync.enhance(this[Symbol.iterator]() as Iterator<T, TReturn, TNext>);\n        }\n        asArray(): ReturnValue<T[], 'sync'> {\n            return this.#iter().asArray();\n        }\n        limit(max: number): Enhanced<T, 'sync', TReturn, TNext> {\n            return this.#iter().limit(max);\n        }\n        forEach(f: IndexedFn<T, void, 'sync'>, thisArg?: any): void {\n            return this.#iter().forEach(f, thisArg);\n        }\n        map<V>(f: IndexedFn<T, V, 'sync'>, thisArg?: any): Enhanced<V, 'sync', TReturn, TNext> {\n            return this.#iter().map(f, thisArg);\n        }\n        filter(f: IndexedPredicate<T, 'sync'>, thisArg?: any): Enhanced<T, 'sync', TReturn, TNext> {\n            return this.#iter().filter(f, thisArg);\n        }\n        flat<D extends number = 1>(depth: D = 1 as D) {\n            return this.#iter().flat(depth);\n        }\n        flatMap<D extends number = 1>(f: IndexedFn<T, any, 'sync'>, depth: D = 1 as D) {\n            return this.#iter().flatMap(f, depth);\n        }\n        slice(start: number = 0, end: number = Number.MAX_SAFE_INTEGER): Enhanced<T, 'sync', TReturn | undefined, TNext> {\n            return this.#iter().slice(start, end);\n        }\n        concat<T, TReturn, TNext>(...gens: Genable<T, 'sync', TReturn, TNext>[]): Enhanced<T, 'sync', void | TReturn, TNext> {\n            return this.#iter().concat(...gens);\n        }\n        reduce<A, T, TReturn, TNext>(f: Reducer<A, T, T, 'sync'>): ReturnValue<A, 'sync'>;\n        reduce<A, T, TReturn = T, TNext = T>(f: Reducer<A, T, A, 'sync'>, init: A): ReturnValue<A, 'sync'>;\n        reduce<A>(f: Reducer<A, T, A, 'sync'>, init?: A): ReturnValue<A, 'sync'>;\n        reduce<A>(f: any, init?: any): ReturnValue<A, 'sync'> | ReturnValue<A, 'sync'> | ReturnValue<A, 'sync'> {\n            return this.#iter().reduce(f, init);\n        }\n        some<T>(p: IndexedPredicate<T, 'sync'>, thisArg?: any): ReturnValue<boolean, 'sync'> {\n            return this.#iter().some(p, thisArg);\n        }\n        every(p: IndexedPredicate<T, 'sync'>, thisArg?: any): ReturnValue<boolean, 'sync'> {\n            return this.#iter().every(p, thisArg);\n        }\n        repeatLast(max: number = Number.MAX_SAFE_INTEGER): Enhanced<T, 'sync', void | TReturn, TNext> {\n            return this.#iter().repeatLast(max);\n        }\n        repeat<N>(value: N, repetitions: number = Number.MAX_SAFE_INTEGER): Enhanced<T | N, 'sync', void, TNext> {\n            return this.#iter().repeat(value, repetitions);\n        }\n        join(sep: string = ''): ReturnValue<string, 'sync'> {\n            return this.#iter().join(sep);\n        }\n        sort(cmp?: (a: T, b: T) => number): ReturnValue<T[], 'sync'> {\n            return this.#iter().sort(cmp);\n        }\n        /**\n         * Tag instances with the type and name for easy recognition.\n         * @internal\n         */\n        get [Symbol.toStringTag]() {\n            try {\n                return this.#tag\n                    ?? (this.#tag = `SyncMixin(${Base.name})`);\n            } catch {\n                // This can happen when viewing the prototype, because #tag isn't declared\n                // on the prototype. That screws up ObservableHQ's inspector, which gets an unhandled\n                // failed promise and never completes if you try to expand the real instance, because\n                // it died on the prototype.\n                return `SyncMixin(${Base.name}).prototype`;\n            }\n        }\n\n    }\n    return SyncMixin;\n}","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * Utilities for implementing or using generators.\n * @module util\n */\n\n/**\n * Delay for the specified number of milliseconds.\n *\n * @param ms\n * @param value\n * @returns\n */\nexport const delay = (ms: number, value?: any) =>\n    new Promise(acc => setTimeout(() => acc(value), ms));","/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * Enhanced range implementation.\n *\n * @packageDocumentation\n * @module range\n * @preferred\n */\n\nimport {EnhancedGenerator, Sync} from \"./sync\";\n\n/**\n * Produce numbers from __start__ to __end__ incremented by __step__.\n * Step may be positive or negative, but not zero.\n *\n * Produces an [[EnhancedGenerator]].\n * @param start (default = 0)\n * @param end   (default = `Number.MAX_SAFE_INTEGER`)\n * @param step  (default = 1)\n */\nexport const range = (start = 0, end = Number.MAX_SAFE_INTEGER, step = 1): EnhancedGenerator<number, void, void> => {\n    function* range2(start = 0, end = Number.MAX_SAFE_INTEGER, step = 1) {\n        let x = start;\n        if (step > 0) {\n            while (x < end) {\n                yield x;\n                x += step;\n            }\n        } else if (step < 0) {\n            while (x > end) {\n                yield x;\n                x += step;\n            }\n        } else {\n            throw new Error(\"Step must not be zero.\");\n        }\n    }\n    return Sync.enhance(range2(start, end, step));\n}\n"],"names":["isFunction","f","isGenable","g","isIterator","isIterable","isAsyncGenable","isAsyncIterator","isAsyncIterable","isGenerator","next","return","throw","Symbol","iterator","isAsyncGenerator","asyncIterator","toGenerator","i","it","wrap","r","done","value","Error","toAsyncGenerator","async","toIterator","toAsyncIterator","asyncAdaptor","self","nr","Promise","resolve","e","returning","toIterable","toAsyncIterable","toAsyncIterable_adaptor","iterable","doCatch","onError","args","Enhancements","toStringTag","asArray","this","_impl","limit","max","forEach","thisArg","map","filter","flat","depth","flatMap","slice","start","end","Number","POSITIVE_INFINITY","concat","gens","reduce","init","some","p","every","repeatLast","repeat","repetitions","tail","zip","join","sep","sort","cmp","EnhancedGenerator","Sync","of","values","enhance","gen","limited","err","RangeError","thisArgOrGen","idx","call","undefined","iter","v","genThisArg","x","Set","add","delete","TypeError","depthOrGen","nv","re","length","initOrGen","acc","pred","thisOrGen","genOrThis","last","its","result","push","zip2","genOrSeparator","merge","sources","running","gen2","old","Object","getPrototypeOf","proto","create","prototype","setPrototypeOf","GenProto","Foo","base","newProto","k","Reflect","ownKeys","inherit","makeProto","defineProperty","writable","enumerable","configurable","Async","then","a","donePromise","active","activeCount","dead","ag","handle","val","race","assign","EnhancedAsyncGenerator","AsyncGenProto","AsyncFoo","SyncFoo","Denque","array","options","_head","_tail","_capacity","capacity","_capacityMask","_list","Array","isArray","_fromArray","peekAt","index","len","size","get","peek","peekFront","peekBack","unshift","item","_growArray","pop","shift","head","_shrinkArray","removeOne","remove","count","removed","del_count","toArray","clear","splice","arguments","temp","arg_len","arguments_index","leng","isEmpty","_copyArray","fullCopy","newArray","list","denque","endTag","for","isThrowMsg","m","Future","fn","delay","accept","reject","error","species","constructor","super","rej","eval","onfulfilled","onrejected","Base","AsyncMixin","tag","MAX_SAFE_INTEGER","name","SyncMixin","ms","setTimeout","queue","unblock","waiter","q","send","eventToGenerator","empty","tmp","n","spec","newest","keyFn","Map","set","has","state","pending","hasPending","check","keys","step","range2","_it","iit"],"mappings":"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"}