/**
 * This entry point loads asynchronous extended generators
 * @packageDocumentation
 * @module future
 * @preferred
 */
/**
 * A [[Future]] is a variant of a Promise that takes a function to start execution at a later point, when
 * the value is desired. It can be used to delay a computation, or to avoid it entirely if not needed.
 *
 * By default, the computation begins when the first _onfulfilled_ handler is added with {@link then}, but
 * if the _delay_ parameter is supplied as `true` an explicit call to the {@link eval} method is required.
 */
export declare class Future<T> extends Promise<T> {
    #private;
    static [Symbol.toStringTag]: string;
    static [Symbol.species]: PromiseConstructor;
    /**
     * Construct a {@link Future}.
     *
     * The supplied _fn_ argument will be discarded once run, so any data referenced
     * by it can be freed by the GC.
     * @param fn The function performing the future calculation
     * @param delay true if the calculation should be delayed until an explicit call to `eval`.
     */
    constructor(fn: () => T, delay?: boolean);
    /**
     * Perform the calculation supplied on construction. Takes arguments like {@link Promise#then}. Any pending
     * handlers from `Promise.then()`, `Promise.catch()`, or `Promise.finally()` will be also be
     * handled as normal.
     *
     * {@link eval} is run synchronously if the supplied function is synchronous. The result is not wrapped in a `Promise`,
     * but will be a `Promise` if that's what the supplied function returns. The supplied handlers are _not_ run synchronously.
     * @param onfulfilled
     * @param onrejected
     * @returns
     */
    eval<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): T;
    /**
     * This runs {@link Promise#then} normally. If the supplied future function has not been run, runs
     * that first, unless _delay_ was supplied as truthy, or unless neither _onfullfilled_ or _onrejected_
     * was supplied.
     * @param onfulfilled
     * @param onrejected
     * @returns
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
}
//# sourceMappingURL=future.d.ts.map