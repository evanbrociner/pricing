/**
 * Functions to test (as typeguards) and coerce generators, iterators, etc.
 *
 * @packageDocumentation
 * @module functions
 * @preferred
 */
import type { Async, Sync, Genable, FullIterable, FullIterableIterator } from "./types";
/**
 * Predicate/Type Guard for any function.
 * @param f
 */
export declare const isFunction: <A extends Function>(f: any) => f is A;
/**
 * Predicate/type guard to determine if an object is [[Genable]]. An object is [[Genable]] if it
 * supports the `Iterator` or `Iterable` protocols. (Generators support both).
 * @param g
 */
export declare const isGenable: <T, TReturn = T, TNext = T>(g: any) => g is Iterator<T, TReturn, TNext> | Iterable<T> | Generator<T, TReturn, TNext> | import("./enhancements").Enhancements<T, TReturn, TNext, "sync">;
export declare const isAsyncGenable: <T, TReturn, TNext>(g: any) => g is AsyncIterator<T, TReturn, TNext> | AsyncIterable<T> | AsyncGenerator<T, TReturn, TNext> | import("./enhancements").Enhancements<T, TReturn, TNext, "async"> | Generator<T, TReturn, TNext> | Iterator<T, TReturn, TNext> | Iterable<T> | import("./enhancements").Enhancements<T, TReturn, TNext, "sync">;
/**
 * Predicate/type guard to determine if an object is (or looks like, structurally) a Generator.
 * @param g
 */
export declare const isGenerator: <T, TReturn, TNext>(g: any) => g is Generator<T, TReturn, TNext>;
/**
 * Predicate/type guard to determine if an object is (or looks like, structurally) a AsyncGenerator.
 * @param g
 */
export declare const isAsyncGenerator: <T, TReturn, TNext>(g: any) => g is AsyncGenerator<T, any, unknown>;
/**
 * Coerce an object to an object that can act as a generator (that is, satisfy both `Iterator`
 * and `Iterable`).
 *
 * If it is an `Iterator` but not `Iterable`, or `Iterable` but not `Iterator`, it is wrapped
 * in a generator. This generator is __not__ enhanced. Use [[Sync.enhance]] on the result if
 * you need an enhanced generator.
 * @param i
 */
export declare function toGenerator<T, TReturn = T, TNext = T>(i: Genable<T, Sync, TReturn, TNext>): Generator<T, TReturn, TNext>;
/**
 * Coerce an object to an object that can act as a async generator (that is, satisfy both `Iterator`
 * and `Iterable`).
 *
 * If it is an `AsyncIterator` but not `AsyncIterable`, or `AsyncIterable` but not `AsyncIterator`,
 * it is wrapped in an async generator. This generator is __not__ enhanced. Use [[Async.enhance]] on the result if
 * you need an enhanced generator.
 * @param i
 */
export declare function toAsyncGenerator<T, TReturn, TNext>(i: Genable<T, Async, TReturn, TNext> | Genable<T, Sync, TReturn, TNext>): AsyncGenerator<T, TReturn, TNext>;
/**
 * Coerce a sync [[Genable]] object to an `Iterator`. If the object is a `Generator` or an `Iterator` it is returned,
 * while if it is an `Iterable`, `[Symbol.iterator]`() is invoked.
 * @param i
 */
export declare function toIterator<T, TReturn, TNext>(i: Genable<T, Sync, TReturn, TNext>): Iterator<T, TReturn, TNext>;
/**
 * Coerce an async [[Genable]] object to an `AsyncIterator`. If the object is a `Generator` or an `Iterator` it is returned,
 * while if it is an `Iterable`, `[Symbol.iterator]`() is invoked.
 * @param i
 */
export declare function toAsyncIterator<T, TReturn, TNext = T>(i: Genable<T, Async, TReturn, TNext>): AsyncIterator<T, TReturn, TNext>;
/**
 * Coerce a [[Genable]] object to `Iterable`. If it is already an `Iterable`, it is returned
 * unchanged. If it is an `Iterator`, it is wrapped in an object with a `[Symbol.iterator]`
 * method that returns the supplied iterator.
 * @param i
 */
export declare function toIterable<T, TReturn = T, TNext = T>(i: Genable<T, Sync, TReturn, TNext>): FullIterable<T, Sync, TReturn, TNext>;
/**
 * Coerce a [[Genable]] object to `AsyncIterable`. If it is already an `AsyncIterable`, it is returned
 * unchanged. If it is an `AsyncIterator`, it is wrapped in an object with a `[Symbol.asyncIterator]`
 * method that returns the supplied iterator.
 * @param i
 */
export declare function toAsyncIterable<T, TReturn, TNext>(i: Genable<T, Async, TReturn, TNext>): FullIterable<T, Async, TReturn, TNext>;
/**
 * Similar to [[toGenerator]], but does not require the presence of `Generator.return` or `Generator.throw` methods.
 * @param i
 */
export declare function toIterableIterator<T, TReturn = T, TNext = T>(i: Genable<T, Sync, TReturn, TNext>): FullIterableIterator<T, Sync, TReturn, TNext>;
/**
 * Similar to [[toAsyncGenerator]], but does not require the presence of `AsyncGenerator.return` or
 * `AsyncGenerator.throw` methods.
 * @param i
 */
export declare function toAsyncIterableIterator<T, TReturn, TNext>(i: Genable<T, Async, TReturn, TNext>): FullIterableIterator<T, Async, TReturn, TNext>;
/**
 * Predicate/type guard, returns `true` if the argument satisfies the `Iterator` protocol (has a `next()` method).
 *
 * Note: There is no way to statically distinguish between an `Iterator` and an `AsyncIterator`. You will get
 * runtime errors if you don't anticipate the distinction.
 * @param i
 */
export declare const isIterator: <K, KReturn = K, KNext = K>(i: any) => i is Iterator<K, KReturn, KNext>;
/**
 * Predicate/type guard, returns `true` if the argument satisfies the `AsyncIterator` protocol (has a `next()` method).
 *
 * Note: There is no way to statically distinguish between an `Iterator` and an `AsyncIterator`. You will get
 * runtime errors if you don't anticipate the distinction.
 * @param i
 */
export declare const isAsyncIterator: <K, KReturn = K, KNext = K>(i: any) => i is AsyncIterator<K, KReturn, KNext>;
/**
 * Predicate/type guard, returns `true` if the argument satisfies the `Iterable` protocol (has a `[Symbol.iterator]`
 * method).
 * @param i
 */
export declare const isIterable: <K, KReturn = K, KNext = K>(i: any) => i is Iterable<K> & {
    [Symbol.iterator]: () => Iterator<K, KReturn, KNext>;
};
/**
 * Predicate/type guard, returns `true` if the argument satisfies the `AsyncIterable` protocol (has a `[Symbol.asyncIterator]`
 * method).
 * @param i
 */
export declare const isAsyncIterable: <K, KReturn = K, KNext = K>(i: any) => i is AsyncIterable<K> & {
    [Symbol.asyncIterator]: () => AsyncIterator<K, KReturn, KNext>;
};
/**
 * Predicate/type guard, returns `true` if the argument satisfies the `Iterable` protocol (has a `[Symbol.iterator]`
 * method) and the `Iterator` protocol (a next() method).
 * @param i
 */
export declare const isIterableIterator: <K, KReturn = K, KNext = K>(i: any) => i is IterableIterator<K> & {
    [Symbol.iterator]: () => IterableIterator<K> & any;
};
/**
 * Predicate/type guard, returns `true` if the argument satisfies the `AsyncIterable` protocol (has a `[Symbol.asyncIterator]`
 * method) and the `AsyncIterator` protocol (a next() method).
 * @param i
 */
export declare const isAsyncIterableIterator: <K, KReturn = K, KNext = K>(i: any) => i is AsyncIterable<K> & {
    [Symbol.asyncIterator]: () => AsyncIterable<K> & any;
};
/**
 * Wrap a function in a catch block.
 * @param f
 * @param onError Called when an error is thrown. The return value is returned. If not supplied, undefined is returned.
 */
export declare const doCatch: <A extends any[], R>(f: (...args: A) => R, onError?: ((e: Error) => R) | undefined) => (...args: A) => R | undefined;
//# sourceMappingURL=functions.d.ts.map