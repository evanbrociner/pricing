{"version":3,"file":"future.js","sources":["../../src/future.ts"],"sourcesContent":["/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * This entry point loads asynchronous extended generators\n * @packageDocumentation\n * @module future\n * @preferred\n */\n\n/**\n * A [[Future]] is a variant of a Promise that takes a function to start execution at a later point, when\n * the value is desired. It can be used to delay a computation, or to avoid it entirely if not needed.\n *\n * By default, the computation begins when the first _onfulfilled_ handler is added with {@link then}, but\n * if the _delay_ parameter is supplied as `true` an explicit call to the {@link eval} method is required.\n */\nexport class Future<T> extends Promise<T> {\n    #fn?: () => T;\n    #delay: boolean;\n\n    #accept?: (val: T) => void;\n    #reject?: (err: Error) => void;\n    #result?: T;\n    #error?: Error;\n    static [Symbol.toStringTag] = 'Future';\n    static [Symbol.species] = Promise;\n\n    /**\n     * Construct a {@link Future}.\n     *\n     * The supplied _fn_ argument will be discarded once run, so any data referenced\n     * by it can be freed by the GC.\n     * @param fn The function performing the future calculation\n     * @param delay true if the calculation should be delayed until an explicit call to `eval`.\n     */\n    constructor(fn: () => T, delay?: boolean) {\n        let accept;\n        let reject;\n        super((acc: (val: T) => void, rej: (err: Error) => void) => {\n            accept = acc;\n            reject = rej;\n        });\n        this.#accept = accept;\n        this.#reject = reject;\n        this.#fn = fn;\n        this.#delay = !!delay;\n    }\n\n    /**\n     * Perform the calculation supplied on construction. Takes arguments like {@link Promise#then}. Any pending\n     * handlers from `Promise.then()`, `Promise.catch()`, or `Promise.finally()` will be also be\n     * handled as normal.\n     *\n     * {@link eval} is run synchronously if the supplied function is synchronous. The result is not wrapped in a `Promise`,\n     * but will be a `Promise` if that's what the supplied function returns. The supplied handlers are _not_ run synchronously.\n     * @param onfulfilled\n     * @param onrejected\n     * @returns\n     */\n    eval<TResult1 = T, TResult2 = never>(\n        onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n        onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n        ):\n        T\n    {\n        if (this.#fn) {\n            try {\n                this.#result = this.#fn();\n                this.#accept?.(this.#result);\n                return this.#result;\n            } catch (e) {\n                this.#error = e;\n                this.#reject?.(e);\n                throw e;\n            } finally {\n                this.#fn = undefined;\n                this.#accept = undefined;\n                this.#reject = undefined;\n                if (onfulfilled || onrejected) {\n                    super.then(onfulfilled, onrejected);\n                }\n            }\n        } else if (this.#error) {\n            throw this.#error;\n        } else {\n            return this.#result!;\n        }\n    }\n\n    /**\n     * This runs {@link Promise#then} normally. If the supplied future function has not been run, runs\n     * that first, unless _delay_ was supplied as truthy, or unless neither _onfullfilled_ or _onrejected_\n     * was supplied.\n     * @param onfulfilled\n     * @param onrejected\n     * @returns\n     */\n    then<TResult1 = T, TResult2 = never>(\n        onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n        onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n        ):\n        Promise<TResult1 | TResult2>\n    {\n        if (this.#fn && !this.#delay && (onfulfilled || onrejected)) {\n            try {\n                this.eval();\n            } catch (e) {\n                // Do nothing; will be rejected inside this.eval().\n            }\n        }\n        if (onfulfilled || onrejected) {\n            return super.then(onfulfilled, onrejected);\n        } else {\n            return this as any as Promise<TResult1 | TResult2>;\n        }\n    }\n}"],"names":["Future","Promise","fn","delay","accept","reject","result","error","Symbol","toStringTag","species","constructor","super","acc","rej","this","eval","onfulfilled","onrejected","e","undefined","then"],"mappings":"mCAmBaA,UAAkBC,QAC3BC,IACAC,OAEAC,QACAC,QACAC,QACAC,OACA,OAAQC,OAAOC,aAAe,SAC9B,OAAQD,OAAOE,SAAWT,QAU1BU,YAAYT,EAAaC,GACrB,IAAIC,EACAC,EACJO,OAAM,CAACC,EAAuBC,KAC1BV,EAASS,EACTR,EAASS,KAEbC,aAAeX,EACfW,aAAeV,EACfU,SAAWb,EACXa,cAAgBZ,EAcpBa,KACIC,EACAC,GAIA,IAAIH,SAiBG,CAAA,GAAIA,YACP,MAAMA,YAEN,OAAOA,aAnBP,IAGI,OAFAA,aAAeA,WACfA,eAAeA,cACRA,aACT,MAAOI,GAGL,MAFAJ,YAAcI,EACdJ,eAAeI,GACTA,UAENJ,cAAWK,EACXL,kBAAeK,EACfL,kBAAeK,GACXH,GAAeC,IACfN,MAAMS,KAAKJ,EAAaC,IAkBxCG,KACIJ,EACAC,GAIA,GAAIH,WAAaA,cAAgBE,GAAeC,GAC5C,IACIH,KAAKC,OACP,MAAOG,IAIb,OAAIF,GAAeC,EACRN,MAAMS,KAAKJ,EAAaC,GAExBH"}