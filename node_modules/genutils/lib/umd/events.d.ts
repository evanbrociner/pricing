/**
 * Turn events/imperative calls into values returned by an async generator.
 * @module events
 * @packageDocumentation
 * @preferred
 */
/**
 * Interface for controlling the generators returned by {@link eventToGenerator}.
 */
export interface Controller<T, E = T | any> {
    /**
     * Queue _v_ to the generator.
     * @param v
     */
    send(v: T): void;
    /**
     * Queue _e_ (optional) to be returned by the generator, ending it.
     * @param e
     */
    end(e?: E): void;
    /**
     * Queue an error to be thrown by the generator, ending it.
     * @param err
     */
    throw(err: Error): void;
    /**
     * Clear all pending values queued to the generator.
     */
    clear(): void;
}
declare const endTag: unique symbol;
declare const returnMsg: {
    [endTag]: string;
};
declare const throwMsg: {
    [endTag]: string;
};
declare type ReturnMsg<R> = typeof returnMsg & {
    value: R;
};
declare type ThrowMsg = typeof throwMsg & {
    value: Error;
};
declare type EndMsg<R> = ReturnMsg<R> | ThrowMsg;
/**
 * A queue usable by {@link eventToGenerator}.
 */
export interface Queue<T extends any> {
    length: number;
    push(value: T): number;
    shift(): T | undefined;
    clear(): void;
}
/**
 * A factory function that returns a {@link Queue}. It will be called with no arguments.
 */
export declare type QueueFactory<T> = () => Queue<T>;
/**
 * async generator function `eventToGenerator`(_queue_) returns _[generator, controller]_
 *
 * Create a generator that can be made to return values to be supplied by a callback.
 * * _queue_: A {@link QueueFactory} function that returns the {@link Queue} to use.
 * * _generator_: The generator being controlled.
 * * _controller_: A {@link Controller} object with the following:
 * >   * `send(`_value_`)`: send the next value to generate.
 * >   * `end()`: Cause the generator to end
 * >   * `throw(`_error_`)`: Cause the generator to throw an exception.
 * >   * `clear()`: Remove any pending queue items.
 *
 * `end` and `throw` are synchronous with the queue. That is, they cause the queue to end or throw
 * when the consumer of the generator has read everything prior in the queue.
 *
 * _queue_ should return a {@link Queue} object that implements `.length`, `.push()`, `.shift()`, and `.clear()`.
 * The default implementation is [Denque](https://github.com/invertase/denque), which is fast for unbounded size.
 *
 * The returned generator may be enhanced with {@link Async_.enhance|Async.enhance} if desired.
 *
 * Other {@link QueueFactory} functions provided:
 * * {@link queue1}: returns a "queue" of maximum length 1. Older entries are discarded.
 * * {@link queueSticky}`: Returns a queue that returns the last value seen, forever (or until cleared).
 * * {@link queueOldest}_(n)_: Call with _n_ to set the size; when full new values are discarded.
 * * {@link queueNewest}_(n)_: Call with _n_ to set the size; when full old values are discarded.
 * * {@link queueUnique}: Returns a queue that discards duplicate enqueued values.
 * @returns [AsyncGenerator, {@link Controller}]
 */
export declare const eventToGenerator: <T, R = void>(queue?: QueueFactory<T | EndMsg<R>>) => [AsyncGenerator<T, R, unknown>, Controller<T, any>];
/**
 * A {@link QueueFactory} that returns a {@link Queue} of maximum length 1, which discards older values.
 */
export declare const queue1: <V>() => Queue<V>;
/**
 * A {@link QueueFactory} that returns a {@link Queue} of maximum length 1, which discards older
 * values, but returns the last seen forever (until cleared).
 */
export declare const queueSticky: <V>() => Queue<V>;
/**
 * Make a {@link QueueFactory} that returns a {@link Queue} of maximum length _n_,
 * which discards newer values.
 * @param n the number of entries, default = `1`.
 */
export declare const queueOldest: <V>(n?: number) => QueueFactory<V>;
/**
 * Make a {@link QueueFactory} that returns a {@link Queue} of maximum length _n_, which discards older values.
 * @param n the number of entries, default = `1`.
 */
export declare const queueNewest: <V>(n?: number) => QueueFactory<V>;
export declare type KeyFn = (k: any) => any;
export interface QueueUniqueSpec {
    newest?: boolean;
    keyFn?: KeyFn;
}
/**
 * function queueUnique({newest, keyFn}): () =>
 *
 * Return a {@link QueueFactory}, which supplies {@link Queue} instances that discard
 * already-enqueued entries. Values can be re-enqueued once delivered.
 * * _newest_: if `false` (the default), values are dequeued in the order they were first enqueued. Using `{newest: true}` deprioritizes more active values so less-busy items can get through. But in a sustained-busy situation, there is no guarantee they will ever be delivered. This can be an advantage or disadvantage, depending on requirements.
 * * _keyFn_: A function to identify what values count as "equal". The default regards +0 and -0 as the same, NaN's as all the same, and otherwise behaves as `===`.
 * @param spec a {@link QueueUniqueSpec}
 */
export declare const queueUnique: <E>(spec?: QueueUniqueSpec | undefined) => QueueFactory<E>;
/**
 * Accepts objects, and returns just the fields that have changed (are no longer `===`).
 *
 * This does not distinguish between deleted keys and keys assigned a value of `undefined` in the input.
 * In the output, a deleted key is represented as present with a value of `undefined`.
 *
 * @param init The initial value
 */
export declare const queueUpdateShallow: <E extends object>(init?: Partial<E>) => () => Queue<Partial<E>>;
export {};
//# sourceMappingURL=events.d.ts.map