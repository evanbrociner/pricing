{"version":3,"file":"functions.js","sources":["../../src/functions.ts"],"sourcesContent":["/*\n * Copyright 2021 by Bob Kerns. Licensed under MIT license.\n *\n * Github: https://github.com/BobKerns/genutils\n */\n/**\n * Functions to test (as typeguards) and coerce generators, iterators, etc.\n *\n * @packageDocumentation\n * @module functions\n * @preferred\n */\n\n\nimport type {Async, Sync, Genable, FullIterable, FullIterableIterator} from \"./types\";\n\n/**\n * Predicate/Type Guard for any function.\n * @param f\n */\nexport const isFunction = <A extends Function>(f: (A | any)): f is A => {\n    return typeof f === 'function';\n}\n\n/**\n * Predicate/type guard to determine if an object is [[Genable]]. An object is [[Genable]] if it\n * supports the `Iterator` or `Iterable` protocols. (Generators support both).\n * @param g\n */\nexport const isGenable = <T, TReturn = T, TNext = T>(g: Iterator<T, TReturn, TNext>|Iterable<T>|Generator<T, TReturn, TNext>|any):\n    g is Genable<T, Sync, TReturn, TNext> =>\n        g && (isIterator(g) || isIterable(g));\n\n\nexport const isAsyncGenable = <T, TReturn, TNext>(g: AsyncIterator<T, TReturn, TNext>|AsyncIterable<T>|AsyncGenerator<T,TReturn,TNext>|any):\n    g is Genable<T, Async, TReturn, TNext> =>\n        g && (isAsyncIterator<T, TReturn, TNext>(g) || isAsyncIterable<T, TReturn, TNext>(g) || isIterable<T, TReturn, TNext>(g));\n\n/**\n * Predicate/type guard to determine if an object is (or looks like, structurally) a Generator.\n * @param g\n */\nexport const isGenerator = <T, TReturn, TNext>(g: Genable<T, Sync, TReturn, TNext>|any): g is Generator<T, TReturn, TNext> =>\n    g &&\n    isFunction(g.next)\n    && isFunction(g.return)\n    && isFunction(g.throw)\n    && isFunction(g[Symbol.iterator]);\n\n/**\n * Predicate/type guard to determine if an object is (or looks like, structurally) a AsyncGenerator.\n * @param g\n */\nexport const isAsyncGenerator = <T, TReturn, TNext>(g: Genable<T, Async, TReturn, TNext>|any): g is AsyncGenerator<T> =>\n    g &&\n    isFunction(g.next)\n    && isFunction(g.return)\n    && isFunction(g.throw)\n    && isFunction(g[Symbol.asyncIterator]);\n\n/**\n * Coerce an object to an object that can act as a generator (that is, satisfy both `Iterator`\n * and `Iterable`).\n *\n * If it is an `Iterator` but not `Iterable`, or `Iterable` but not `Iterator`, it is wrapped\n * in a generator. This generator is __not__ enhanced. Use [[Sync.enhance]] on the result if\n * you need an enhanced generator.\n * @param i\n */\nexport function toGenerator<T, TReturn = T, TNext = T>(i: Genable<T, Sync, TReturn, TNext>): Generator<T, TReturn, TNext> {\n    if (isGenerator(i)) return i;\n    if (isIterator(i)) {\n        const it = i;\n\n        function* wrap() {\n            while (true) {\n                const r = it.next();\n                if (r.done) return r.value;\n                yield r.value;\n            }\n        }\n\n        return wrap();\n    } else if (isIterable(i)) {\n        return toGenerator(i[Symbol.iterator]() as Iterator<T, TReturn, TNext>);\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\n\n/**\n * Coerce an object to an object that can act as a async generator (that is, satisfy both `Iterator`\n * and `Iterable`).\n *\n * If it is an `AsyncIterator` but not `AsyncIterable`, or `AsyncIterable` but not `AsyncIterator`,\n * it is wrapped in an async generator. This generator is __not__ enhanced. Use [[Async.enhance]] on the result if\n * you need an enhanced generator.\n * @param i\n */\nexport function toAsyncGenerator<T, TReturn, TNext>(i: Genable<T, Async, TReturn, TNext>|Genable<T, Sync, TReturn, TNext>):\n    AsyncGenerator<T, TReturn, TNext>\n{\n    if (isAsyncGenerator(i)) return i;\n    if (isAsyncIterator(i)) {\n        const it = i;\n        async function* wrap() {\n            while (true) {\n                const r = await it.next();\n                if (r.done) return r.value;\n                yield r.value;\n            }\n        }\n        return wrap();\n    } else if (isAsyncIterable(i)) {\n        return toAsyncGenerator(i[Symbol.asyncIterator]()) as AsyncGenerator<T, TReturn, TNext>;\n    } else if (isIterable(i)) {\n        return toAsyncGenerator(i[Symbol.iterator]() as Iterator<T, TReturn, TNext>);\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\n/**\n * Coerce a sync [[Genable]] object to an `Iterator`. If the object is a `Generator` or an `Iterator` it is returned,\n * while if it is an `Iterable`, `[Symbol.iterator]`() is invoked.\n * @param i\n */\nexport function toIterator<T, TReturn, TNext>(i: Genable<T, Sync, TReturn, TNext>): Iterator<T, TReturn, TNext> {\n    if (isGenerator(i)) return i;\n    if (isIterator(i)) return i;\n    if (isIterable(i)) {\n        return i[Symbol.iterator]() as Iterator<T, TReturn, TNext>;\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\n\n/**\n * Coerce an async [[Genable]] object to an `AsyncIterator`. If the object is a `Generator` or an `Iterator` it is returned,\n * while if it is an `Iterable`, `[Symbol.iterator]`() is invoked.\n * @param i\n */\nexport function toAsyncIterator<T, TReturn, TNext = T>(i: Genable<T, Async, TReturn, TNext>): AsyncIterator<T, TReturn, TNext> {\n    if (isAsyncGenerator(i)) return i;\n    if (isAsyncIterable(i)) {\n        return i[Symbol.asyncIterator]() as AsyncIterator<T, TReturn, TNext>;\n    } else if (isIterable(i)) {\n        return asyncAdaptor(toIterator(i));\n    } else {\n        throw new Error(`Not iterable: ${i}`);\n    }\n}\n\nconst asyncAdaptor = <T, TReturn, TNext>(i: Iterator<T, TReturn, TNext>):\n    AsyncGenerator<T, TReturn, TNext> =>\n{\n    const it = i as unknown as AsyncIterator<T>;\n    let self: AsyncGenerator<T> & {returning?: any};\n    async function* asyncAdaptor(): AsyncGenerator<T> {\n        let nr: any;\n        let done = false;\n        try {\n            while (true) {\n                const r = await Promise.resolve(it.next());\n                if (r.done) {\n                    done = true;\n                    return r.value;\n                }\n                try {\n                    nr = yield r.value;\n                } catch (e) {\n                    await it.throw?.(e);\n                    throw(e);\n                }\n            }\n        } finally {\n            if (!done) {\n                await i.return?.(self.returning);\n            }\n        }\n    }\n    return self = asyncAdaptor();\n};\n\n/**\n * Coerce a [[Genable]] object to `Iterable`. If it is already an `Iterable`, it is returned\n * unchanged. If it is an `Iterator`, it is wrapped in an object with a `[Symbol.iterator]`\n * method that returns the supplied iterator.\n * @param i\n */\nexport function toIterable<T, TReturn = T, TNext = T>(i: Genable<T,Sync,TReturn,TNext>):\n    FullIterable<T, Sync, TReturn, TNext>\n{\n    if (isIterable(i)) return i as FullIterable<T, Sync, TReturn, TNext>;\n    return {\n        [Symbol.iterator]: () => i\n    } as FullIterable<T, Sync, TReturn, TNext>;\n}\n\n\n/**\n * Coerce a [[Genable]] object to `AsyncIterable`. If it is already an `AsyncIterable`, it is returned\n * unchanged. If it is an `AsyncIterator`, it is wrapped in an object with a `[Symbol.asyncIterator]`\n * method that returns the supplied iterator.\n * @param i\n */\nexport function toAsyncIterable<T, TReturn, TNext>(i: Genable<T, Async, TReturn, TNext>):\n    FullIterable<T, Async, TReturn, TNext>\n{\n    if (isAsyncIterable<T, TReturn, TNext>(i)) return i;\n    if (isIterable<T, TReturn, TNext>(i)) {\n        return toAsyncIterable_adaptor<T, TReturn, TNext>(i) as\n            FullIterable<T, Async, TReturn, TNext>;\n    }\n    return {\n        [Symbol.asyncIterator]: () => i\n    } as FullIterable<T, Async, TReturn, TNext>;\n}\nasync function* toAsyncIterable_adaptor<T, TReturn, TNext>(iterable: Iterable<T>):\n    AsyncGenerator<T, TReturn, TNext>\n{\n    const it = iterable[Symbol.iterator]();\n    let nr: any = undefined;\n    while (true) {\n        const r = await it.next(nr);\n        if (r.done) return r.value;\n        nr = yield r.value;\n    }\n}\n\n// noinspection JSUnusedGlobalSymbols\n/**\n * Similar to [[toGenerator]], but does not require the presence of `Generator.return` or `Generator.throw` methods.\n * @param i\n */\nexport function toIterableIterator<T, TReturn = T, TNext = T>(i: Genable<T, Sync, TReturn, TNext>): FullIterableIterator<T, Sync, TReturn, TNext> {\n    if (isIterable(i) && isIterator(i)) return i as FullIterableIterator<T, Sync, TReturn, TNext>;\n    if (isIterable(i)) {\n        // Invoke [Symbol.iterator]() just once, on first use.\n        let _it: Iterator<T>|undefined = undefined;\n        const it = () => _it ?? (_it = i[Symbol.iterator]());\n        const iit: FullIterableIterator<T, Sync, TReturn, TNext> = {\n            [Symbol.iterator]: () => iit,\n            next: (val?: TNext) => it().next(val as undefined),\n            return: it().return && ((val) => it().return!(val)),\n            throw: it().throw && ((val) => it().throw!(val))\n        };\n        return iit;\n    }\n    if (isIterator(i)) {\n        const iit: FullIterableIterator<T, Sync, TReturn, TNext> = {\n            [Symbol.iterator]: () => iit,\n            next: (val?: TNext) => i.next(val!),\n            return: i.return && ((val) => i.return!(val)),\n            throw: i.throw && ((val) => i.throw!(val))\n        }\n        return iit;\n    }\n    throw new Error(`Not iterator nor iterable: ${i}`);\n}\n\n\n/**\n * Similar to [[toAsyncGenerator]], but does not require the presence of `AsyncGenerator.return` or\n * `AsyncGenerator.throw` methods.\n * @param i\n */\nexport function toAsyncIterableIterator<T, TReturn, TNext>(i: Genable<T, Async, TReturn, TNext>):\n    FullIterableIterator<T, Async, TReturn, TNext>\n{\n    if (isAsyncIterable<T, TReturn, TNext>(i) && isAsyncIterator<T, TReturn, TNext>(i)) {\n        return i as unknown as FullIterableIterator<T, Async, TReturn, TNext>;\n    }\n    if (isAsyncIterable<T, TReturn, TNext>(i)) {\n        // Invoke [Symbol.iterator]() just once, on first use.\n        let _it: AsyncIterator<T, TReturn, TNext>|undefined = undefined;\n        const it = () => _it ?? (_it = i[Symbol.asyncIterator]() as AsyncIterator<T, TReturn, TNext>);\n        const iit: AsyncIterableIterator<T> = {\n            [Symbol.asyncIterator]: () => iit,\n            next: () => it().next(),\n            return: it().return && ((val) => it().return!(val)),\n            throw: it().throw && ((val) => it().throw!(val))\n        };\n        return iit;\n    }\n    if (isIterable<T, TReturn, TNext>(i)) {\n        return toAsyncIterable_adaptor(i);\n    }\n    if (isAsyncIterator(i)) {\n        const iit: AsyncIterableIterator<T> = {\n            [Symbol.asyncIterator]: () => iit,\n            next: (val: any) => i.next(val),\n            return: i.return && ((val) => i.return!(val)),\n            throw: i.throw && ((val) => i.throw!(val))\n        }\n        return iit;\n    }\n    throw new Error(`Not iterator nor iterable: ${i}`);\n}\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `Iterator` protocol (has a `next()` method).\n *\n * Note: There is no way to statically distinguish between an `Iterator` and an `AsyncIterator`. You will get\n * runtime errors if you don't anticipate the distinction.\n * @param i\n */\nexport const isIterator = <K, KReturn = K, KNext = K>(i: Iterable<K> | FullIterable<K, Sync, KReturn, KNext> | any):\n    i is Iterator<K, KReturn, KNext> =>\n        i && typeof i.next === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `AsyncIterator` protocol (has a `next()` method).\n *\n * Note: There is no way to statically distinguish between an `Iterator` and an `AsyncIterator`. You will get\n * runtime errors if you don't anticipate the distinction.\n * @param i\n */\nexport const isAsyncIterator = <K, KReturn = K, KNext = K>(i: AsyncIterable<K> | AsyncIterator<K, KReturn, KNext>| any):\n    i is AsyncIterator<K, KReturn, KNext> =>\n        i && typeof i.next === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `Iterable` protocol (has a `[Symbol.iterator]`\n * method).\n * @param i\n */\nexport const isIterable = <K, KReturn = K, KNext = K>(i: Iterable<K> | FullIterable<K, Sync, KReturn, KNext> | any): i is FullIterable<K, Sync, KReturn, KNext>  =>\n    i && typeof i[Symbol.iterator] === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `AsyncIterable` protocol (has a `[Symbol.asyncIterator]`\n * method).\n * @param i\n */\nexport const isAsyncIterable = <K, KReturn = K, KNext = K>(i: AsyncIterable<K> | FullIterable<K, Async, KReturn, KNext> | any):\n    i is FullIterable<K, Async, KReturn, KNext> =>\n        i && typeof i[Symbol.asyncIterator] === 'function';\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `Iterable` protocol (has a `[Symbol.iterator]`\n * method) and the `Iterator` protocol (a next() method).\n * @param i\n */\nexport const isIterableIterator = <K, KReturn = K, KNext = K>(i: Iterable<K>|Iterator<K, KReturn, KNext>|any):\n    i is FullIterableIterator<K, Sync, KReturn, KNext> =>\n        isIterator(i) && isIterable(i);\n\n/**\n * Predicate/type guard, returns `true` if the argument satisfies the `AsyncIterable` protocol (has a `[Symbol.asyncIterator]`\n * method) and the `AsyncIterator` protocol (a next() method).\n * @param i\n */\nexport const isAsyncIterableIterator = <K, KReturn = K, KNext = K>(i: Iterable<K>|Iterator<K, KReturn, KNext>|any):\n    i is FullIterableIterator<K, Async, KReturn, KNext> =>\n        isAsyncIterator(i) && isAsyncIterable(i);\n\n/**\n * Wrap a function in a catch block.\n * @param f\n * @param onError Called when an error is thrown. The return value is returned. If not supplied, undefined is returned.\n */\nexport const doCatch = <A extends any[], R>(f: (...args: A) => R, onError?: (e: Error) => R):\n    ((...args: A) => (R | undefined)) => {\n    return (...args: A) => {\n        try {\n            return f(...args);\n        } catch (e) {\n            return onError?.(e);\n        }\n    };\n};\n"],"names":["isFunction","f","isGenerator","g","next","return","throw","Symbol","iterator","isAsyncGenerator","asyncIterator","toIterator","i","isIterator","isIterable","Error","asyncAdaptor","it","self","async","nr","done","r","Promise","resolve","value","e","returning","toAsyncIterable_adaptor","iterable","isAsyncIterator","isAsyncIterable","onError","args","toAsyncGenerator","wrap","_it","iit","val","toGenerator"],"mappings":"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"}