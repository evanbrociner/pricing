var t,e;t=this,e=function(t){const e=t=>"function"==typeof t,r=t=>t&&(h(t)||w(t)),n=t=>t&&(d(t)||p(t)||w(t)),o=t=>t&&e(t.next)&&e(t.return)&&e(t.throw)&&e(t[Symbol.iterator]),i=t=>t&&e(t.next)&&e(t.return)&&e(t.throw)&&e(t[Symbol.asyncIterator]);function a(t){if(o(t))return t;if(h(t)){const r=t;function*e(){for(;;){const t=r.next();if(t.done)return t.value;yield t.value}}return e()}if(w(t))return a(t[Symbol.iterator]());throw new Error(`Not iterable: ${t}`)}function l(t){if(i(t))return t;if(d(t)){const r=t;async function*e(){for(;;){const t=await r.next();if(t.done)return t.value;yield t.value}}return e()}if(p(t))return l(t[Symbol.asyncIterator]());if(w(t))return l(t[Symbol.iterator]());throw new Error(`Not iterable: ${t}`)}function c(t){if(o(t))return t;if(h(t))return t;if(w(t))return t[Symbol.iterator]();throw new Error(`Not iterable: ${t}`)}function u(t){if(i(t))return t;if(p(t))return t[Symbol.asyncIterator]();if(w(t))return s(c(t));throw new Error(`Not iterable: ${t}`)}const s=t=>{const e=t;let r;return r=async function*(){let n,o=!1;try{for(;;){const t=await Promise.resolve(e.next());if(t.done)return o=!0,t.value;try{n=yield t.value}catch(t){throw await(e.throw?.(t)),t}}}finally{o||await(t.return?.(r.returning))}}()};function f(t){return w(t)?t:{[Symbol.iterator]:()=>t}}function y(t){return p(t)?t:w(t)?async function*(t){const e=t[Symbol.iterator]();let r;for(;;){const t=await e.next(r);if(t.done)return t.value;r=yield t.value}}(t):{[Symbol.asyncIterator]:()=>t}}const h=t=>t&&"function"==typeof t.next,d=t=>t&&"function"==typeof t.next,w=t=>t&&"function"==typeof t[Symbol.iterator],p=t=>t&&"function"==typeof t[Symbol.asyncIterator],v=(t,e)=>(...r)=>{try{return t(...r)}catch(t){return e?.(t)}};class m{returning;[Symbol.toStringTag];asArray(){return this._impl.asArray(this)}limit(t){return this._impl.limit(t,this)}forEach(t,e){this._impl.forEach(t,e,this)}map(t,e){return this._impl.map(t,e,this)}filter(t,e){return this._impl.filter(t,e,this)}flat(t=1){return this._impl.flat(t,this)}flatMap(t,e=1){return this._impl.flatMap(t,e,this)}slice(t=0,e=Number.POSITIVE_INFINITY){return this._impl.slice(t,e,this)}concat(...t){return this._impl.concat(this,...t)}reduce(t,e){return this._impl.reduce(t,e,this)}some(t,e){return this._impl.some(t,e,this)}every(t,e){return this._impl.every(t,e,this)}repeatLast(t=Number.POSITIVE_INFINITY){return this._impl.repeatLast(this,t)}repeat(t,e=Number.POSITIVE_INFINITY){const r=this._impl.repeat(t,e);return this._impl.concat(this,r)}zip(...t){return this._impl.zip(this,...t)}join(t){return this._impl.join(this,t)}sort(t){return this._impl.sort(t)(this)}}class b extends m{[Symbol.toStringTag]}const g=new class{of(...t){return this.enhance(t)}asArray(t){return[...f(t)]}limit(t,e){let r;function*n(e){let n,o=!1;try{for(let r=0;r<t;r++){const t=e.next(n);if(t.done)return t.value;try{n=yield t.value}catch(t){e.throw?.(t)}}o=!0;const i=new RangeError(`Generator produced excessive values > ${t}.`);throw e.throw?.(i),i}finally{o||e.return?.(r?.returning)}}return e?r=this.enhance(n(c(e))):t=>this.enhance(n(c(t)))}forEach(t,e,n){const o=(t,e,r)=>{const n=c(r);let o=0;for(;;){const r=n.next();if(r.done)return;t.call(e,r.value,o++)}};return n?o(t,e,n):r(e)?o(t,void 0,e):(r,n)=>o(t,n??e,r)}map(t,e,n){const o=(e,r)=>{const n=a(r);let o;return o=this.enhance(function*(){let r,i=0;for(;;)for(;;)try{for(;;){const o=n.next(r);if(o.done)return o.value;const a=t.call(e,o.value,i++);try{r=yield a}catch(t){n.throw(t)}}}finally{if(!n.return(o?.returning).done)break}}())};return n?o(e,n):r(e)?o(void 0,e):(t,r)=>o(r??e,t)}filter(t,e,n){const o=(e,r)=>{const n=a(r);let o;return o=this.enhance(function*(t){let r,i=0;for(;;)for(;;)try{for(;;){const o=n.next(r);if(o.done)return o.value;if(t.call(e,o.value,i++))try{r=yield o.value}catch(t){n.throw(t)}}}finally{const t=n.return?.(o?.returning);if(!t?.done)break}}(t))};return n?o(e,n):r(e)?o(void 0,e):(t,r)=>o(r??e,t)}flat(t,e){const n=(t,e)=>{let r;const n=new Set;return o(e)&&n.add(e),r=this.enhance(function*t(e,i){let a;for(;;)for(;;)try{for(;;){const r=e.next(a);if(r.done)return r.value;const l=r.value;o(l)&&n.add(l);try{i>0&&h(l)?yield*t(l,i-1):i>0&&w(l)?yield*t(c(l),i-1):a=yield r.value}catch(t){e.throw?.(t)}}}finally{const t=e.return?.(r?.returning);if(o(e)&&n.delete(e),t&&!t.done)break;for(const t of n)t.return(r?.returning)}}(c(e),t))};if("number"==typeof t){if(e){if(r(e))return n(t,e);throw new TypeError(`Invalid Genable: ${e}`)}return e=>n(t,e)}if(r(t))return n(e??1,t);throw new TypeError("Illegal arguments to flat()")}flatMap(t,e,n){const o=(e,r)=>{let n,o=0;return n=this.enhance(function*e(r,i){let l;for(;;)for(;;)try{for(;;){const n=r.next(l);if(n.done)return n.value;const u=t(n.value,o++);try{h(u)?i>1?yield*e(u,i-1):1===i?yield*a(u):yield u:w(u)?i>1?yield*e(c(u),i-1):1===i?yield*a(u):yield u:l=yield u}catch(t){r.throw?.(t)}}}finally{const t=r.return?.(n?.returning);if(t&&!t.done)break}}(c(r),e))};return r(n)?o(e??1,n):r(e)?o(1,e):(t,r)=>o(e??r??1,t)}slice(t,e,r){const n=r=>{const n=c(r);return this.enhance(function*(t,e){for(let e=0;e<t;e++){const t=n.next();if(t.done)return t.value}if(e===Number.POSITIVE_INFINITY)yield*f(n);else{let r;for(;;)try{for(let o=t;o<e;o++){const t=n.next(r);if(t.done)return t.value;try{r=yield t.value}catch(t){const e=n.throw?.(t);if(e){if(e.done)return e.value;r=yield e.value}}}}finally{const t=n.return?.();if(t&&!t.done)break}}}(t,e))};return r?n(r):n}concat(...t){let e;return e=this.enhance(function*(){let r=0;try{for(;r<t.length;r++)yield*f(t[r])}finally{for(;r<t.length;r++){const n=t[r];o(n)&&n.return(e?.returning)}}}())}reduce(t,e,n){const o=(e,r)=>{let n=e;if(void 0===n){const t=r.next();if(t.done)throw new TypeError("No initial value in reduce");n=t.value}for(;;){const e=r.next();if(e.done)return n;n=t(n,e.value)}};return r(n)?o(e,c(n)):r(e)?o(void 0,c(e)):(t,r)=>o(r??e,c(t))}some(t,e,n){const o=(e,r)=>{let n=0;for(;;){const o=r.next();if(o.done)return!1;if(t.call(e,o.value,n++))return!0}};return r(n)?o(e,c(n)):r(e)?o(void 0,c(e)):(t,r)=>o(r??e,c(t))}every(t,e,n){const o=(e,r)=>{let n=0;for(;;){const o=r.next();if(o.done)return!0;if(!t.call(e,o.value,n++))return!1}};if(r(n))return o(e,c(n));if(r(n))return(t,r)=>o(r??e,c(t));throw new Error(`Invalid argument to every: ${n??e}`)}repeatLast(t,e=Number.POSITIVE_INFINITY){const r=c(t);let n,o;return o=this.enhance(function*(){try{let t;for(;;){const e=r.next(n);if(e.done)break;try{n=yield t=e.value}catch(e){const n=r.throw?.(e);if(n){if(n.done)break;yield t=n.value}}}for(let r=0;r<e;r++)yield t}finally{r.return?.(o?.returning)}}())}repeat(t,e=Number.POSITIVE_INFINITY){return this.enhance(function*(){for(let r=0;r<e;r++)yield t}())}zip(...t){if(0===t.length)return this.enhance([]);const e=t.map(c);let r,n=!1;return r=this.enhance(function*(){try{for(;;){let r=[];for(const t of e){const e=t.next();if(e.done)return n=!0,e.value;r.push(e.value)}try{yield r}catch(e){for(const r of t)try{r.throw?.(e)}catch{}throw e}}}finally{if(!n)for(const e of t)try{e.return?.(r?.returning)}catch{}}}())}join(t,e){return"string"==typeof t?(e=t,t=>this.join(t,e)):[...f(t)].join(e)}merge(...t){let e,r=t.map(c);return e=this.enhance(function*(t){let r,n=!1,o=!0;try{for(;o;){o=!1;for(let e=0;e<t.length;e++){const n=t[e];if(n){const i=n.next(r);if(i.done)t[e]=null;else{o=!0;try{r=yield i.value}catch(e){t.forEach(v((t=>t?.throw?.(e))))}}}}}n=!0}finally{n||t.forEach(v((t=>t?.return?.(e?.returning))))}return e?.returning}(r))}sort(t){return(...e)=>this.merge(...e).asArray().sort(t)}enhance(t){const e=a(t),r=Object.getPrototypeOf(e),n=Object.create(b.prototype);return n.return=t=>(e.returning=t,r.return.call(e,t)),n[Symbol.iterator]=()=>e,Object.setPrototypeOf(e,b.prototype),e}},I=Object.getPrototypeOf(function*(){}());Object.setPrototypeOf(b.prototype,(t=>{const e=Object.create(t);return(t=>{for(const r of Reflect.ownKeys(t))"constructor"!==r&&(e[r]=t[r])})(m.prototype),e})(I)),Object.defineProperty(b.prototype,"_impl",{value:g,writable:!1,enumerable:!1,configurable:!1});const x=new class{of(...t){return this.enhance(t)}async asArray(t){const e=u(t),r=[];for(;;){const t=await e.next();if(t.done)return r;r.push(t.value)}}limit(t,e){let r;async function*n(e){let n,o=!1;try{for(let r=0;r<t;r++){const t=await e.next(n);if(t.done)return t.value;try{n=yield t.value}catch(t){await(e.throw?.(t))}}o=!0;const i=new RangeError(`Generator produced excessive values > ${t}.`);throw await(e.throw?.(i)),i}finally{o||await(e.return?.(r?.returning))}}return e?r=this.enhance(n(u(e))):t=>this.enhance(n(u(t)))}forEach(t,e,r){const o=async(t,e,r)=>{const n=u(r);let o=0;for(;;){const r=await n.next();if(r.done)return;await t.call(e,r.value,o++)}};return r?o(t,e,r):n(e)?o(t,void 0,e):(r,n)=>o(t,n??e,r)}map(t,e,r){const o=(e,r)=>{const n=l(r);let o;return o=this.enhance(async function*(){let r,i=0;for(;;)for(;;)try{for(;;){const o=await n.next(r);if(o.done)return o.value;const a=await t.call(e,await o.value,i++);try{r=yield a}catch(t){await n.throw(t)}}}finally{if(!(await n.return(o?.returning)).done)break}}())};return r?o(e,r):n(e)?o(void 0,e):(t,r)=>o(r??e,t)}filter(t,e,r){const o=(e,r)=>{const n=l(r);let o;return o=this.enhance(async function*(t){let r,i=0;for(;;)for(;;)try{for(;;){const o=await n.next(r);if(o.done)return o.value;if(await t.call(e,o.value,i++))try{r=yield o.value}catch(t){await n.throw(t)}}}finally{if(!(await(n.return?.(o?.returning)))?.done)break}}(t))};return r?o(e,r):n(e)?o(void 0,e):(t,r)=>o(r??e,t)}flat(t,e){const r=(t,e)=>{let r;const n=new Set;return i(e)&&n.add(e),r=this.enhance(async function*t(e,o){let a;for(;;)for(;;)try{for(;;){const r=await e.next(a);if(r.done)return r.value;const l=r.value;i(l)&&n.add(l);try{o>0&&d(l)?yield*t(l,o-1):o>0&&(p(l)||w(l))?yield*t(u(l),o-1):a=yield r.value}catch(t){await(e.throw?.(t))}}}finally{const t=await(e.return?.(r?.returning));if(i(e)&&n.delete(e),t&&!t.done)break;for(const t of n)await t.return(r?.returning)}}(u(e),t))};if("number"==typeof t){if(e){if(n(e))return r(t,e);throw new TypeError(`Invalid Genable: ${e}`)}return e=>r(t,e)}if(n(t))return r(e??1,t);throw new TypeError("Illegal arguments to flat()")}flatMap(t,e,r){const o=(e,r)=>{let n,o=0;return n=this.enhance(async function*e(r,i){let a;for(;;)for(;;)try{for(;;){const n=await r.next(a);if(n.done)return n.value;const c=await t(n.value,o++);try{if(d(c))if(i>1)yield*e(c,i-1);else if(1===i){const t=u(c);yield*l(t)}else yield c;else p(c)||w(c)?i>1?yield*e(u(c),i-1):1===i?yield*l(c):yield c:a=yield c}catch(t){await(r.throw?.(t))}}}finally{const t=await(r.return?.(n?.returning));if(t&&!t.done)break}}(u(r),e))};return n(r)?o(e??1,r):n(e)?o(1,e):(t,r)=>o(e??r??1,t)}slice(t,e,r){const n=r=>{const n=u(r);return this.enhance(async function*(t,e){for(let e=0;e<t;e++){const t=await n.next();if(t.done)return t.value}if(e===Number.POSITIVE_INFINITY)yield*y(n);else{let r;for(;;)try{for(let o=t;o<e;o++){const t=await n.next(r);if(t.done)return t.value;try{r=yield t.value}catch(t){const e=await(n.throw?.(t));if(e){if(e.done)return e.value;r=yield e.value}}}}finally{const t=await(n.return?.());if(t&&!t.done)break}}}(t,e))};return r?n(r):n}concat(...t){let e;return e=this.enhance(async function*(){let r=0;try{for(;r<t.length;r++){const e=y(t[r]);yield*e}}finally{for(;r<t.length;r++){const n=t[r];i(n)&&await n.return(e?.returning)}}}())}reduce(t,e,r){const o=async(e,r)=>{let n=await e;if(void 0===n){const t=await r.next();if(t.done)throw new TypeError("No initial value in reduce");n=t.value}for(;;){const e=await r.next();if(e.done)return n;n=await t(n,e.value)}};return n(r)?o(e,u(r)):n(e)?o(void 0,u(e)):(t,r)=>o(r??e,u(t))}some(t,e,r){const o=async(e,r)=>{let n=0;for(;;){const o=await r.next();if(o.done)return!1;if(t.call(e,o.value,n++))return!0}};if(n(r))return o(e,u(r));if(n(r))return(t,r)=>o(r??e,u(t));throw new Error(`Invalid argument to some: ${r??e}`)}every(t,e,o){const i=async(e,r)=>{let n=0;for(;;){const o=await r.next();if(o.done)return!0;if(!t.call(e,o.value,n++))return!1}};if(n(o))return i(e,u(o));if(r(o))return(t,r)=>i(r??e,u(t));throw new Error(`Invalid argument to every: ${o??e}`)}repeatLast(t,e=Number.POSITIVE_INFINITY){const r=u(t);let n,o;return o=this.enhance(async function*(){try{let t;for(;;){const e=await r.next(n);if(e.done)break;try{n=yield t=e.value}catch(e){const n=await(r.throw?.(e));if(n){if(n.done)break;yield t=n.value}}}for(let r=0;r<e;r++)yield await t}finally{await(r.return?.(o?.returning))}}())}repeat(t,e=Number.POSITIVE_INFINITY){return this.enhance(async function*(){for(let r=0;r<e;r++)yield await t}())}zip(...t){if(0===t.length)return this.enhance([]);const e=t.map(u);let r,n=!1;return r=this.enhance(async function*(){try{for(;;){let r=[];for(const t of e){const e=await t.next();if(e.done)return n=!0,e.value;r.push(e.value)}try{yield r}catch(e){for(const r of t)try{await(r.throw?.(e))}catch{}throw e}}}finally{if(!n)for(const e of t)try{await(e.return?.(r?.returning))}catch{}}}())}join(t,e){return"string"==typeof t?(e=t,t=>this.join(t,e)):Promise.resolve(this.enhance(t).asArray()).then((t=>t.join(e)))}merge(...t){let e,r;const n=new Promise((t=>r=t));let o,i=t.length;const a=new Promise((()=>null));let l=[];return o=[...t.map((async(t,e)=>{const n=u(t);l[e]=n;const c=async t=>()=>{if(t.done)return o[e]=a,--i>0?null:(r(t),t);{const r=n.next().then(c);return o[e]=r,t}};return await n.next().then(c)})),n],e=x.enhance(async function*(){try{let r;for(;i;){const t=[];o.forEach((e=>t.push(e)));const e=await await Promise.race(t);if("function"==typeof e){let t=e();if(t){if(t.done)return t.value;r=yield t.value}}else if(e&&e.done)return e.value}}finally{if(i)for(let r=0;r<t.length;r++)(null===o[r]?null:l[r])?.return?.(e?.returning)}}())}sort(t){return async(...e)=>(await this.merge(...e).asArray()).sort(t)}enhance(t){const e=l(t),r=Object.getPrototypeOf(e),n=Object.assign(Object.create(N.prototype),r);return n.return=t=>(e.returning=t,r.return.call(e,t)),n[Symbol.asyncIterator]=()=>e,Object.setPrototypeOf(e,n),e}};class N extends m{}const O=Object.getPrototypeOf(async function*(){}());Object.setPrototypeOf(N.prototype,(t=>{const e=Object.create(t);return(t=>{for(const r of Reflect.ownKeys(t))"constructor"!==r&&(e[r]=t[r])})(m.prototype),e})(O)),Object.defineProperty(N.prototype,"_impl",{value:x,writable:!1,enumerable:!1,configurable:!1});const E=g,_=x;t.Async=_,t.Sync=E,Object.defineProperty(t,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).generators={});
//# sourceMappingURL=generators.js.map
